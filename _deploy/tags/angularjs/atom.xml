<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: AngularJS | Thinking in Crowd / 鹄思乱想]]></title>
  <link href="http://www.thinkingincrowd.me/tags/angularjs/atom.xml" rel="self"/>
  <link href="http://www.thinkingincrowd.me/"/>
  <updated>2014-03-28T20:34:31+08:00</updated>
  <id>http://www.thinkingincrowd.me/</id>
  <author>
    <name><![CDATA[鹄思乱想]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Thanks to everyone, Zach Lendon, Github, AngularJS]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2013/09/24/thanks-to-everyone-zach-lendon-github-angularjs/"/>
    <updated>2013-09-24T06:24:00+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2013/09/24/thanks-to-everyone-zach-lendon-github-angularjs</id>
    <content type="html"><![CDATA[<p>Today I just wander around Google Analytics to check my blog&rsquo;s visits count.  I am so pleased to find that the visit counts keeps increasing.  Below are some figures:</p>

<ol>
<li>Total Visits <strong>616</strong></li>
<li>Unique Visitors: <strong>555</strong></li>
<li>Pageviews: <strong>793</strong></li>
<li>Pages / visit: <strong>1.29</strong></li>
<li>% New Visits: <strong>88.31%</strong></li>
</ol>


<p>Thanks to everyone who visited my blogs and made all those suggestive comments, such as Da.  I will strive to write more valuable articles to keep my knowledge and help others.  Hopefully, the return visits can grow more.</p>

<p>I happened to found that This particular <a href="http://www.thinkingincrowd.me/blog/2013/06/08/how-to-verify-json-data-with-angularjs-httpbackend/">article</a> about <a href="http://angularjs.org">AngularJS</a> <a href="http://docs.angularjs.org/api/ngMock.$httpBackend">$httpBackend</a> brought me <strong>215</strong> visits.  I think that should be due to a patch I submitted to AngularJS in <a href="https://github.com">Github</a>.  How valuable for that patch!!  I will try to contribute more to the opensource.</p>

<p>Personally, I need to thank Zach Lendon who has referred my blog in his article about <a href="http://zachlendon.github.io/blog/2013/04/02/updated-extjs4-mock-ajax-library-for-jasmine/">ExtJS4 Ajax testing</a>.  His referral brought me <strong>8</strong> visits.  I originally want to thank him in his blog but there is no comments enabled there.  So here gives my sincere thanks too.</p>

<p>Do not ask but give.  You will earn more.  Thanks guys.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to support page content i18n in AngularJS]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2013/08/29/how-to-support-page-content-i18n-in-angularjs/"/>
    <updated>2013-08-29T20:16:00+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2013/08/29/how-to-support-page-content-i18n-in-angularjs</id>
    <content type="html"><![CDATA[<p><a href="http://code.angularjs.org/1.0.8/docs/guide/i18n">i18n</a> (Internationalization) is one of the development guide section in AngularJS.  However, the doc doesn&rsquo;t really help us a lot to do what we want basically for i18n, language change support of the web page content.</p>

<p>As an <a href="http://en.wikipedia.org/wiki/Single-page_application">SPA</a> (Single Page Application), the view in <a href="http://angularjs.org">AngularJS</a> is partially loaded, rendered and even cached at client side.  When user switches the language, how can we rerender the page with another language?</p>

<p>My idea is to make the label or web page content as a binding model linked with the language.  If the language value is changed when users switch language, those label models should be updated.  It works smoothly but I haven&rsquo;t done performance test for extremely large page yet.</p>

<p>Let&rsquo;s see how it&rsquo;s done.</p>

<p>First, I need to define a Service which is used to fetch language resource file, cache them locally, and do the translation.</p>

<p>```javascript</p>

<pre><code>factory('LocaleManager', function($resource, $rootScope) {
    var langs = {},
        LocaleManager = $resource('/js/i18n/resources-locale_:lang.js',
            {port: ':3000', lang: 'en_US'});

    LocaleManager.load = function(language) {
        if (langs[language]) {
            if ($rootScope.language !== language) {
                $rootScope.language = language;
            }
            return;
        }

        return LocaleManager.get({lang: language}, function(data) {
            langs[language] = data;
            $rootScope.language = language;
        });
    };

    LocaleManager.getText = function(text, language) {
        if (language === 'en_US') {
            return text;
        }
        if (langs[language] &amp;&amp; langs[language][text]) {
            return langs[language][text];
        }
        return text;
    };

    return LocaleManager;
})
</code></pre>

<p>```</p>

<p>You can find that there is a <a href="http://code.angularjs.org/1.0.8/docs/api/ng.$rootScope">$rootScope</a> level variable <em>language</em>  which is set to the user selected language when <em>LocaleManager.load</em> is called.</p>

<p>Later if we use the <a href="http://code.angularjs.org/1.0.8/docs/api/ng.$interpolate">$interpolate</a> like below in the view, the text value can be updated whenever the <em>$rootScope.language</em> is changed.</p>

<p></p>

<pre><code>{{ LocaleManager.getText('Login', language) }}
</code></pre>

<p></p>

<p>An alternative approach is to define a <a href="http://docs.angularjs.org/api/ng.$filter">$filter</a> for translation instead of calling a method from Service class.  Haven&rsquo;t tried that yet and will give an update here once done.</p>

<p>Do you have experience on i18n in AngularJS?  Thoughts and comments are appreciated.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to verify JSON data with AngularJS $httpBackend]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2013/06/08/how-to-verify-json-data-with-angularjs-httpbackend/"/>
    <updated>2013-06-08T22:17:00+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2013/06/08/how-to-verify-json-data-with-angularjs-httpbackend</id>
    <content type="html"><![CDATA[<p>When we are writing Unit Test for AngularJS Controller or Service, it&rsquo;s pretty common to verify the data posted to server using <a href="http://docs.angularjs.org/api/ngMock.$httpBackend">$httpBackend</a> in ngMock module.</p>

<p>Consider the most common method: <em>expect(method, url, data, headers)</em>, from the doc, we find that the data is expected to be either <em>String</em> or <em>RegExp</em>.</p>

<blockquote><p><strong>expect(method, url, data, headers)</strong><br/>
Creates a new request expectation.</p>

<p>Parameters<br/>
* method – {string} – HTTP method.<br/>
* url – {string|RegExp} – HTTP url.<br/>
* data(optional) – {(string|RegExp)=} – HTTP request body.</p></blockquote>

<p>So normally, below simple case is working as expected:</p>

<p>```javascript</p>

<pre><code>$httpBackend.expect('POST', 'http://localhost/timeEntry', 'hello').respond(200, 'Done');
$resource('http://localhost/timeEntry/').save('hello');
$httpBackend.flush();

$httpBackend.expect('POST', 'http://localhost/timeEntry', /te/g).respond(200, 'Done');
$resource('http://localhost/timeEntry/').save('test');
$httpBackend.flush();
</code></pre>

<p>```</p>

<p>However, in real application, the data posted to server is normally in JSON format.  How do we verify JSON data then?  Actually, if we look into the source of the <em>angular-mocks.js</em>, it supports JSON data too although it&rsquo;s not documented.</p>

<p>```javascript
  this.matchData = function(d) {</p>

<pre><code>if (angular.isUndefined(data)) return true;
if (data &amp;&amp; angular.isFunction(data.test)) return data.test(d);
if (data &amp;&amp; !angular.isString(data)) return angular.toJson(data) == d;
return data == d;
</code></pre>

<p>  };
```</p>

<p>So below sample also works.</p>

<p>```javascript</p>

<pre><code>$httpBackend.expect('POST', 'http://localhost/timeEntry', {firstName: 'Ken', lastName: 'Chen'}).respond(200, 'Done');
$resource('http://localhost/timeEntry/').save({firstName: 'Ken', lastName: 'Chen'});
$httpBackend.flush();
</code></pre>

<p>```</p>

<p>As we see, the JSON data validation requires the JSON data posted to be exactly the same as the expect value provided.  How if the JSON data posted is different on each posting, say guid or timestamp field is contained, and we want to verify whether the JSON data is valid based on our special valiation logic?</p>

<p>Here is the hack to make AngularJS take our special validation logic.</p>

<p>```javascript</p>

<pre><code>var Validator = (function() {
    return {
        hasMinimumFields: function(entry) {
            return StringUtil.isNotBlank(entry.id) &amp;&amp; StringUtil.isNotBlank(entry.desc) &amp;&amp;
                StringUtil.isNotBlank(entry.lastUpdateOn) &amp;&amp; StringUtil.isNotBlank(entry.status);
        },
        isNewEntry: function(entry) {
            return this.hasMinimumFields(entry) &amp;&amp; entry.status === 'P';
        }
    };
})();

$scope.desc = 'Hello there';

var data = {
    test: function(data) {
        var entry = angular.fromJson(data);
        return (entry.desc === $scope.desc) &amp;&amp; Validator.isNewEntry(entry);
    }
};
$httpBackend.expect('POST', 'http://localhost/timeEntry', data).respond(200, 'Done');
$scope.saveEntry(); // Let's assume this method will post the data with model $scope.desc
$httpBackend.flush();
</code></pre>

<p>```</p>

<p>The hacking as you see is to take advantage of the <em>test</em> method which the <em>RegExp</em> has and AngularJS uses for data matching.  But when the data is not posted as expected, the Unit Test fails with below message:</p>

<p>```javascript</p>

<pre><code>Chrome 27.0 (Linux) Unit: Controllers Test EntryCtrl should start entry in correct format if only entry desc is filled. FAILED
Error: Expected POST http://localhost/timeEntry with different data
EXPECTED: {}
GOT:      {"status":"P","actualStartOn":"2013/06/08T21:24+0800","desc":"First Unit Test","id":"3849ae1a-4b9c-40be-baa0-60eeaf3af430","lastUpdateOn":"2013/06/08T13:24:44.104+0000"}
</code></pre>

<p>```</p>

<p>This error message is not quite developer friendly and it doesn&rsquo;t tell you much about why it failed at first glance.  However, if we make the test data contain the JSON value too, the expect message would be more meaningful.</p>

<p>```javascript</p>

<pre><code>var data = {
    desc: $scope.desc,
    status: 'P',
    id: 'SHOULD NOT BLANK',
    lastUpdateOn: 'SHOULD NOT BLANK',
    test: function(data) {
        var entry = angular.fromJson(data);
        return (entry.desc !== $scope.desc) &amp;&amp; Validator.isNewEntry(entry);
    }
};
</code></pre>

<p>```</p>

<p><code>javascript
EXPECTED: {"desc":"First Unit Test","status":"P","id":"SHOULD NOT BLANK","lastUpdateOn":"SHOULD NOT BLANK"}
</code></p>

<p><em>[Edited on Aug 09th 2013]</em>: After AngularJS accepted my <a href="https://github.com/angular/angular.js/pull/2981">pull request</a> to support Function as validation data last week, we don&rsquo;t need to use duck-typing for the hack.  The validation logic can be simplified as below and we can even override the Function&rsquo;s <em>toString()</em> method to give more expressive error message in a cleaner way.</p>

<p>```javascript</p>

<pre><code>var data = function(data) {
    var entry = angular.fromJson(data);
    return (entry.desc !== $scope.desc) &amp;&amp; Validator.isNewEntry(entry);
};
data.toString = function() {
    return 'The status of the new entry should be "P", desc should be "' + $scope.desc +
        '" and its id &amp; lastUpdateOn should not be blank.';
};
</code></pre>

<p>```</p>

<p><code>javascript
EXPECTED: The status of the new entry should be "P", desc should be "First Unit Test" and its id &amp; lastUpdateOn should not be blank.
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Expression in AngularJS must be idempotent and for multiple calls]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2013/02/02/expression-in-angularjs-must-be-idempotent-and-for-multiple-calls/"/>
    <updated>2013-02-02T14:32:00+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2013/02/02/expression-in-angularjs-must-be-idempotent-and-for-multiple-calls</id>
    <content type="html"><![CDATA[<p>Recently, I encounter two very interesting issues when using ng-repeat in <a href="http://angularjs.org">AngularJS</a>.  Not completely understanding the <a href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$watch">$watch</a> and <a href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$digest">$digest()</a> is the root cause.</p>

<h2>Requirement</h2>

<p>I am making some workout entries as a list and one special requirement is to group the records by the date.</p>

<p>In order to break the entries to different groups, I use a scope level variable <em>$scope.lastActionDate</em> to keep track of the last actionDate of the entry to decide whether I should add the actionDateGroup DIV.  The source is as below.  The debug messages are used to explain the issues I encountered.  You can safely ignore them now.  Actually, you may already guess what one of the issues is after seeing them.  Yes, only one.  I bet you can never guess the second one and why.</p>

<p>
``` html</p>

<pre><code>&lt;style&gt;
    body {font-family: 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;}
    ul li {list-style-type: none;}
    .actionDateGroup {font-weight: bold; color: red}
&lt;/style&gt;
&lt;div id="content" ng-controller="EntryCtrl"&gt;
    &lt;div id="entries"&gt;
        &lt;ul&gt;
            &lt;li ng-repeat="entry in entries"&gt;
                &lt;div ng-switch on="isNewDateGroup(entry.actionDate)"&gt;
                    &lt;div ng-switch-when="true" class="actionDateGroup"&gt;{{entry.actionDate}}&lt;/div&gt;
                &lt;/div&gt;
                &lt;span&gt;{{entry.desc}}&lt;/span&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;script type="text/javascript" src="./js/angular/angular.js"&gt;&lt;/script&gt;
&lt;script&gt;
    function EntryCtrl($scope, $location) {
        $scope.entries = [{
            desc: 'Rope jumping count 1000',
            actionDate: '2012-01-31',
        },{
            desc: 'Jogging 3000M',
            actionDate: '2012-01-31'
        },{
            desc: 'Situp 40 * 3',
            actionDate: '2012-01-30'
        }];
        $scope.lastActionDate = null;
        $scope.calledCount = 0;

        $scope.isNewDateGroup = function(actionDate) {
            $scope.calledCount++;
            console.log('Function called count: ' + $scope.calledCount);
            console.log('Entry date vs Scope date: ' + actionDate + ' vs ' + $scope.lastActionDate);
            if ($scope.lastActionDate === null || $scope.lastActionDate !== actionDate) {
                $scope.lastActionDate = actionDate;
                return true;
            }
            return false;
        };
    }
&lt;/script&gt;
</code></pre>

<p>```
</p>

<h2>Expectation</h2>

<ol>
<li><em>actionDate</em> of the first entry will always be shown as it&rsquo;s the first group.</li>
<li><em>actionDate</em> of the remaining entries will be shown if its value is not the same as the previous one.</li>
</ol>


<h2>Phenomenon</h2>

<p>When the sample data is as above (case #1), the effect looks like it&rsquo;s behaving correctly as below:</p>

<ul>
    <li style="list-style-type: none;">
        <div style="font-weight: bold; color: red">2012-01-31</div>
        <span>Rope jumping count 1000</span>
    </li>
    <li style="list-style-type: none;">
        <span>Jogging 3000M</span>
    </li>
    <li style="list-style-type: none;">
        <div style="font-weight: bold; color: red">2012-01-30</div>
        <span>Situp 40 * 3</span>
    </li>
</ul>


<p>However, if you change the <em>actionDate</em> of the last entry to be also <strong>2012-01-31</strong> (case #2), you will find the result is that no date group is shown.  Why?  Isn&rsquo;t it supposed to show only the first one as all entries have the same <em>actionDate</em>?</p>

<h4>Expected result:</h4>

<ul>
    <li style="list-style-type: none;">
        <div style="font-weight: bold; color: red">2012-01-31</div>
        <span>Rope jumping count 1000</span>
    </li>
    <li style="list-style-type: none;">
        <span>Jogging 3000M</span>
    </li>
    <li style="list-style-type: none;">
        <span>Situp 40 * 3</span>
    </li>
</ul>


<h4>Actual result:</h4>

<ul>
    <li style="list-style-type: none;">
        <span>Rope jumping count 1000</span>
    </li>
    <li style="list-style-type: none;">
        <span>Jogging 3000M</span>
    </li>
    <li style="list-style-type: none;">
        <span>Situp 40 * 3</span>
    </li>
</ul>


<p>Now if you check the calledCount in the debug message, you will find that it&rsquo;s called 6 times (double the entry count) in case #1 and 9 times in case #2.  There are two issues I never thought they should happen:</p>

<ol>
<li>The <em>isNewDateGroup</em> function is called more than the entries' count.  (Guess this, right?)</li>
<li>The called count is different when the data is different.  (how about this?)</li>
</ol>


<h2>Causes</h2>

<p>In AngularJS <a href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$watch">$watch</a> API:</p>

<blockquote><ul>
<li>Since <a href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$digest">$digest()</a> reruns when it detects changes the watchExpression can execute multiple times per <a href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$digest">$digest()</a> and should be <strong>idempotent</strong>.</li>
<li>The listener is called only when the value from the current watchExpression and the previous call to watchExpression are not equal <strong>(with the exception of the initial run, see below)</strong> &hellip;</li>
<li>The watch listener may change the model, which may trigger other listeners to fire. This is achieved by <strong>rerunning the watchers until no changes are detected</strong>. The rerun iteration limit is 10 to prevent an infinite loop deadlock.
&hellip;
(Since watchExpression can execute multiple times per $digest cycle when a change is detected, be prepared for multiple calls to your listener.)</li>
</ul>
</blockquote>

<h3>Issue #1</h3>

<p>The <em>isNewDateGroup</em> being watched whose calculation relies on value of <em>lastActionDate</em> is not idempotent and so during initial run stage, <em>lastActionDate</em> is set to 2012-01-30 at the end of case #1 which causes the illusion of working, while it is set to 2012-01-31 at the end of case #2 which illustrates the error.</p>

<h3>Issue #2</h3>

<p>In below code, if I comment out <strong>$scope.lastActionDate = actionDate;</strong> or change the <strong>return true;</strong> to <strong>return false;</strong>, the called count will be 6, same as case #1.  This implies that the return value of the expression is the cause.</p>

<p>``` javascript</p>

<pre><code>if ($scope.lastActionDate === null || $scope.lastActionDate !== actionDate) {
    $scope.lastActionDate = actionDate;
    return true;
}
</code></pre>

<p>```</p>

<p>Remember what the API states: <strong>rerunning the watchers until no changes are detected</strong>?  Let&rsquo;s see what the return value is for watch expression <em>isNewDateGroup</em> after each run.</p>

<p>If the <em>actionDate</em> of the last entry is <strong>2012-01-30</strong>:</p>

<p>
<table style="font-size: 0.85em;">
    <tr>
        <td style="padding: 5px; border: 1px solid black;"></td>
        <td style="padding: 5px; border: 1px solid black; font-weight: bold;">Rope jumping</td>
        <td style="padding: 5px; border: 1px solid black; font-weight: bold;">Jogging</td>
        <td style="padding: 5px; border: 1px solid black; font-weight: bold;">Situp</td>
    </tr>
    <tr>
        <td style="padding: 5px; border: 1px solid black;">1st <br/>(initial)</td>
        <td style="padding: 5px; border: 1px solid black;">true ($scope.lastActionDate === null)</td>
        <td style="padding: 5px; border: 1px solid black;">false</td>
        <td style="padding: 5px; border: 1px solid black;">true ('2012-01-31' !== '2012-01-30';<br/>
        $scope.lastActionDate = '2012-01-30')
        </td>
    </tr>
    <tr>
        <td style="padding: 5px; border: 1px solid black;">2nd</td>
        <td style="padding: 5px; border: 1px solid black;">true ($scope.lastActionDate !== '2012-01-31')</td>
        <td style="padding: 5px; border: 1px solid black;">false</td>
        <td style="padding: 5px; border: 1px solid black;">true</td>
    </tr>
</table>
</p>


<p>If the <em>actionDate</em> of the last entry is <strong>2012-01-31</strong>:</p>

<p>
<table style="font-size: 0.85em;">
    <tr>
        <td style="padding: 5px; border: 1px solid black;"></td>
        <td style="padding: 5px; border: 1px solid black; font-weight: bold;">Rope jumping</td>
        <td style="padding: 5px; border: 1px solid black; font-weight: bold;">Jogging</td>
        <td style="padding: 5px; border: 1px solid black; font-weight: bold;">Situp</td>
    </tr>
    <tr>
        <td style="padding: 5px; border: 1px solid black;">1st <br/>(initial)</td>
        <td style="padding: 5px; border: 1px solid black;">true ($scope.lastActionDate === null)</td>
        <td style="padding: 5px; border: 1px solid black;">false</td>
        <td style="padding: 5px; border: 1px solid black;">false</td>
    </tr>
    <tr>
        <td style="padding: 5px; border: 1px solid black;">2nd</td>
        <td style="padding: 5px; border: 1px solid black;">false (change compared to last run)</td>
        <td style="padding: 5px; border: 1px solid black;">false</td>
        <td style="padding: 5px; border: 1px solid black;">false</td>
    </tr>
    <tr>
        <td style="padding: 5px; border: 1px solid black;">3rd</td>
        <td style="padding: 5px; border: 1px solid black;">false</td>
        <td style="padding: 5px; border: 1px solid black;">false</td>
        <td style="padding: 5px; border: 1px solid black;">false</td>
    </tr>
</table>
</p>


<p>So now you see why changing the last entry to 2012-01-31 causes the 3rd time to evaluate the expression again.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[String interpolation should not be used with Class Directive in AngularJS]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2013/01/30/string-interpolation-should-not-be-used-with-class-directive-in-angularjs/"/>
    <updated>2013-01-30T07:02:00+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2013/01/30/string-interpolation-should-not-be-used-with-class-directive-in-angularjs</id>
    <content type="html"><![CDATA[<p>Do you see any issue in below HTML snippet with <a href="http://angularjs.org">AngularJS</a> code?<br/>

``` html</p>

<pre><code>&lt;span ng-class="task-{{task.type}}"&gt;{{task.type}}&lt;/span&gt;
&lt;input type="text" ng-model="task.type"/&gt;
</code></pre>

<p>```
</p>

<p>Do you see what is the difference between the one below and above?<br/>

``` html</p>

<pre><code>&lt;span ng-class="'task-' + task.type"&gt;{{task.type}}&lt;/span&gt;
&lt;input type="text" ng-model="task.type"/&gt;
</code></pre>

<p>```
</p>

<p>The first one use String interpolation in Class <a href="http://docs.angularjs.org/guide/directive">Directive</a>.  The result is that the css class you expect to got based on model value <em>task.type</em> will not be applied to the <em>span</em> element. It took me a long time to figure out why.</p>

<p>Before furher reading, it&rsquo;s better if you have read the Developer Guide, <a href="http://docs.angularjs.org/guide/directive">Directive</a> section which explains the concept of <strong>String interpolation</strong> and <strong>Compilation process, and directive matching</strong>, although honestly, it doesn&rsquo;t quite clearly say how the String interpolation should or can be used.  Before, I just have the rough idea that it can be evaluated and replaced in String and also reflect the change from model.</p>

<p>If you use the first code snippet to create sample AngularJS page and bind an <em>task</em> model to it, you can see that the String Interpolation &ldquo;<em>works</em>&rdquo;: the ng-class attribute and the content of the span tag can be replaced correctly with model value.  Even if you change the model value through the input field, they can be updated accordingly.  However, the CSS is not applied as expected.</p>

<p>Why?  Let&rsquo;s take a look at AngularJS source:</p>

<p>In function <em>collectDirectives</em>, when it checks the element&rsquo;s attribute, it calls <em>addAttrInterpolateDirective</em> before <em>addDirective</em>.  In <em>addAttrInterpolateDirective</em>, the <a href="http://docs.angularjs.org/guide/expression">Expression</a> in String interpolation will be converted to a new directive with compile function to watch the change and set new value to the attribute which is the class directive in this case.  There are two important things need to be aware of:</p>

<ol>
<li>A new directive is ad-hoc created before the class directive it&rsquo;s inspecting.</li>
<li>The new directive&rsquo;s linking function is watching the expression change to update the class directive value itself.</li>
</ol>


<p>```javascript</p>

<pre><code>function collectDirectives(node, directives, attrs, maxPriority) {
  var nodeType = node.nodeType,
      attrsMap = attrs.$attr,
      match,
      className;

  switch(nodeType) {
    case 1: /* Element */
      // use the node name: &lt;directive&gt;
      addDirective(directives,
          directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority);

      // iterate over the attributes
      for (var attr, name, nName, value, nAttrs = node.attributes,
               j = 0, jj = nAttrs &amp;&amp; nAttrs.length; j &lt; jj; j++) {
        attr = nAttrs[j];
        if (attr.specified) {
          name = attr.name;
          nName = directiveNormalize(name.toLowerCase());
          ...
          addAttrInterpolateDirective(node, directives, value, nName);
          addDirective(directives, nName, 'A', maxPriority);
        }
      }
      ...
    }
    ...
}

function addAttrInterpolateDirective(node, directives, value, name) {
  var interpolateFn = $interpolate(value, true);

  // no interpolation found -&gt; ignore
  if (!interpolateFn) return;

  directives.push({
    priority: 100,
    compile: valueFn(function(scope, element, attr) {
      var $$observers = (attr.$$observers || (attr.$$observers = {}));
      ...
      attr[name] = undefined;
      ($$observers[name] || ($$observers[name] = [])).$$inter = true;
      (attr.$$observers &amp;&amp; attr.$$observers[name].$$scope || scope).
        $watch(interpolateFn, function(value) {
          attr.$set(name, value);
        });
    })
  });
}
</code></pre>

<p>```</p>

<p>Let&rsquo;s see how class directive works now.  It&rsquo;s at function <em>classDirective</em>.  If you put an expression in class directive, it will watch that.  Once there is any value change, it adds/removes class from element.  Hence, the second example above works correctly.</p>

<p>```javascript</p>

<pre><code>function classDirective(name, selector) {
  name = 'ngClass' + name;
  return ngDirective(function(scope, element, attr) {
    scope.$watch(attr[name], function(newVal, oldVal) {
      if (selector === true || scope.$index % 2 === selector) {
        if (oldVal &amp;&amp; (newVal !== oldVal)) {
           if (isObject(oldVal) &amp;&amp; !isArray(oldVal))
             oldVal = map(oldVal, function(v, k) { if (v) return k });
           element.removeClass(isArray(oldVal) ? oldVal.join(' ') : oldVal);
         }
         if (isObject(newVal) &amp;&amp; !isArray(newVal))
            newVal = map(newVal, function(v, k) { if (v) return k });
         if (newVal) element.addClass(isArray(newVal) ? newVal.join(' ') : newVal);      }
    }, true);
  });
}
</code></pre>

<p>```</p>

<p>However, if you put String interpolation into it, it will be watching <strong>undefined</strong>.  Why?  Remember what <em>addAttrInterpolateDirective</em> does?  An extra directive is added before this class directive and so its linking function runs before the one for class directive.  And one more thing I omit above: its linking function explicitly sets <strong>attr[name] = undefined;</strong>.  Hence, when the linking functions run sequentially, the class directive&rsquo;s linking function doesn&rsquo;t watch the expression in String interpolation or the value derived although the String interpolation itself works correctly to set the value to class directive.</p>

<p>Hence, in order to set CSS class on HTML element dynamically, we should either use:</p>

<ul>
<li>ng-class / ng-class-odd / ng-class-even without String interpolation by directly using model value or Expression.</li>
</ul>


<p>or</p>

<ul>
<li>HTML class attribute directly with String interpolation.</li>
</ul>

]]></content>
  </entry>
  
</feed>
