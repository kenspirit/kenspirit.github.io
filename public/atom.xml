<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thinking in Crowd / 鹄思乱想</title>
  <subtitle>Swan flying in the immense sky</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.thinkingincrowd.me/"/>
  <updated>2019-01-05T02:36:24.945Z</updated>
  <id>http://www.thinkingincrowd.me/</id>
  
  <author>
    <name>鹄思乱想</name>
    <email>chengusky@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个人的目标都不容易实现，何况两个人的？</title>
    <link href="http://www.thinkingincrowd.me/2019/01/05/accomplish-two-people-goal-is-difficult-than-your-own/"/>
    <id>http://www.thinkingincrowd.me/2019/01/05/accomplish-two-people-goal-is-difficult-than-your-own/</id>
    <published>2019-01-05T02:33:45.000Z</published>
    <updated>2019-01-05T02:36:24.945Z</updated>
    
    <content type="html"><![CDATA[<p>新年伊始，你是否已经设下了新的计划，希望迎来新的改变？  </p>
<p>改变，萌生于现实和理想之间的差距，目标就是向自己认为好的，正确的方向发展，消除不一致。  </p>
<p>我们经常对自己，或者身边的人发出改变的期望，希望自己，伴侣，或者子女变得更健康，上进，懂事等。  </p>
<p>可是，这么多年，减肥，锻炼，写作，早起，学英语，这些口号你都喊了多少遍，能坚持下来的有几个？还是说，你的新年愿望是：明年一定要完成今年应该完成的去年没完成的前年的愿望？  </p>
<p>改变自己已经那么不容易，可我们往往还希望改变他人。  </p>
<p>我们理所当然地认为，既然我要 Ta 改变，就是因为 Ta 当前的做法或想法和我不一致。如果我们的想法和观点达成一致了，改变就能启动了。所以，我们经常企图说服对方。  </p>
<p>尤其是在亲密关系里，我们很容易就想改变对方。其实，即便你是被要求改变的一方，很可能你也是在用消极，不配合的方式来默默地期望对方改变，接纳你认可的方式，让对方放弃自己的想法。  </p>
<p>拿我自己来举例子吧。  </p>
<p>老婆其实好几年前就想买车。但是，我一直认为那是消耗品，租车也很方便，就一直没同意。她一直想改变我的想法，而我总是没被说服。我也在默默期望她能认同我的观点。我们就这么一直耗着。  </p>
<p>2018 年底，我终于同意并落实了这件事情了。  </p>
<p>为什么现在的我又答应了呢？是我改变了吗？并没有。目前为止，我还是觉得，相比坐公司班车，自己开车上下班比较累。要远途出游，还是可以租车。虽然自己有车是便利，但是没有舒服到我需要花大价钱拥有它。  </p>
<p>我之所以选择了 <strong>「合作」</strong>，是因为<strong>我们的目标其实是一致的：改善生活</strong>。  </p>
<p>她觉得有了车，可以更常回老家；更容易和朋友结伴出游；偶尔随性的，不需要提前准备和等待的，就可以去某一个地方。这是她认为重要的东西。这是她认为改善生活需要改变的部分。虽然我认为有其它替代买车的选择，但是如果我把赚的钱花在其它我认为是改善生活的地方，家人却不认同，那有什么用呢？  </p>
<p>既然那些钱都是赚来改善生活的，她得益，我也得益，那不就是实现目标了吗？  </p>
<ul>
<li>买车：她爽；我爽（不被唠叨）  </li>
<li>不买车：她不爽；我不爽（被唠叨）  </li>
</ul>
<p>所以，即便还没有被说服，我还是选择合作。改善生活的目标没变，只是手段，或者各自改善的地方不一样而已。  </p>
<p><strong>包容，求同存异，是爱和维护关系中重要的一部分</strong>。要做到这样，最重要的是看清楚共同的目标是什么。还有，要能平和地看到各自的需求，需要在脑里牢牢地植入这么一个概念：<strong>「我们想法不一样，但是都没有错」</strong>。这个观念非常的重要。如果我们认为对方和我们不同，就是错了，那非常容易就会陷入要说服对方的困境。如果对方也认为自己没有错，那凭什么要 Ta 按照你说的来改变，而你却不能按 Ta 的想法来做呢？  </p>
<p>我这个理工直男死脑子，可是在听了李松蔚的「洞悉相处之道」课程，和持续看他的一些文章后，才慢慢转过弯来的。  </p>
<p>所以，当你期望对方改变的时候，先想想你们的共同目标是什么。从目标层面来讨论合作的方式，别急着让对方改变。附上李松蔚的两篇关于改变的文章，让你们看看这个前理工直男的有意思的角度：  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新年伊始，你是否已经设下了新的计划，希望迎来新的改变？  &lt;/p&gt;
&lt;p&gt;改变，萌生于现实和理想之间的差距，目标就是向自己认为好的，正确的方向发展，消除不一致。  &lt;/p&gt;
&lt;p&gt;我们经常对自己，或者身边的人发出改变的期望，希望自己，伴侣，或者子女变得更健康，上进，懂事等。
    
    </summary>
    
      <category term="Psychology" scheme="http://www.thinkingincrowd.me/categories/Psychology/"/>
    
    
      <category term="Relationship" scheme="http://www.thinkingincrowd.me/tags/Relationship/"/>
    
  </entry>
  
  <entry>
    <title>别轻易相信他人，或自己给出的理由</title>
    <link href="http://www.thinkingincrowd.me/2018/10/20/do-not-easily-trust-other-or-your-own-reason/"/>
    <id>http://www.thinkingincrowd.me/2018/10/20/do-not-easily-trust-other-or-your-own-reason/</id>
    <published>2018-10-20T07:30:26.000Z</published>
    <updated>2019-01-06T14:42:07.600Z</updated>
    
    <content type="html"><![CDATA[<p>儿子从三年级开始，就参加了学校的田径队。到了四年级以后，因为学校政策改变，说一般都是三年级，五年级的同学，所以四年级就只剩下他一个被留了下来。  </p>
<p>一开始我们都很为他刚到自豪，毕竟是唯一一个被承认和留下的队员。他每天也照样早晚训练，偶尔回来说一下今天训练了什么项目，哪里的肌肉疼。  </p>
<p>突然有一天晚上，他和我们说：“我不想去田径队训练了。你帮我和老师说一下吧。”  </p>
<p>我们感到很惊讶，问他到底为什么？他说：“太累了。” 我们下意识地想到，国庆回来后他一直感冒流鼻涕，偶尔还有咳嗽，确实可能状态不好。所以，也认可地说：“是啊，最近你身体不好，可能确实会感觉比较累。” “现在你也慢慢康复了，后面可能就好点了。你如果现在就放弃了你喜欢的跑步活动，我觉得有点可惜啊。不如你再坚持一个月看看，怎么样？” 他突然情绪上来说：“我都说了，以后都不去了。” 这下，我们感觉到，辛苦可能并不是真正的原因。  </p>
<p>她妈妈接着问：“其实是不是你只是想下课后去玩，所以不想跑步了？” “不是！” “是不是补请假的那天，老师批评了你，所以你不想去了？” “不是！” 这个时候，感觉他已经情绪上来了，估计怎么问都没有结果了，也接近睡觉时间，我们就说：“你如果真不想去，明天也必须准时到学校，自己和老师讲清楚。” 睡觉前老婆和我说，昨晚他又去同学家玩到 6 点才回家，被狠批了一顿。  </p>
<p>第二天，已经接近平时出门训练的时间，他才起床。“不如你今天和老师好好说明一下，说最近感觉太辛苦，可能要退出，看看老师怎么说，或者怎么调整？” “我都说以后都不参加咯，这是我的选择！” “爸爸妈妈感觉都不太清楚你退出的原因，不如你今天先别说，我们周末商量清楚了，如果你还是要退出，周一再和老师说好吗？” “我今天就说！” 不知道是起床气，还是一直延续了昨晚的情绪，真的没辙了。  </p>
<p>所以，我也只好收拾东西送他去学校。在电动自行车上，我特意骑得很慢，平静地和他又重复了一遍：“爸爸妈妈一直都没有逼迫你做什么事情。我知道你是很喜欢跑步的，你之前都还兴奋地讨论比谁快，比大长腿慢多少，今天又快了两秒，还和我比赛。我觉得你就这么放弃自己喜欢的东西，太可惜了。” “我以后还是可以和你比赛啊。” “我觉得我和妈妈还是不清楚你真正退出的原因。你可以告诉我吗？是不是觉得以前的朋友都不在田径队，下午训练后没时间玩啊？” “是啊”  </p>
<p>路程很短，很快到学校了，但是还是没法想到对策如何劝他。只好由他去了。回到家，我和老婆说：“可能他真的是觉得没时间和朋友玩，田径队又没有其它认识的伙伴。所以不想去了。”  </p>
<p>上班后，老婆发来消息，说儿子落下一本书没带，让她送去。去到后，她问他和老师说了没，他说找了一圈没找到。可是，当时老师就在操场一个角落带人训练。就让他马上去说清楚了，结果说了两句就回来了。“老师，我不想训练了” “可以” 这就是对话过程。  </p>
<p>后来可能中午回家后，老婆又平和地和他讨论这个问题，认可了他的辛苦，和缺少一起训练的小伙伴。也告诉他等五年级后可以和朋友们再参加田径队。结果他还是说不去。老婆不知道怎么地，说了一句：“可能到时又会换训练的老师。”  然后儿子就说：“那就可以再参加。”  </p>
<p>？？？ 难道真正的原因是他不喜欢这个老师？  </p>
<p>到现在，我们还是没有搞清楚儿子要退出田径队的最根本的原因是什么，是否还有其它更深层次的原因。但是，老师的原因，目前来看确实是程度最重，压死骆驼的最后一根稻草了。  </p>
<p>一个人的积极性，是多么容易被他人打击和影响，尤其是有直接关系的权威人士（家长，老师，领导等）。虽然我还是鼓励儿子不要因为他人而放弃了自己的兴趣，但是，我自己上学时，何尝不是因为讨厌一个语文老师而不认真学习语文。  </p>
<p>我们做的每一个决定，背后都有一个，或者多个理由。口上对他人说的是一个，内心对自己说的是另一个。有时候，我们是故意不让其他人知道真相；有时候，可能连我们自己都被自己骗了。如果不认真反思，久而久之，我们可能都不记得当初的决定，或是放弃是为了什么。很可能就把骗别人的理由，当成真正的理由。自我的认知，很可能就这么失去了。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;儿子从三年级开始，就参加了学校的田径队。到了四年级以后，因为学校政策改变，说一般都是三年级，五年级的同学，所以四年级就只剩下他一个被留了下来。  &lt;/p&gt;
&lt;p&gt;一开始我们都很为他刚到自豪，毕竟是唯一一个被承认和留下的队员。他每天也照样早晚训练，偶尔回来说一下今天训练了什么
    
    </summary>
    
      <category term="Think" scheme="http://www.thinkingincrowd.me/categories/Think/"/>
    
    
      <category term="Reason" scheme="http://www.thinkingincrowd.me/tags/Reason/"/>
    
  </entry>
  
  <entry>
    <title>那些让你更爱 Elixir 的理由</title>
    <link href="http://www.thinkingincrowd.me/2018/09/20/what-make-you-love-elixir-more/"/>
    <id>http://www.thinkingincrowd.me/2018/09/20/what-make-you-love-elixir-more/</id>
    <published>2018-09-20T00:10:45.000Z</published>
    <updated>2018-09-19T23:43:56.263Z</updated>
    
    <content type="html"><![CDATA[<p>如果前面的 <a href="http://www.thinkingincrowd.me/2018/08/21/first-taste-on-elixir/">初尝 Elixir，真的挺好喝的</a> 和 <a href="http://www.thinkingincrowd.me/2018/09/19/programming-language-born-for-distributed-environment/">深入到骨子里的分布式和微服务化编程语言</a> 都还没能让你爱上 Elixir，那我就再补充两个它可以赋予你改造语言能力的特性吧。  </p>
<h2 id="Meta-Programming"><a href="#Meta-Programming" class="headerlink" title="Meta Programming"></a>Meta Programming</h2><p>Elixir 的元编程能力，拥有和 Lisp 一样的代码即数据的特点。它的方法名，参数和方法体等，能用 List 的数据格式包装起来，传给宏（Macro），再做分析或者扩展。且看 <a href="https://pragprog.com/book/elixir16/programming-elixir-1-6" target="_blank" rel="external">Programming Elixir ≥ 1.6</a> 书中很简单的展示代码。  </p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">My</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">macro</span></span>(param) <span class="keyword">do</span></div><div class="line">    IO.inspect param</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span>  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Test</span></span> <span class="keyword">do</span></div><div class="line">  require My</div><div class="line"></div><div class="line">  My.macro <span class="keyword">do</span></div><div class="line">    <span class="number">1</span> + <span class="number">2</span></div><div class="line">  else</div><div class="line">    <span class="number">3</span> + <span class="number">4</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span>  </div><div class="line">  </div><div class="line"><span class="comment"># =&gt; [</span></div><div class="line">      <span class="symbol">do:</span> &#123;<span class="symbol">:+</span>, [<span class="symbol">line:</span> <span class="number">7</span>], [<span class="number">1</span>, <span class="number">2</span>]&#125;,</div><div class="line">      <span class="symbol">else:</span> &#123;<span class="symbol">:+</span>, [<span class="symbol">line:</span> <span class="number">9</span>], [<span class="number">3</span>, <span class="number">4</span>]&#125;</div><div class="line">     ]</div></pre></td></tr></table></figure>
<p><code>IO.inspect</code> (类似于 <code>System.out</code> 或者 <code>console.log</code>) 打印出来的就是宏接收到的以 List 格式包装的代码。  </p>
<p>所以，通过宏（Macro），我们可以动态生成代码，实现 AOP 在方法前后包装自己的逻辑等。比如下面的代码，<code>times_3</code> 和 <code>times_4</code> 就是动态生成的方法。  </p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Times</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">times_n</span></span>(n) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">unquote</span></span>(<span class="symbol">:<span class="string">"times_<span class="subst">#&#123;n&#125;</span>"</span></span>)(v) <span class="keyword">do</span></div><div class="line">        unquote(n) * v</div><div class="line">      <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span>  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Test</span></span> <span class="keyword">do</span></div><div class="line">  require Times</div><div class="line"></div><div class="line">  Times.times_n(<span class="number">3</span>)</div><div class="line">  Times.times_n(<span class="number">4</span>)</div><div class="line"><span class="keyword">end</span>  </div><div class="line">  </div><div class="line">IO.puts Test.times_3(<span class="number">4</span>)   <span class="comment">#=&gt; 12</span></div><div class="line">IO.puts Test.times_4(<span class="number">5</span>)   <span class="comment">#=&gt; 20</span></div></pre></td></tr></table></figure>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>“多态”，对于学过面向对象的开发人员来说，应该是一个很熟悉的概念了。单一的接口，不同的类型或实现。  </p>
<p>在 JAVA 里，如果你想实现“多态”，你必须修改那些类的源代码，让它们都继承某个公共类，或者实现某个统一的接口。假如，你想为第三方的一些“多态”类添加一些行为，但你没办法修改它的源代码，这就比较尴尬了。然后各种幺蛾子的方法都会弄出来。  </p>
<p>但是，Elixir Protocol 的实现方式，可以让你不必修改对方的源代码的情况下，实现扩展。借 <a href="https://pragprog.com/book/elixir16/programming-elixir-1-6" target="_blank" rel="external">Programming Elixir ≥ 1.6</a> 书中的例子来说明一下。  </p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Collection</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@fallback_to_any</span> <span class="keyword">true</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_collection?</span></span>(value)</div><div class="line"><span class="keyword">end</span>  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Collection</span></span>, <span class="symbol">for:</span> [List, Tuple, BitString, Map] <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_collection?</span></span>(<span class="number">_</span>), <span class="symbol">do:</span> <span class="keyword">true</span></div><div class="line"><span class="keyword">end</span>  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Collection</span></span>, <span class="symbol">for:</span> Any <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_collection?</span></span>(<span class="number">_</span>), <span class="symbol">do:</span> <span class="keyword">false</span></div><div class="line"><span class="keyword">end</span>  </div><div class="line">  </div><div class="line">Enum.each [<span class="number">1</span>, <span class="number">1.0</span>, [<span class="number">1</span>, <span class="number">2</span>], &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, %&#123;&#125;, <span class="string">"cat"</span>], <span class="keyword">fn</span> value -&gt;</div><div class="line">  IO.puts <span class="string">"<span class="subst">#&#123;inspect value&#125;</span>: <span class="subst">#&#123;Collection.is_collection?(value)&#125;</span>"</span></div><div class="line"><span class="keyword">end</span></div><div class="line">  </div><div class="line"><span class="comment"># 打印出来的结果就是：  </span></div><div class="line">  </div><div class="line"><span class="number">1</span>: <span class="keyword">false</span></div><div class="line"><span class="number">1.0</span>: <span class="keyword">false</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>]: <span class="keyword">true</span></div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;: <span class="keyword">true</span></div><div class="line">%&#123;&#125;: <span class="keyword">true</span></div><div class="line"><span class="string">"cat"</span>: <span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>上面就为系统内置的数据类型，定义了一个很简单的 “多态” 函数，检测哪些是属于集合类。嗯，就是这么简洁。  </p>
<p>Elixir 除了功能强大，学习它还可以给自己一种非常不同的思维方式。如果说 Elixir 有什么不好，那就是周边的人少了点吧，Slack Channel 才 2W 多人，遇到问题找答案可就不是那么容易的事情了。不过，我觉得还是值得的。  </p>
<p>最后附上 Joe Armstrong 老爷子，Erlang 作者对 Elixir 的第一印象文章 <a href="https://joearms.github.io/published/2013-05-31-a-week-with-elixir.html" target="_blank" rel="external">A week with Elixir</a>。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果前面的 &lt;a href=&quot;http://www.thinkingincrowd.me/2018/08/21/first-taste-on-elixir/&quot;&gt;初尝 Elixir，真的挺好喝的&lt;/a&gt; 和 &lt;a href=&quot;http://www.thinkingincrow
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Elixir" scheme="http://www.thinkingincrowd.me/tags/Elixir/"/>
    
  </entry>
  
  <entry>
    <title>深入到骨子里的分布式和微服务化编程语言</title>
    <link href="http://www.thinkingincrowd.me/2018/09/19/programming-language-born-for-distributed-environment/"/>
    <id>http://www.thinkingincrowd.me/2018/09/19/programming-language-born-for-distributed-environment/</id>
    <published>2018-09-19T00:30:38.000Z</published>
    <updated>2018-09-26T13:52:30.665Z</updated>
    
    <content type="html"><![CDATA[<p>分布式和微服务化，已经大行其道很久了。现在很多项目动不动就说做成微服务，不管不顾自己的项目性质，和相应的工具链支持。关于微服务，我还是很喜欢 Martin Fowler 大叔在 <a href="https://martinfowler.com/bliki/MicroservicePremium.html" target="_blank" rel="external">MicroservicePremium</a> 里说的：  </p>
<blockquote>
<p>my primary guideline would be <strong>don’t even consider microservices unless you have a system that’s too complex to manage as a monolith.</strong>  </p>
</blockquote>
<p>微服务最基本，最核心的点是什么？服务切分。一个能很好切分服务的架构师，即便是让他用 Monolith 的方式搭建系统，模块的划分也应该是很清晰的。  </p>
<p>那么，假如你手上拥有的已经是 JAVA 界当前开发效率最高，开发约定最统一的 Springboot 实现的一个 Monolith 系统，如果要把它分隔为几个独立的服务，你觉得会有多简单？除了复制一些配置，切分新建几个 Application 这些体力活外，模块间的通信方式则可能需要有很大的改变。原来的 Java 代码调用，现在可能要改成 http 接口，grpc 等，即便不需要对外提供服务。  </p>
<p>在 Elixir 里，如果规划的好，模块的切分一开始就通过 GenServer 等使用消息传递的方式来调用，后期的微服务化简直就是拆一下文件目录就差不多了，并不需要再大费周章改接口，统一数据传输格式等。Elixir 的 Node 节点注册，Process 注册、管理和通信，为打造微服务化和分布式的系统提供非常好的支持。  </p>
<p>更难得的是，Elixir 坐拥了 Erlang 传承的宝藏，一篮子的工具库，让代码，服务间的调用和监控变得非常容易。这一套工具可以说是历经几十年产品线上磨练的官方套件，不必像其它语言那样到处搜罗组装开源工具，或者自研。  </p>
<p>比如，我现在只是实现一个计数器，你每次可以向它获取下一个可用的数字，它会一直自增下去。如果你不想每次自增的间隔是 1，那可以设置其它间隔。  </p>
<p>这么简单的一个应用，可以算是一个微服务了吧？我们还可以怎么把它切分为更细的服务吗？我们还可以把它分成三部分：  </p>
<ol>
<li>实现自增，和间隔设置逻辑的业务服务  </li>
<li>保存数据状态的服务  </li>
<li>监控这两个服务的 Supervisor 服务，假如业务逻辑出错，负责重启  </li>
</ol>
<p>下面这幅图应该基本可以说明整个应用是如何运作的了。  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/Elixir_Sequence_Server_Demo.png" alt="Elixir Sequence Server Demo">  </p>
<p>你可以看到，如果我把自增的间隔故意设置为非数字，导致服务意外退出，背后的 Supervisor 服务会将它悄悄的重启，并按照编写好的逻辑，把 Server 的内部状态数据保存到数据服务，以便重启时读取。等我重新设置一个正确的数字自增间隔后，就可以接着获取新的号码了。  </p>
<p>在 Elixir 的交互控制台 iex 下，敲入 <code>:observer.start()</code> 这个命令，就可以监控整个系统的运行状态，包括有哪些 Application，哪些 Process，Application 内存使用情况，内部数据状态（State）等。  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/Elixir_Sequence_Server_Hierarchy.png" alt="Elixir Sequence Server Hierchary">  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/Elixir_Sequence_Server_Info.png" alt="Elixir Sequence Server Info">  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/Elixir_Sequence_Server_State.png" alt="Elixir Sequence Server State">  </p>
<p>总的来说，Elixir 的消息调用机制，Application 的组织方式，Process Supervision 和节点的架构方式，丰富的系统工具，真的是从骨子里散发出微服务的光芒。数据的 immutability 更是让分布式数据处理更安心，不用担心一些不必要的多线程问题。  </p>
<p>Elixir 的作者 José Valim，在 <a href="http://blog.plataformatec.com.br/2015/06/elixir-in-times-of-microservices/" target="_blank" rel="external">Elixir in times of microservices</a> 这篇文章中介绍更清楚详细，推荐一读。  </p>
<p>相关文章：  </p>
<p><a href="http://www.thinkingincrowd.me/2018/08/21/first-taste-on-elixir/">初尝 Elixir，真的挺好喝的</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式和微服务化，已经大行其道很久了。现在很多项目动不动就说做成微服务，不管不顾自己的项目性质，和相应的工具链支持。关于微服务，我还是很喜欢 Martin Fowler 大叔在 &lt;a href=&quot;https://martinfowler.com/bliki/Microser
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Distributed" scheme="http://www.thinkingincrowd.me/tags/Distributed/"/>
    
      <category term="Elixir" scheme="http://www.thinkingincrowd.me/tags/Elixir/"/>
    
      <category term="MicroServices" scheme="http://www.thinkingincrowd.me/tags/MicroServices/"/>
    
  </entry>
  
  <entry>
    <title>真正的责任体现于为何种失败和错误考虑</title>
    <link href="http://www.thinkingincrowd.me/2018/08/29/design-for-failure-reflects-the-greatest-responsibility/"/>
    <id>http://www.thinkingincrowd.me/2018/08/29/design-for-failure-reflects-the-greatest-responsibility/</id>
    <published>2018-08-29T10:15:13.000Z</published>
    <updated>2018-09-26T13:52:31.411Z</updated>
    
    <content type="html"><![CDATA[<p>最近滴滴的事情闹的很大，也被骂地很凶。我当然也认为滴滴有错，没有尽到应有的责任。但是，我并不认为关停是好的做法。试想一下，如果是普通的出租车或者黑车出事，有可能那么快抓到人吗？科技和数据是先进的表现，滴滴拥有比出租车把事情做好的更优越的条件，只是它们的关注点没有放在安全上面，甚至是忽略了。  </p>
<p>本文并不主要讨论滴滴，而是有感于 TK教主（网络信息安全领域大牛）发的微博：  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/tombkeeper_weibo_safety_system.png" alt="tombkeeper weibo"></p>
<h2 id="Design-for-Failure"><a href="#Design-for-Failure" class="headerlink" title="Design for Failure"></a>Design for Failure</h2><p>我不记得自己最早什么时候看到关于这个观点的文章或者书了，或许是 Martin Fowler 大叔的这篇关于<a href="https://martinfowler.com/articles/microservices.html#DesignForFailure" target="_blank" rel="external">微服务</a>的文章吧。“为了失败而设计”？其实它要表达的意思是<strong>“为应对失败而设计（因为失败无可避免）”</strong>。失败指的是出错，并没有按照预期的方式运转。  </p>
<p>如果页面打开时 JavaScript 或 CSS 文件加载不成功，或者服务端接口数据出错怎么办？后台定时运行的一个 Job，会不会因出错导致中止运行？假设一条数据处理出错，那会不会影响其它数据的处理？如果因为 Job 有 Bug 要停止运行，数据堆积了一个小时，一天，甚至一个星期，修复后如何重新运行这个 Job，要花多长时间？如果一个服务器 down 了，能马上启用一个新的吗？如果不行，按平时的流量，另一个服务器能撑多久，要不要降级，哪些次要的服务可以暂时关停？  </p>
<p>无论是前端，还是后端开发，或者是运维等，都可能面对各种失败。<strong>不同的失败场景，有不同的处理方法。而不同的失败场景，也体现了设计者本身的关注点，和职责所在。</strong>  </p>
<h2 id="Responsibility-for-Failure"><a href="#Responsibility-for-Failure" class="headerlink" title="Responsibility for Failure"></a>Responsibility for Failure</h2><p>一个后端开发人员，主要考虑的是系统功能的失败，如何在发生了故障的情况下依然尽可能正常地提供服务，保障数据的正确性等。他们负责的对象以系统为主。  </p>
<p>一个前端开发人员，主要考虑的是减少失败场景对用户产生的挫败感，尽可能让用户达成使用产品功能的目标。他们负责的对象以人为主，但主要也是针对用户体验、产品功能。  </p>
<p>一个安全人员，主要考虑的是系统防护安全的失败，如何在不同的防护层被黑后减少对系统的影响，和保密数据的安全等。他们负责的对象以系统为主。  </p>
<p>虽然上面举例的一些人还是以系统为主要负责对象，但是，其实系统背后也承担着使用系统的人的利益。  </p>
<p>保障数据的安全，其实就是保护用户的资产。花功夫在这上面的企业，才是真正重视用户的资产，为他们负最大的责任。所以说，一个人，一个企业为了哪种失败而做出精心的设计和准备，其实体现了他到底是为谁而负责。  </p>
<p>并不是每个人都能像 TK教主 那样有那么强的安全意识。但是，如果出现多次这样的事情都不能做出有效防护手段，就说不过去了。而滴滴，在接二连三的意外出现后，都没能有效地做出调整，可见用户安全这个场景对他们来说真的没有认真考虑。  </p>
<p>一个参与创业者，最应该考虑的失败应该是项目失败或者公司面临倒闭。那 Ta 是提前怎么考虑过的？是另寻工作，变卖抵押自己和家庭的资产，还是甚至结束自己的生命？Ta 到底最终为谁负责？  </p>
<p>对于一个普通人来说，最大的失败可能就是意外死亡，有没有为这个准备好也体现了他是否为家人负责。  </p>
<p>每一个人都注定面临各种各样的失败，想想你都为哪些做好了准备。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近滴滴的事情闹的很大，也被骂地很凶。我当然也认为滴滴有错，没有尽到应有的责任。但是，我并不认为关停是好的做法。试想一下，如果是普通的出租车或者黑车出事，有可能那么快抓到人吗？科技和数据是先进的表现，滴滴拥有比出租车把事情做好的更优越的条件，只是它们的关注点没有放在安全上面
    
    </summary>
    
      <category term="Think" scheme="http://www.thinkingincrowd.me/categories/Think/"/>
    
    
      <category term="Responsibility" scheme="http://www.thinkingincrowd.me/tags/Responsibility/"/>
    
      <category term="Failure" scheme="http://www.thinkingincrowd.me/tags/Failure/"/>
    
  </entry>
  
  <entry>
    <title>初尝 Elixir，真的挺好喝的。</title>
    <link href="http://www.thinkingincrowd.me/2018/08/21/first-taste-on-elixir/"/>
    <id>http://www.thinkingincrowd.me/2018/08/21/first-taste-on-elixir/</id>
    <published>2018-08-21T12:52:46.000Z</published>
    <updated>2018-08-22T15:05:18.727Z</updated>
    
    <content type="html"><![CDATA[<p>其实，之前从北京回来的时候，我就在考虑学习 Go 还是 Elixir。  </p>
<p>因为现在很多的区块链项目和 docker 等虚拟技术都是用 Go 语言实现，同时公司用 Hyperledger Fabric 时也要写点 chaincode，所以一开始的时候看了一下 Go。不过，我好像怎么都没法被它吸引起来。可能因为自己是一个并非从写 C 语言成长起来的程序员？  </p>
<p>自从看了「程序人生」公众号里面的两篇关于 Elixir 的文章，终于忍不住买了一本「<a href="https://pragprog.com/book/elixir16/programming-elixir-1-6" target="_blank" rel="external">Programming Elixir ≥ 1.6</a>」来看。一看真的是舍不得放下。除了 Elixir 这门函数式语言本身的特性我很喜欢外，作者的理念和写作风格也是很和我心意。  </p>
<h2 id="编程就是数据转换"><a href="#编程就是数据转换" class="headerlink" title="编程就是数据转换"></a>编程就是数据转换</h2><blockquote>
<p>Programming Should Be About Transforming Data</p>
</blockquote>
<p>看到书里面的这句话，就已经感觉 Elixir 一定挺对我胃口的，或许自己真的是函数式的忠粉吧。我一直觉得啥都封装成一个对象，真的挺累的。而且，如果你深刻地理解了这句话，数据分析的 ETL（Extract - Transform - Load）是那么地自然，Map/Reduce 分而治之也是很好理解。  </p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>开篇我就被作者颠覆了骨子里的一个最基本的认知：赋值（Assignment）。  </p>
<p>凡是学过一点点编程的人应该都知道，<code>=</code> 是大多数编程语言的赋值操作符。即便不是这样，也会有类似的一个符号，在它的左边是一个变量，右边是赋值给它的常量，其它变量或一些运算，比如：<code>a = 1</code> 或者 <code>a = max(number_list)</code>。  </p>
<p>但是，在 Elixir 里面，<code>=</code> 是匹配操作符。  </p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt;a = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt;<span class="number">1</span> = a</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt;<span class="number">2</span> = a</div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> <span class="number">1</span></div></pre></td></tr></table></figure>
<p>第一句代码可能让我们认为它是和其它编程语言一样的赋值语句，但是看到后面两句估计就有点懵逼了。这是什么鬼？变量怎么可以在右边？  </p>
<p>其实，<code>=</code> 在 Elixir 里被成为匹配操作符。它的作用是让 Elixir 去尝试寻找满足 <code>=</code> 号两边相等的情况。而把 <code>a</code> 赋值为 <code>1</code> 就满足这样的条件了。在匹配的时候，Elixir 只可以修改 <code>=</code> 号左边的变量值，而会把右边的变量用它的值来替换。所以，如果没有最开始的 <code>a = 1</code> 那个语句，第二句 <code>1 = a</code> 是会出错的。  </p>
<p>要改变习惯，转成这种思维方式并不容易。而且，Elixir 的模式匹配还支持比较复杂的形式，比如：  </p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ken = %&#123; <span class="symbol">name:</span> <span class="string">"Ken"</span>, <span class="symbol">likes:</span> <span class="string">"programming"</span>, <span class="symbol">has:</span> <span class="string">"a wife and a son"</span> &#125;</div><div class="line"><span class="keyword">case</span> ken <span class="keyword">do</span></div><div class="line">  %&#123; <span class="symbol">likes:</span> something &#125; = person = man -&gt;</div><div class="line">    IO.puts <span class="string">"<span class="subst">#&#123;person.name&#125;</span> likes <span class="subst">#&#123;something&#125;</span> and has <span class="subst">#&#123;man.has&#125;</span>"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>一开始看到书上有一个类似的例子（<code>= man</code> 那部分是为了在这里说明才加上的）时，我一下子没转过弯，都傻了。啥玩意啊？<code>person</code> 这个变量哪里冒出来的？后来才想到那里的匹配，应该相当于是这样的情况：  </p>
<p><code>%{ likes: something } = person = man = ken</code></p>
<h3 id="函数的匹配"><a href="#函数的匹配" class="headerlink" title="函数的匹配"></a>函数的匹配</h3><p>作为一门函数式编程语言，怎么能不提到递归。Elixir 的模式匹配和递归配合起来使用，实在是太爽了。完全不必用到 <code>if else</code> 之流来判断边界值，代码表达得相当优雅。  </p>
<p>我觉得，递归可以说非常好地体现了 First Principle 原则。只有看透数据处理的本质，才能理解递归。我们来看看书中的一句霸气的话吧：  </p>
<blockquote>
<p>L. Peter Deutsch once penned, “To iterate is human, to recurse divine.”</p>
</blockquote>
<p>什么意思？“使用遍历的是普通人，能用递归的是神”。  </p>
<p>递归思想在 Elixir 里面是如此地深入骨髓，连列表也可以表达为：<code>[ head | tail ]</code>。也就是说，一个列表，就是最开头的一个元素，拼上后面的列表。  </p>
<p>充分了解了这些后，我的感觉和 Dave 在书里表达的一样：  </p>
<blockquote>
<p>that’s certainly the way I felt when I first started coding Elixir. The joy of pattern-matching lists in sets of recursive functions drove my designs. After a while, I realized that perhaps I was taking this too far.</p>
</blockquote>
<p>好吧，还是先擦一擦口水，来看一个简单的递归和函数的模式匹配吧：  </p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Recursion</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(<span class="number">0</span>), <span class="symbol">do:</span> <span class="number">0</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n), <span class="symbol">do:</span> n + sum(n - <span class="number">1</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Recursion.sum(<span class="number">5</span>)  <span class="comment"># =&gt; 15</span></div></pre></td></tr></table></figure>
<p>这个函数计算了某个给定数字之下的所有正整数之和。以上的例子就是计算 <code>5+4+3+2+1+0</code>。  </p>
<p>能理解上面这个方法的，可以尝试猜一猜下面的程序是干嘛的，我就不解释了。  </p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Chop</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">match</span></span>(actual, min, max) <span class="keyword">when</span> actual === min <span class="keyword">or</span> actual === max <span class="keyword">do</span></div><div class="line">    IO.puts actual</div><div class="line">  <span class="keyword">end</span></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">match</span></span>(actual, min, max) <span class="keyword">when</span> actual &gt; min <span class="keyword">and</span> actual &lt;= (div(max + min, <span class="number">2</span>)) <span class="keyword">do</span></div><div class="line">    IO.puts <span class="string">"Is it <span class="subst">#&#123;(div(max + min, <span class="number">2</span>))&#125;</span>?"</span></div><div class="line">    match(actual, min + <span class="number">1</span>, div(max + min, <span class="number">2</span>))</div><div class="line">  <span class="keyword">end</span></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">match</span></span>(actual, min, max) <span class="keyword">when</span> actual &gt; div(max + min, <span class="number">2</span>) <span class="keyword">and</span> actual &lt; max <span class="keyword">do</span></div><div class="line">    IO.puts <span class="string">"Is it <span class="subst">#&#123;div(max + min, <span class="number">2</span>)&#125;</span>?"</span></div><div class="line">    match(actual, div(max + min, <span class="number">2</span>) + <span class="number">1</span>, max - <span class="number">1</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">guess</span></span>(actual, <span class="number">_</span>) <span class="keyword">when</span> <span class="keyword">not</span> is_integer(actual) <span class="keyword">do</span></div><div class="line">    IO.puts <span class="string">"Guess value <span class="subst">#&#123;actual&#125;</span> is not integer"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">guess</span></span>(actual, min..max) <span class="keyword">when</span> actual &lt; min <span class="keyword">or</span> actual &gt; max <span class="keyword">do</span></div><div class="line">    IO.puts <span class="string">"Guess value <span class="subst">#&#123;actual&#125;</span> is out of the range <span class="subst">#&#123;min&#125;</span>..<span class="subst">#&#123;max&#125;</span>"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">guess</span></span>(actual, min..max) <span class="keyword">do</span></div><div class="line">    match(actual, min, max)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">Chop.guess(<span class="number">512</span>, <span class="number">1</span>..<span class="number">1000</span>)</div></pre></td></tr></table></figure>
<h2 id="完善的工具，和开发规范"><a href="#完善的工具，和开发规范" class="headerlink" title="完善的工具，和开发规范"></a>完善的工具，和开发规范</h2><p>作为一个新兴的小众语言，真没想到它还有非常丰富的辅助工具，包括调试，测试，代码依赖分析，发布管理，服务器监控等。如作者所说，这都是因为 Elixir 继承了 Erlang 的财富，和开发社区对工具的重视。  </p>
<p>当前我了解的还很少，初步印象深刻的是它的测试功能。它连文档中的代码块都能测试（据说是借鉴 Python 的）。  </p>
<p>很多程序员都抱怨文档没人写，写了也跟不上代码的变化。Elixir 的这个功能可以比较好地减少这种情况。虽然 JAVA 和 JavaScript 好像也有类似的包，但是都不太完善，也不是官方支持。而且 JAVA 这种以类为基础，动不动还要初始化对象什么的，写起来太累赘了。Elixir 的函数式风格就能很简洁地写出测试的验证代码。  </p>
<p>它的格式大概是这样：  </p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">提供的 `actual` 是在区间 `min..max` 中的某一个数字，本方法一步步猜测 `actual` 的值是什么。</div><div class="line"></div><div class="line">## Example</div><div class="line"></div><div class="line">  iex&gt; Chop.guess(512, 1..1000)</div><div class="line">  "Is it <span class="number">500</span>?<span class="string">"</span></div><div class="line">  "Is it <span class="number">750</span>?<span class="string">"</span></div><div class="line">  "Is it <span class="number">626</span>?<span class="string">"</span></div><div class="line">  "Is it <span class="number">564</span>?<span class="string">"</span></div><div class="line">  "Is it <span class="number">534</span>?<span class="string">"</span></div><div class="line">  "Is it <span class="number">519</span>?<span class="string">"</span></div><div class="line">  "Is it <span class="number">512</span>?<span class="string">"</span></div><div class="line">  "<span class="number">512</span><span class="string">"</span></div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">guess</span></span>(actual, min..max) <span class="keyword">do</span></div><div class="line">  match(actual, min, max)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>另外，Elixir 和 Ruby 差不多，有一定的开发规范可以遵循。这有助于统一风格，提高开发效率。  </p>
<p>Elixir 更强大的编写并发代码的能力我还没有接触到，但估计更加精彩。所以，我决定今后的 Pet Project 都会从 Node.js 改成 Elixir 来写，并期待能有拿它来写 Serious Project 的机会。  </p>
<p>有兴趣一起学习的朋友，可以看看我看书后做的<a href="https://github.com/kenspirit/programming-elixir-exercises" target="_blank" rel="external">练习题解答</a>。  </p>
<p>相关文章：  </p>
<p><a href="http://www.thinkingincrowd.me/2016/08/28/What-is-programming-should-I-learn/">编程是什么？我要学吗？</a><br><a href="http://www.thinkingincrowd.me/2016/09/15/Capability-for-Learning-Programming-Abstraction.md/">学习编程需要具备的基本能力 - 抽象</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实，之前从北京回来的时候，我就在考虑学习 Go 还是 Elixir。  &lt;/p&gt;
&lt;p&gt;因为现在很多的区块链项目和 docker 等虚拟技术都是用 Go 语言实现，同时公司用 Hyperledger Fabric 时也要写点 chaincode，所以一开始的时候看了一下 
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Functional Programming" scheme="http://www.thinkingincrowd.me/tags/Functional-Programming/"/>
    
      <category term="Elixir" scheme="http://www.thinkingincrowd.me/tags/Elixir/"/>
    
  </entry>
  
  <entry>
    <title>你最害怕的，是这个吗？</title>
    <link href="http://www.thinkingincrowd.me/2018/07/25/is-this-the-scariest-thing-to-you/"/>
    <id>http://www.thinkingincrowd.me/2018/07/25/is-this-the-scariest-thing-to-you/</id>
    <published>2018-07-24T22:38:40.000Z</published>
    <updated>2018-07-24T22:39:48.218Z</updated>
    
    <content type="html"><![CDATA[<p><strong>人类是下意识地惧怕不确定性，并热衷于给于或索求解释的</strong>。我在「象与骑象人」看到一个有意思的例子可以充分说明这点，我这里简单介绍一下，顺便推荐一下这本书。  </p>
<p>心理学家迈克尔·加扎尼加（Michael Gazzaniga）对实施了裂脑手术的病人做了一些后遗症研究。什么是裂脑手术呢？人脑有两个大脑半球，左半球接收人体右半边的信号，右半球接收左边的。接受了裂脑手术的病人，是连接左右两个半脑的神经纤维称做胼胝体（corpus callosum）被切断的手术。而切断，就意味着左右脑的沟通大幅减少。加扎尼加要病人注视着屏幕上的某个点，然后让某个词或者物体的图片快速出现在这个点的右边或左边，闪现的速度快到病人连移动视线的时间都来不及。  </p>
<p>有一次，加扎尼加对右半球闪现一张鸡爪图片，对左半球则闪示一张一个屋子和一辆车子埋在雪堆中的图片。接着，加扎尼加给出一堆图片让病人选择匹配的图片。病人的右手指着一张鸡的图片（和左半球看到的鸡爪有关），左手却指向一张铲子的图片（和右半球看到的雪景有关）。但是加扎尼加让他解释为什么的时候，他不是回答“我不知道”，而是毫不犹豫地说：“鸡脚配鸡，所以你需要一把铲子来清理鸡舍。”。病人的左大脑半球立即编出这个精彩的故事。  </p>
<h2 id="如何处理未知和不确定性"><a href="#如何处理未知和不确定性" class="headerlink" title="如何处理未知和不确定性"></a>如何处理未知和不确定性</h2><p>幼小的时候，怕爸爸妈妈离开后不回来了。  </p>
<p>长大了，担忧失业。或者想转行，创业，又怕不稳定。  </p>
<p>体检查出来有肿块，担忧是恶性的，坐立不安。直到被确诊为良性，才长舒一口气。如果是恶性的，甚至还无法治疗，就一直忧心，不知道还有多少活命的日子。  </p>
<p>即便只是身上的一个伤口，虽然我们没法控制它恢复的快慢，但是如果它处在能让自己看得到的位置，你也会心安一些。因为看得见的不确定性，比看不见要小。  </p>
<p>对于不确定的将来，自己无法控制掌握，我们往往就会焦虑，纠结，怎么办呢？  </p>
<ul>
<li><p>寄托于另一个更高权威的“客体”  </p>
<p>这些客体既可以是非实体的，比如上帝，不同司职的神，塔罗牌，求签等；也可以是具备实体的，如神父，上司，专家等。他们期待这些客体可以替自己做决定，把选择权交给对方，自己顺从地接受。  </p>
</li>
<li><p>逃避，遗忘  </p>
<p>反正我也不知道自己能做什么，而且每个人都有可能失业，就这样走一步算一步呗。有些人面对未知的身体症状也是逃避，视而不见。上次我住院时的一位同室病友，病犯差不多半年，导致身体变的极差，还不愿意到医院看，想着自己休养一下就好。最后到医院一查，严重贫血，输了 6 袋血，医生说再晚点来，如果不小心摔倒晕过去，可能就救不过来了。  </p>
</li>
<li><p>接受，放下  </p>
<p>这种行为看似和逃避的情况差不多，其实它们相距甚远。接纳了不确定性的人，承认了它的存在并无法消除。但他们能放下焦虑，减少思考坏的一面，尽量做一些正向的事情。很多能比预期存活的时间长的绝症患者，都是如此。  </p>
</li>
</ul>
<p>最近的疫苗事件，让一个巨大的不确定性突然笼罩在全国人民，尤其是父母的身上。面对这样的不确定性，我们是持有 “都已经生在中国，我还有什么选择呢？” 的想法；还是努力发声，监督政府，努力赚钱，让自己有能力移民或者选择进口疫苗呢？  </p>
<h2 id="过去也有不确定性"><a href="#过去也有不确定性" class="headerlink" title="过去也有不确定性"></a>过去也有不确定性</h2><p>对未来的不确定性，比较常见和容易理解。其实还有一种隐晦一点的，是对过去的不确定性，对自己或他人曾做过的事情的原因不确定。  </p>
<p>比如，有人老是迟到，老是频繁被炒鱿鱼换工作，或者老是和异性相处不好。他们会一直埋怨自己：“我怎么老是这样，怎么都改不了？”。  </p>
<p>觉得自己能力范围内应该可以控制的事情，却又一直没法按理想的方向发展而产生，焦虑油然而生。  </p>
<p>显然，要消除或者减轻这种不确定性，我们无非要给自己找一个解释和理由，要么是自己的，要么从权威那获得，比如心理咨询师。  </p>
<p>有些人可能认为不一定需要找一个理由啊。但是，“我就是这样的人” 的回答，本身就是一个理由。最近很火的“原生家庭”的概念，也是把自己的缺点和问题，溯源到过去和家人关系上的一个理由。  </p>
<p>不同心理学派有各种不同的对人行为的解读方式。年幼时和抚养人之间的关系，是心理学精神分析学派非常看重的一种解释。而系统论，更强调关系中双方对某一相处模式的共同作用，相互影响。  </p>
<p><strong>在不确定性面前，得到一个解释，人类才不会思来想去</strong>。但是，对于一种特定的行为，我们可以“拿出”各种不同的解释。但是，解释质量高低不同，有些甚至是可笑和荒谬的，尤其是自己找的理由。所以，<strong>解释的质量，和后续行动，才是最关键的</strong>。偏向于消极被动的解释，会让我们倾向于逃避和否定。如果你归罪于自己的性格，归罪于“原生家庭”，归罪于关系中另一方，没有看到自己改变的可能和力量，就会一直困于当前的行为模式中。而积极主动的解释和行动，是在接纳中改变。  </p>
<p><strong>莎士比亚说过：“事情没有好坏，是人的思想在作祟。”</strong>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;人类是下意识地惧怕不确定性，并热衷于给于或索求解释的&lt;/strong&gt;。我在「象与骑象人」看到一个有意思的例子可以充分说明这点，我这里简单介绍一下，顺便推荐一下这本书。  &lt;/p&gt;
&lt;p&gt;心理学家迈克尔·加扎尼加（Michael Gazzaniga）对实施了
    
    </summary>
    
      <category term="Psychology" scheme="http://www.thinkingincrowd.me/categories/Psychology/"/>
    
    
      <category term="Unknown" scheme="http://www.thinkingincrowd.me/tags/Unknown/"/>
    
  </entry>
  
  <entry>
    <title>被偶像说是傻逼，你会怎么想？</title>
    <link href="http://www.thinkingincrowd.me/2018/07/09/how-do-you-feel-if-your-idol-call-you-idiot/"/>
    <id>http://www.thinkingincrowd.me/2018/07/09/how-do-you-feel-if-your-idol-call-you-idiot/</id>
    <published>2018-07-09T13:47:45.000Z</published>
    <updated>2018-07-09T13:50:35.336Z</updated>
    
    <content type="html"><![CDATA[<p>前些天，一份关于李笑来的录音流传出来了，里面充满了脏话，傻逼，忽悠等词汇。很多人说他人设坍塌，也有人说他说了大实话，路转粉。那到底是怎么回事呢？我当然也需要自己听听录音，然后自己做判断。</p>
<h2 id="利益声明"><a href="#利益声明" class="headerlink" title="利益声明"></a>利益声明</h2><p>如果你一直关注我公众号，并看过这些文章，应该知道，我当初只身一人去北京，就是跟笑来做事。所以，再做一下利益声明吧。</p>
<ol>
<li>为新生大学交了两年费用  </li>
<li>前一块听听核心后端开发  </li>
<li>Candy.one 前期核心后端开发（不是录音中被骂的团队，我是接手改写系统的，不是用的 PHP，即便它是最好的语言）  </li>
<li>自购 700 PRS，无 MIX  </li>
<li>因参与了一些笑来的项目，被送了约 500w Candy  </li>
</ol>
<h2 id="傻逼共识？"><a href="#傻逼共识？" class="headerlink" title="傻逼共识？"></a>傻逼共识？</h2><p>为什么说被笑来说是 “傻逼”呢？录音中，笑来的原话是这样的：</p>
<blockquote>
<p>到最后，区块链里面最大的价值是共识价值。共识啥意思？它不值钱，但是信的人那么多，最后就值钱了。<br>…<br>莱特币为什么涨？到最后的解释很简单，就是傻逼太多了。对吧？共识价值嘛，傻逼的共识也是共识啊。<br>…<br>所以，傻逼多，有共识，也会产生价值。  </p>
</blockquote>
<p>这里的逻辑关系是：莱特币是傻逼项目（笑来前面录音里说的） -&gt; 支持它的人就是傻逼 -&gt; 所以是傻逼共识  </p>
<p>也就是说，如果说项目是傻逼项目的话，支持的人就是傻逼，达成的共识就是傻逼共识。他在录音里的意思，也是说很多区块链项目都是傻逼共识。  </p>
<p>但是，我觉得，是否傻逼，不能单看项目。为什么呢？  </p>
<h3 id="判断项目太难"><a href="#判断项目太难" class="headerlink" title="判断项目太难"></a>判断项目太难</h3><p>为什么笑来说莱特币是傻逼项目？因为，莱特币最开始的源代码，就是拿比特币的代码来做了一些参数的修改而已。然后创始人就说比特币是金，它是银。（<a href="https://www.coindesk.com/information/comparing-litecoin-bitcoin/）所以，这不符合笑来的判断原则嘛，他很自然就认定莱特币是傻逼项目了。" target="_blank" rel="external">https://www.coindesk.com/information/comparing-litecoin-bitcoin/）所以，这不符合笑来的判断原则嘛，他很自然就认定莱特币是傻逼项目了。</a>  </p>
<p>但是，区块链项目好坏并不是那么容易判断的。抄代码的项目，最后也不一定发展的不好。为什么？  </p>
<p>比如，BCH 也是从比特币分叉出去的。BCH 的想法，是比特币有缺陷，然后通过某种方式改代码，让它变得更好，构建自己的网络。那你说 BCH 和比特币，以后谁能发展地更好？比特币的行家都未必能说清楚。而且，做技术的人都知道，面对一个问题前，解决方案可能有好几个，每个可能都有好有坏，各有取舍。如果后面 BCH 发展的更好呢？  </p>
<p>举个更通俗的例子，你可能知道为什么金子比银贵：金子产量少，冶炼成本高，化学特性稳定等。但是，普通人可能不知道啊。他们知道金银值钱的时候，就是“知道”金比银贵，他们也不知道为什么。反正现实就是金比银贵，但都有价值，都有升值空间。只是有些人买不起金子，就买银呗。  </p>
<p>对于普通人来说，怎么可能区分比特币和 BCH 哪个更好呢？他怎么知道莱特币只是比特币的修改版而已呢？未来谁发展更好也不好说。所以，仅凭这样就说他们是傻逼，也有点太为难别人一些了。只是确实它有价值的人多起来，它也就还是有价值了。  </p>
<h3 id="是否对自己行为负责"><a href="#是否对自己行为负责" class="headerlink" title="是否对自己行为负责"></a>是否对自己行为负责</h3><p>既然现在判断区块链项目很难，我觉得判断你是否是一个傻逼，取决于你参与的理由是什么了。  </p>
<p>现在很多所谓的“区块链”项目，参与者 99% 都是炒币的人，为发财而来，而不是相信项目的价值，以及能发展多久。多数人的共识，自然是它能升值而已。  </p>
<p>如果说，参与者真的相信项目的价值（先不管是否真的有价值，因为没几个人能说清楚区块链适用的场景在哪里），而且做项目的人是真的有职业操守，有理想，买币人是真相信（即便是盲信），他们算不算傻逼？我觉得不算，因为他们知道自己在干什么，可以算是天使投资人吧。如果参与者本来就是投机的，只是想赚钱，也真的赚了钱，那可能没人认为他们是傻逼。  </p>
<p>是否是傻逼（准确来说，韭菜），区别在于你是否知道自己在玩火，还是信仰和天使投资，是否对自己的行为负责，是否只是盲目相信了所谓的“大V”，高价接棒了空气项目的人。  </p>
<h2 id="偶像的话就该相信吗？"><a href="#偶像的话就该相信吗？" class="headerlink" title="偶像的话就该相信吗？"></a>偶像的话就该相信吗？</h2><h3 id="偶像也是人"><a href="#偶像也是人" class="headerlink" title="偶像也是人"></a>偶像也是人</h3><p>和专家一样，他们的话都不一定正确，而且还不知道是不是“砖家”。他们也都有自己的喜好，也会有判断错误的时候。  </p>
<p>很多人骂李笑来，说他站台很多空气项目，搞了不少 ONE 系项目，单机币，一开始说多好多好，后面跌成屎。  </p>
<p>不可否认，笑来确实站台投资不少项目（有些说是被站台），拉不少项目群，说他的项目好，包括 Mixin，Big.one，Candy.one，Press.one 等。虽然有时我也有点反感，但这是他自己的或者投资的项目，怎么不能说好呢？他有没有劝别人去买呢？我没花时间去翻他的信息，搜黑历史。但是我问他有没有什么好的区块链项目介绍时，他都说这个只能你自己去了解。印象中，他也只是说 XX 好，拿着呗，Y 年后看看。所以，黄婆卖瓜肯定有，是不是故意割韭菜，我就不从主观上猜测了。  </p>
<h3 id="有自己的判断"><a href="#有自己的判断" class="headerlink" title="有自己的判断"></a>有自己的判断</h3><p>他说好的，我们就要冲进去买了吗？买了后跌了，就要他负责吗？这么做的人，就真的是韭菜行为了。无论是谁说的，都应该有自己的思考和判断。推荐看看笑来之前介绍的「Beyond Feelings - A Guide to Critical Thinking」。  </p>
<p>从那份流传的录音中，你可以知道他确实觉得，区块链当今需要 IP，流量，所以要搞社群，聚人气。有流量，就有共识。  </p>
<p>但是，真的只能从人气出发，推动产品的发展吗？我还是觉得产品应该有区块链的价值，有场景才行。当然，我不是说他不看重场景，只是我会问：“这个产品，为什么需要区块链？节点在哪些人手里？他们的共识，激励机制是什么？” 所以，即便是他的项目，如果我不清楚的话，我就不买，或者少买。  </p>
<p>我自己是 Candy.one 的早期开发者。离开北京前，我们在做游戏，新闻聚合，任务奖励，交易所等。一开始，我认为是 Candy.one 如果是一个 ETF 的话，最大的价值就是管理好里面的其它代币资产，引进优秀项目。那它做游戏，新闻，任务奖励这有什么用呢？这些引来的流量，真的有价值吗？它和普通中心化系统的积分制度有什么不同，真的需要区块链吗？就因为能上交易所，能换钱吗？它做交易所干什么呢？不是和 Big.one 重叠吗？  </p>
<p>很多人说 Mixin.one 是下一代公网，有支持全币种钱包的通信工具，还免转账费。但从官网上给的 Github 链接里，没有看到节点的代码，也不知道有哪些节点存在。所以，它真的是区块链项目吗？全币种支持虽然需要集成各种币，但是要实现这功能，不一定需要是一个公链啊。免转账费的话，普通中心化数据库也可以啊。像那些交易所，也不是每笔交易就上链的。只要不提币或充值，内部那些操作都不需要走链上交易。有事情发生，还可以回滚交易呢。所以，免转账费，免交易费也当然不是大问题。  </p>
<p>再比如，现在各大交易所都说去中心化，价值在什么地方呢？交易，就需要人气，真正的去中心化就是小范围交易，又不是赌场的开大小，交易量上不来谁喜欢去呢？我想到的好处，去中心化就是容易避开监管，但里面所有的交易，还是集中的。  </p>
<p>即便是偶像的东西，看不懂我也不会盲目相信和跟进。真正有价值的，发展后再投资呗。我买的币都是自己感觉靠谱，买了就当天使投资，即便钱丢了也不可惜。所以，我是没赚到大钱，没财富自由，但也能赚到点傻钱。那我是不是笑来说的“傻逼”呢？也许算是吧，因为有点盲目相信“价值投资”。只是我不觉得自己是韭菜，因为我知道自己做什么，也对自己负责。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些天，一份关于李笑来的录音流传出来了，里面充满了脏话，傻逼，忽悠等词汇。很多人说他人设坍塌，也有人说他说了大实话，路转粉。那到底是怎么回事呢？我当然也需要自己听听录音，然后自己做判断。&lt;/p&gt;
&lt;h2 id=&quot;利益声明&quot;&gt;&lt;a href=&quot;#利益声明&quot; class=&quot;he
    
    </summary>
    
      <category term="Think" scheme="http://www.thinkingincrowd.me/categories/Think/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>什么叫做尽责</title>
    <link href="http://www.thinkingincrowd.me/2018/06/23/How-to-fullfill-your-responsibility/"/>
    <id>http://www.thinkingincrowd.me/2018/06/23/How-to-fullfill-your-responsibility/</id>
    <published>2018-06-23T09:36:04.000Z</published>
    <updated>2018-06-23T10:11:52.335Z</updated>
    
    <content type="html"><![CDATA[<p><strong>要评价是否尽责，最重要的是要弄清楚你的职责是什么。</strong>  </p>
<p>最近自己的一些经历，我觉得能很好地对此进行说明。  </p>
<p>最近我刚做了一个小手术，住院了几天。每天，护士都回来帮忙清洁伤口和换药。  </p>
<p>你们觉得护士的职责是什么呢？是清洁伤口和换药吗？  </p>
<p>那怎样算是尽责了呢？伤口清洁干净，换药完毕就可以了对吗？  </p>
<p>但是对于我这个病人来说，显然更喜欢那些手势温柔，不让你感觉那么痛苦的护士。这些护士，愿意蹲下身子，放慢速度，集中精神，同时言语上安抚病人。相反，那些粗手粗脚，心不在焉，甚至给你的伤口带来二次伤害，然后还假装说你伤口比较大容易受伤的护士，你肯定不觉得她们尽责了吧？  </p>
<p>出院后，我每天还要回医院清洁伤口和换药。但是，换了三四天，才有一个护士和我说：“伤口和附近的皮肤有点过敏啊，这怎么好的了啊？这两天就不要用这个药膏了。你去买一个叫氧化锌的药膏来擦一下。先把过敏弄好，保持伤口干爽。” 果不其然，擦了几天护士建议的药膏，我就感觉好了很多。  </p>
<p>到这里，你们觉得，最后这个护士，她尽责了吗？她的好心建议，是不是责任外的事情？如果不是，在我过敏发生后，其它那些帮我换药的护士，尽责了吗？  </p>
<p>职责，应该是为目标服务的。护士的目标和职责，应该是让病人更快，更好的恢复，而不仅仅是过程中的清洗伤口和换药。<strong>如果你看到的职责，只是通往目标中的过程，那就无法为实现目标，做得比别人更好</strong>。  </p>
<p>只看到过程，就很难看到其它可以让你更好地实现目标的选择。只看到过程，就会导致领导叫你做什么，就只做什么，而不会去想到底什么才是应该要做的事情。  </p>
<p>经典的「X-Y Problem」，也是类似的道理。耗子哥很久前写过一篇文章（<a href="https://coolshell.cn/articles/10804.html），值得一看。" target="_blank" rel="external">https://coolshell.cn/articles/10804.html），值得一看。</a>  </p>
<p>所以，要尽责，只需要两点：  </p>
<ol>
<li>目标清晰  </li>
<li>用心做好  </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;要评价是否尽责，最重要的是要弄清楚你的职责是什么。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;最近自己的一些经历，我觉得能很好地对此进行说明。  &lt;/p&gt;
&lt;p&gt;最近我刚做了一个小手术，住院了几天。每天，护士都回来帮忙清洁伤口和换药。  &lt;/p&gt;
&lt;p&gt;你们觉得护
    
    </summary>
    
      <category term="Think" scheme="http://www.thinkingincrowd.me/categories/Think/"/>
    
    
      <category term="Responsibility" scheme="http://www.thinkingincrowd.me/tags/Responsibility/"/>
    
  </entry>
  
  <entry>
    <title>父亲的另一个角色</title>
    <link href="http://www.thinkingincrowd.me/2018/06/17/another-role-of-father/"/>
    <id>http://www.thinkingincrowd.me/2018/06/17/another-role-of-father/</id>
    <published>2018-06-17T10:52:56.000Z</published>
    <updated>2018-06-17T10:55:10.305Z</updated>
    
    <content type="html"><![CDATA[<p>又到了一年一度的父亲节，朋友圈和公众号也有不少怀念和感恩以前难以理解的父爱的文章。  </p>
<p>父亲节所赞美和体现的，都只强调了父亲的其中一个角色。  </p>
<p>现在主流的教育观念，都基本肯定了父亲在教育，和亲子关系中的重要性。那父亲除了需要更多地参与子女教育，陪伴外，还有什么需要注意的呢？  </p>
<p>但是，我们还应该看到父亲的前一个角色，丈夫。  </p>
<p>夫妻的亲密关系，对孩子的成长有非常密切的关系。夫妻关系，是孩子学习如何建立亲密关系的榜样，也会对孩子成年后的择偶观念有重大的影响。和睦的家庭，是孩子成长的基石。终日争吵，甚至把这一过错推卸到孩子身上的家庭，对孩子更是有不可估量的影响。  </p>
<p>因为没有一个“丈夫节”，所以，我希望趁着“父亲节”，拿自己痛的感悟给自己，和各位“丈夫”们，提一个醒。  </p>
<h2 id="妻子-vs-母亲"><a href="#妻子-vs-母亲" class="headerlink" title="妻子 vs 母亲"></a>妻子 vs 母亲</h2><p>估计每个人都听过网上流传广泛的一个经典难题：“我和你妈同时掉到水里，你救谁？” 撇去那些抖机灵的答案和建议，每个男人应该都不愿意去面对这个问题，也很烦他的爱人拿这个问题来质问他。  </p>
<p>婆媳问题，恐怕是世界级的难题。每个丈夫，估计每天都祈祷，他的妻子和母亲意见一致，不要有任何冲突。一旦发现冲突，很多都是打打混水，敷衍过去。做的好一些的，会在母亲那边说说妻子的好话，在妻子那边说说母亲的好话，希望相互体谅一下。玩火的那些，就反过来，在母亲那边说妻子的不是，在妻子那边说母亲的不是。  </p>
<p>最最差的做法是什么呢？从不站在妻子那边，即便母亲做的不对，也不敢反对，老是让妻子要体谅迁就母亲。  </p>
<p>其实，<strong>一个男人成家后，首要的家庭，应该是他和妻子的新家庭。他要捍卫的，应该是这个家庭的稳定，其次才是儿子身份的旧家庭。大部分情况下，在你妻子和母亲之间，你都应该站在妻子那边。</strong>  </p>
<p>我知道这个观点实在很难去面对和接受，尤其是“孝子”，因为他们都不愿意去伤害一个曾经在他们身上倾注了那么多爱的人。曾经的我也是这样。<strong>站在妻子那边，重要的不是说你就需要背叛，或者不尊重你的父母。</strong>在大是大非面前，你还是应该有正确的价值观。但是，多数日常生活面对的，婆媳之间的矛盾或者冲突问题，你都需要站在妻子那边。  </p>
<p>我相信，你追寻到的，愿意陪伴一生的她，应该是一个讲道理的好人。真正提出不讲道理的情况，应该是很极端的。在你认为妻子越来越不讲道理的时候，很可能是你之前一直忽略她的需求，站在她的对立面太多了。越是稀缺的东西，越是渴望。其实，很多情况下，作为丈夫，你在一些小的方面都能体现出支持和维护妻子的感觉和做出行动，她会反过来在更多方面支持和理解你。  </p>
<h2 id="妻子-vs-孩子"><a href="#妻子-vs-孩子" class="headerlink" title="妻子 vs 孩子"></a>妻子 vs 孩子</h2><p>孩子的抚育和教育理念，也是夫妻之间争吵最多的问题之一。  </p>
<p>曾经为了儿子是否要早点上床睡觉，早上起来是否能玩手机，是通过严厉的语气批评还是温和地讲道理等问题，我和老婆都争得不可开交，都“倔强地”坚持自己的做法。即便我们很少在儿子面前公开争吵，他有时都能感觉到我们之间紧张的关系，甚至还问：“你们吵架了吗？”  </p>
<p>在不同观念的指导下，夫妻间对待孩子的行为肯定会有不同做法。孩子也理所当然会产生偏向性，偏向于那个 Ta 认为“对 Ta 更好”的一方。<strong>当孩子更听某一方的话时，Ta 和某一方关系会更好，同时也意味着更疏远另一方。更疏远的一方，也就更难管教孩子。这样很容易形成恶性循环，也会加重夫妻间的矛盾，加剧分裂。</strong>  </p>
<p>我觉得，世界上并没有太多绝对好坏的教育方式。当你和妻子发生分歧时，别太争对错，尽量从分歧中看到各自背后的需求，寻找共同点，统一战线。即便真的无法统一，一三五听爸爸的，二四六听妈妈的，也不见得有问题。最重要的是让孩子知道，你们双方都是互相支持和尊重，这样的决定是双方都认可的。<strong>最不应该的，是在孩子面前，贬低诋毁另一半的观点或者做法。</strong>  </p>
<p>还有另一种情形是，孩子对你的妻子做出一些不尊重的行为，或者有语言的冒犯，你也应该让孩子知道，妻子对你来说更重要，你必须保护她。如果发现实际犯错的是妻子，导致孩子才产生恶言或者粗鲁的行为，应当夫妻私下讨论清楚，然后两人一同先向孩子道歉。  </p>
<p>原则上来说，丈夫和妻子，是一个整体，战线应该是一致的。然后，范围再扩大到包括孩子的整个家庭，也就是孩子犯错时，父母也应该先保护 Ta，对外承担责任，然后父母再对孩子进行相应的教育，而不是站到 Ta 的对立面。  </p>
<blockquote>
<p>和睦的家庭空气是世界上的一种花朵，没有东西比它更温柔，没有东西比它更适宜于把一家人的天性培养得坚强正直。<br> — 德莱赛  </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又到了一年一度的父亲节，朋友圈和公众号也有不少怀念和感恩以前难以理解的父爱的文章。  &lt;/p&gt;
&lt;p&gt;父亲节所赞美和体现的，都只强调了父亲的其中一个角色。  &lt;/p&gt;
&lt;p&gt;现在主流的教育观念，都基本肯定了父亲在教育，和亲子关系中的重要性。那父亲除了需要更多地参与子女教育，
    
    </summary>
    
      <category term="Psychology" scheme="http://www.thinkingincrowd.me/categories/Psychology/"/>
    
    
      <category term="Relationship" scheme="http://www.thinkingincrowd.me/tags/Relationship/"/>
    
      <category term="Father" scheme="http://www.thinkingincrowd.me/tags/Father/"/>
    
  </entry>
  
  <entry>
    <title>没想到，抱怨已不再是抱怨</title>
    <link href="http://www.thinkingincrowd.me/2018/05/25/complaint-is-not-complaint-any-more/"/>
    <id>http://www.thinkingincrowd.me/2018/05/25/complaint-is-not-complaint-any-more/</id>
    <published>2018-05-24T23:01:58.000Z</published>
    <updated>2018-05-24T23:57:13.559Z</updated>
    
    <content type="html"><![CDATA[<p>早在去年刚听到一些关于亲密关系的心理学课程，可能也是开始意识到自己处理亲密关系是多么糟糕的时候，我写过一篇总结 <a href="http://www.thinkingincrowd.me/2017/03/31/intimate-communication-is-not-as-easy-as-you-think">亲密关系的沟通没你想的那么简单</a>。  </p>
<p>里面，我提到<strong>“面对沟通要约，最重要的是男方要表现出一种面对，而不是背对的态度”</strong>这个观点。到现在为止，我才觉得自己可以说能比较自然地，敏锐地发现对方的沟通要约，和用面对的态度来处理。我终于可以和自己说，这么长时间地接触和学习心理学，并没有白学了。  </p>
<p>举两个例子吧：  </p>
<p>某一天晚上，应该说是深夜了吧，我迷迷糊糊中察觉到了老婆的异常声响，像是抽泣。我转身看了看，发现她用被子在擦眼。我握着她的手问：“又做噩梦了？” “嗯。”</p>
<p>如果是你，你是否会再安慰一下：“做梦而已，都不是真的，别瞎想。”，然后继续睡过去？或者说你觉得我这么做太矫情了，直接装作没看见？  </p>
<p>我继续问她，还是以前那个梦吗？她说：“不是，那个梦很久没出现了。是另一个。” “那这次是梦见了什么？” 然后，我慢慢听她把梦的情景告诉我，我也告诉她之前听的武志红的关于解梦的技巧，相互探讨她的梦可能说明了什么。就这样，我们在凌晨聊了可能有半小时。  </p>
<blockquote>
<p><strong>When you are in pain.  My world stops and I listen.</strong>  </p>
</blockquote>
<p>这是 Gottman 博士在「the Seven Principles for Making Marriage Work」里说的一句话。当时看到这句话时，对我来说是多么地震撼，我很庆幸现在自己也能不自觉地做到了。  </p>
<p>上周四晚上回到家，老婆就向我投诉：“爸妈每天去学校接儿子放学，又拿牛奶饼干糖果给他吃。都说那么多次了，饼干糖果热气，儿子很容易又喉咙不舒服。现在弄得晚上还吃不下饭。每天早上，还特意等他田径训练完，拿衣服给他换，说怕着凉。我们都问过他了，他自己都觉得不需要。他们俩回家那段时间，不还是什么事都没有？照顾那么周到，你让儿子怎么才能独立起来？换下的校服还要拿回去了，我哪里还有衣服给儿子用？”  </p>
<p>一连串的抱怨，就这样成了我晚饭的加餐。  </p>
<p>一直以来，我的观点是，要么别找老人家帮忙带小朋友，要么就只能将就一下。他们都那么大年纪，自己有自己一套生活模式和价值观，并不容易改变。想想要你去改一件你自己的坏习惯，你能说改就改吗？所以，一些不是什么违背大原则的事，我都是随它的。不是说什么都不干，我还是会回头唠叨我的父母，只是不会态度特别强硬。  </p>
<p>但是，这个“大原则”的定义，每个人的标准或者关注点都不同的。这也导致，以前的我，和老婆之间都会在这些方面有不少争吵。争吵在于非要分个对错，听谁的，而不能一起解决背后的问题。  </p>
<p>现在，我<strong>看到了情绪背后合理的要求</strong>：“不希望儿子吃太多零食，甚至吃不下饭；希望儿子能早点独立，为自己的决定负责；校服拿走了，不够用。” 她的原则没错，只是和老妈在当前情况关注的角度不一样。况且，她是儿子的母亲，管教的“职责和权力”应该倾斜多一些。  </p>
<p>我边吃饭，边肯定了她，并说：“我吃了饭过去拿校服回来，顺便和他们说一下。”  </p>
<p>没想到，第二天，老婆又投诉到：“今天中午放学都拿东西给他吃，还要不要吃饭了？” 天啊，我也真是无语了。周六家庭聚餐时再一次当着老婆的面说了爸妈一次，温和而坚定的，并告诉他们我们的想法，和给他们一些提议看如何配合。  </p>
<p>我依然会和老婆有不同意见，但是，很多情况下，我都<strong>不会让情绪升起，也不再关注于争对错，让对方听我的。很多事情，没有明显的对错之分，只是稍有优劣，或者角度不同</strong>。以前，我理亏的时候，不出声，默默改进；我占理的时候，忍着，因为怕吵架。但从她的角度，怎么看，都是没有回应，这是很不好的做法。现在，我都会<strong>平和地说出自己的想法，感受，和背后的一些顾虑，理解她的同时，让她能理解我</strong>。以前我通常是回头和父母唠叨两句，但是她不知道，现在我<strong>更清楚地用行动告诉她我对她的支持</strong>。  </p>
<p>尊重，让对方的想法影响自己，合作面对问题是真正的相处之道。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在去年刚听到一些关于亲密关系的心理学课程，可能也是开始意识到自己处理亲密关系是多么糟糕的时候，我写过一篇总结 &lt;a href=&quot;http://www.thinkingincrowd.me/2017/03/31/intimate-communication-is-not-a
    
    </summary>
    
      <category term="Psychology" scheme="http://www.thinkingincrowd.me/categories/Psychology/"/>
    
    
      <category term="Relationship" scheme="http://www.thinkingincrowd.me/tags/Relationship/"/>
    
      <category term="Communication" scheme="http://www.thinkingincrowd.me/tags/Communication/"/>
    
      <category term="Complaint" scheme="http://www.thinkingincrowd.me/tags/Complaint/"/>
    
  </entry>
  
  <entry>
    <title>「PRESS.one 的投资逻辑」合理吗？</title>
    <link href="http://www.thinkingincrowd.me/2018/05/23/is-press-one-investment-logic-reasonable/"/>
    <id>http://www.thinkingincrowd.me/2018/05/23/is-press-one-investment-logic-reasonable/</id>
    <published>2018-05-23T13:16:25.000Z</published>
    <updated>2019-02-17T07:01:52.738Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，岳琦和 PRESS.one 拓荒者社群在我的老东家「一块听听」做了一个直播：<a href="https://live.tinfinite.com/live-detail.html?liveshowId=5aff18c75eca460001caf10f" target="_blank" rel="external">「PRESS.one的投资逻辑」</a>。整个直播听下来，比起很多盲目“信仰投资”的人来说，他对 PRESS.one 的分析和投资看法，还是相当全面的。</p>
<p>总的来说，岳琦的看法是，投资一个区块链项目，靠单纯的信仰是不够的，也是不负责任的。因为很多项目的 ICO，白皮书来来去去都是那些套路：先说现在的行业，或者当前某区块链项目有什么问题，然后说我们可以解决这个问题（有些项目甚至都没说怎么解决），或者一些项目就对标当前某某巨头，说做区块链的xx（且不说这个领域有没有必要用区块链），最后就说要发币募集资金，巴拉巴拉一大堆。所以，在鱼龙混杂的情况下，如何分析项目，合理投资很重要，尤其是现在已经不是随便发币就鸡犬升天的时候了。  </p>
<p>不过，就他里面说到的一些观点，我想补充一些看法。  </p>
<h2 id="利益声明"><a href="#利益声明" class="headerlink" title="利益声明"></a>利益声明</h2><ol>
<li>从珠海到北京跟李笑来老师做教育领域产品一年半。由于家庭原因，最后还是回珠海。  </li>
<li>前 一块听听 核心后端开发人员  </li>
<li>前 Candy.one 核心后端开发人员  </li>
<li>自己花钱购买了 500 个 PRS  </li>
</ol>
<h2 id="价值的分析比较"><a href="#价值的分析比较" class="headerlink" title="价值的分析比较"></a>价值的分析比较</h2><p>在一个成熟的投资市场，比如股票市场，通过比较同一个行业不同公司的市值，营收等数据，就可以相对合理地知道投资哪个公司比较好。但是，当前投资区块链项目，很难按这种方式运作。它更像是对创业公司的天使轮投资。所以，我们更多的是分析它要解决的问题，发展前景，团队成员的能力和人品。  </p>
<p>对当前很多区块链项目来说，影响它币价的，有两个重大的因素：  </p>
<ol>
<li><p>先发优势  </p>
<p> 一个区块链项目，只要它宣称是第一个为了解决某某问题的，支持人数会相对更多。  </p>
</li>
<li><p>参与人数  </p>
<p> 由于现在很多参与区块链投资的人，都是为信仰充值，所以，参与人数多的项目，信徒心理明显，价格更有支撑。现在很多新项目都用各种营销拉新手段来送币，希望用户基数更大。  </p>
</li>
</ol>
<p>关于 PRESS.one，岳琦觉得它在 .one 生态里面，作为笑来系的一部分，未来的用户量，和引流增长方面会有很大优势，价值也会更高。用户流量和产品价值的关系，并不能说不合理，因为它们在当前互联网行业也是存在的。在生态内互相引流，也是常事。但是，当前区块链的拉新，估计比互联网拉新的用户质量更差，很多用户都仅仅是羊毛党而已，根本没有什么价值。  </p>
<p>最重要的是，且不说当前 .one 生态有多少用户量，日后 PRESS.one 能收获多少导流，倒过来的用户是你的产品目标用户吗？比如，Big.one 的用户，无论是投资还是投机也好，主要是为了交易，它能为 PRESS.one 带来多少有价值的用户呢？不同的产品，用户属性和所属的圈层是不同的。正如热衷购买和刷知识付费类商品的用户，刷快手的应该较少。  </p>
<p>那对 PRESS.one 来说，真正有价值的用户是哪些，有多少呢？我们再来分析它的产品定位。  </p>
<h2 id="产品定位"><a href="#产品定位" class="headerlink" title="产品定位"></a>产品定位</h2><p>岳琦在直播里把数字内容行业的一些区块链项目做了比较。总的来说，当前很多的项目都是做内容生产和奖励，或者社群，比如知名的 Steemit，币乎等。我和岳琦观点比较一致，在之前的<a href="http://www.thinkingincrowd.me/2018/05/08/is-blockchain-valuable/">「区块链到底有没有价值」</a>里我也写到：  </p>
<blockquote>
<p>虚拟货品（币，数字商品，游戏道具等）我觉得是可以通过区块链的物权和钱的同时转移（比如通过智能合约）来实现的，也是合理的。</p>
</blockquote>
<p>PRESS.one 的官网显示，它将来真正要做的是：  </p>
<blockquote>
<p>基于区块链的<strong>数字内容交易及分发网络</strong>  </p>
<p>利用交易历史的链上存证、可灵活自定义的轻合约、分布式网络、数字货币等技术推动交易模式的变革，<strong>重建数字内容的生产/授权/分销/消费方式</strong>。  </p>
<p>发掘并借助新型的信任关系/组织形式/驱动模式，重塑内容生产者/消费者的角色及关系。  </p>
<p>去中心化的开放协议，允许任何人基于我们的数据和基础架构来创建应用及内容。透明，高效，平等。  </p>
</blockquote>
<p>PRESS.one 有意识的区别定位，要做更底层的协议，专注交易分发和改变生态关系。理论上来说，无论是哪个区块链的内容生产平台，甚至是当前中心化的平台（如公众号）上的写作者，都可以通过 PRESS.one 把数字内容签名确权。  </p>
<p>岳琦认为这是 PRESS.one 有优势和价值的地方。但是，是不是和其它产品不同，做更底层的东西就肯定更有价值呢？如果 PRESS.one 自己不生产内容，只是<strong>重建交易/分发/授权/分销/消费内容的方式</strong>，它的角色和竞争力在什么地方，产品护城河又在哪里呢？  </p>
<h3 id="数字内容电商渠道"><a href="#数字内容电商渠道" class="headerlink" title="数字内容电商渠道"></a>数字内容电商渠道</h3><p>假如我们把数字内容对标为商品，内容生产方就是商家。那 PRESS.one 是不是就类似是淘宝的电商平台呢？根据 PRESS.one 官网最新的更新日志，他们正在和 MIXIN 集成经济系统。把 MIXIN 比作支付宝也是李笑来老师在他朋友圈说过的事情，所以我觉得把 PRESS.one 比作淘宝也是合理的。  </p>
<p>回看电商的发展，从杂乱的淘宝大集市，然后细分为各种垂直领域，或主打不同的消费体验（如更好的服务，更高质量的商品，更便宜且社交化的消费场景等）。PRESS.one 所在的领域可以说很有想象力，但是也同样面临被抄袭，切分细领域的困境。  </p>
<p>实体经济的商家，依赖电商是依赖它们的 IT 实力，流量分发，系统服务，物流管控等能力。但是，来到数字内容世界，情况又如何呢？  </p>
<p>对于个人内容生产者来说，它们无法直接在 PRESS.one 上生产内容，并且它们需要流量。所以，多数人来说，肯定需要借助内容生产平台，而并不是 PRESS.one 的直接用户。  </p>
<p>PRESS.one 的直接用户，应该是内容平台。但是，大的内容平台本身 IT 能力不一定比 PRESS.one 差，自己又掌握内容本身和流量。如果说是 PRESS.one 设计的经济模型和运作模式好，它们做内容的很可能就会直接抄袭。而 MIXIN 作为公链，也不是说只有 PRESS.one 能接入。再说，互联网的孤岛效应越发严重，大内容平台有更大动力自己做。岳琦认为 PRESS.one 有可能打破信息孤岛的局面。我觉得这个就有点太乐观了，不太实际。PRESS.one 的定位，如果不是内容生产平台，而只是交易分发网络的话，我觉得是没法改变这个格局的。  </p>
<p>内容平台兴盛与否，和有多少内容生产者在上面有关系。我在一块听听做的那段时间里，深刻体会到多数主讲人都没什么忠诚度可言。哪个平台和渠道有流量，有推广，有补贴，他们就去哪家。只要哪个平台开更优惠的条件，给更好的服务，它们可能一转身就走了。小的内容生产应用/平台要和大平台竞争会很困难。  </p>
<p>所以，对于一个不生产内容，纯平台或者渠道来说，我觉得最重要的能力是运营合作和服务能力。PRESS.one 确实要想好如何和大内容平台合作，避免竞争。长期来看，我觉得 PRESS.one 自己可能也需要搭建内容平台。  </p>
<h3 id="辅助生态"><a href="#辅助生态" class="headerlink" title="辅助生态"></a>辅助生态</h3><p>MIXIN 平台，承担着 PRESS.one 的支付系统，帮助用户能方便消费和兑现 PRS 币，对 PRESS.one 的发展很重要。正如移动支付，小额支付的流行，也为知识内容付费起了推波助澜的作用。所以，岳琦也认为 MIXIN 是 PRESS.one 价值推进的重要因素。  </p>
<p>我虽然赞同，但觉得风险也很大。Token 和电子货币在国内的使用，与法币的兑换，目前并不被允许。政策的影响相当大。即便政策开放支持，当前的移动支付巨头，按他们现在的技术积累，要上区块链和支持电子货币的支付也是很容易的。当前中心化的内容生产平台，发币和区块链+ 更容易些，还是让现在的内容生产和消费者迁移去新生态容易些呢？这个问题实在不好说，机会与风险同在。头条，抖音现在也把其它巨头打的很痛。  </p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>PRESS.one 是否值得投资，只有自己经过思考才能决定。整篇文章下来，似乎我都在列出它可能会遇到的困难和问题。但是，老实说，我对这个项目还是持正面乐观的态度的。看到困难是比较容易的，要提出有效的建议，执行并解决问题才困难。欢迎大家也给我的文章提出更多的想法和建议，一起见证和协助 PRESS.one 的成长。  </p>
<p><em>本文作为第一篇自己写 PRESS.one 的文章，也是我用来放在各种平台认证接入的文章，下面就是我的认证接入凭证。有兴趣的，你也可以去 PRESS.one 了解一下。</em>  </p>
<p><a href="https://press.one/p/address/v?s=38c0f8314a5e5c519eda7c73167e3a99eee7eaf5550a86becd81ddc3517438962764b64a60f2f9dd5373244b3ebb2f6c9f6ab6b09059ce7b6f3b3a2091536b480&amp;h=8fab93570c1f39bd49c91e451e56f4c7fe6689c3fb9db062d72ee51cfbd320b1&amp;a=b294d95ad0b3d76c0fdd60dcc576a8448b0e3f06&amp;f=P1&amp;v=2" target="_blank" rel="external">https://press.one/p/address/v?s=38c0f8314a5e5c519eda7c73167e3a99eee7eaf5550a86becd81ddc3517438962764b64a60f2f9dd5373244b3ebb2f6c9f6ab6b09059ce7b6f3b3a2091536b480&amp;h=8fab93570c1f39bd49c91e451e56f4c7fe6689c3fb9db062d72ee51cfbd320b1&amp;a=b294d95ad0b3d76c0fdd60dcc576a8448b0e3f06&amp;f=P1&amp;v=2</a></p>
<p>我的 BIG.one PRS 代币地址是 0x394c74071368bd692c495c292b216e65b383480f，欢迎大户打赏。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天，岳琦和 PRESS.one 拓荒者社群在我的老东家「一块听听」做了一个直播：&lt;a href=&quot;https://live.tinfinite.com/live-detail.html?liveshowId=5aff18c75eca460001caf10f&quot; target
    
    </summary>
    
      <category term="Think" scheme="http://www.thinkingincrowd.me/categories/Think/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>习惯了别人的好是很危险的</title>
    <link href="http://www.thinkingincrowd.me/2018/05/09/addictive-to-others-goodness-is-dangerous/"/>
    <id>http://www.thinkingincrowd.me/2018/05/09/addictive-to-others-goodness-is-dangerous/</id>
    <published>2018-05-09T12:25:12.000Z</published>
    <updated>2019-02-17T07:02:45.496Z</updated>
    
    <content type="html"><![CDATA[<p>不知道大家有没有听过这么一个小故事，或者是谚语：  </p>
<p>一个乞丐，每天都会有固定的一位善心人士给予 Ta 一元钱的施舍。但是，某一天，或许是因为那位善心人士没有了散钱，或者有急事在身，匆匆路过而没有给予这个乞丐施舍。结果，那个乞丐起来破口大骂，说：“你怎么今天不给钱了？” 结果就是，这位善心人士再也不给予 Ta 更多的施舍。  </p>
<p>我在看社会心理学的书时，还发现另一个小故事。  </p>
<p>一群小朋友，喜欢在一个老人家外的空地玩耍。但是这个老人家喜欢安静，怕吵，他就出去和小朋友说：“你们的快乐和笑声真的给我带来很美好的时光。我人老了，没收入，所以只能打赏你们 1 元。不过现在我想休息一下，你们去别的地方玩好吗？” 小朋友们本来就很开心，没想到还能收到钱，说了声谢谢就离开了。往后，老人家都会打赏。但是，渐渐的减少了金额。后来某一天，老人家只给了 1 毛钱，那些小朋友生气地说：“我们给你带来那么多欢乐，你才给 1 毛钱那么少。我们以后再也不来这里玩了！” 所以，最后，老人家收获到了他想要的安静。  </p>
<p>通过这两个故事，我想说什么呢？依赖会：  </p>
<h2 id="丧失独立能力和感恩"><a href="#丧失独立能力和感恩" class="headerlink" title="丧失独立能力和感恩"></a>丧失独立能力和感恩</h2><p>独立，是成年人很重要的能力。依赖，就像是还在襁褓中的婴儿对母亲的“剥削”。婴儿子所以如此，是因为 Ta 能力不足。可是如果成年后还不能独立，成为了巨婴，问题是很严重的。没有一个人有义务一辈子对你好，即便 Ta 是你的父母，子女，或者伴侣，更别说素不相识的善心人士了。当然，有一些人无法长大，并不是他们自己的问题，反而是父母或者是伴侣，使各种手段不让他们离开。  </p>
<p>以前报纸时不时都有报道说一些学生收到捐助，出来工作后也不知道要报答一下，甚至一些感恩的心都没有。更别说拿了助学贷款不还的了。我自己也碰到这样的事情。几年前，在某些慈善机构爆出丑闻后，我觉得自己应该直接捐款给某个具体的人，而不是机构，这样可以减少中间的腐败浪费环节。刚好我在某份报纸上看到有个母亲，患有恶性疾病，还有一个小孩要照顾，我连续四五个月给他们家汇款给予捐助。后来，忙得不记得汇款了，他主动发信息过来询问，要钱。我顿时感觉到了恶心，也停止了对他的捐助。  </p>
<h2 id="迷失自己，忘却了本心"><a href="#迷失自己，忘却了本心" class="headerlink" title="迷失自己，忘却了本心"></a>迷失自己，忘却了本心</h2><p>依赖，有时并不是你一开始就故意想这么做的。生活中的美好，可能在你意料不到的时候到来，然后由于对方的善和爱，你持续收获到了关注和温暖。渐渐地，你习惯了这种美好，把它当作理所当然。就像是第二个故事的小朋友那样，本来是为了自己的欢乐而玩耍，最后因为没有钱的奖励而丧失了原来的本心。  </p>
<p>我写公众号的本心，就是提高自己的思考和写作能力。虽然我也会被自恋影响，希望能得到更多的关注，但确实没幻想过能有很多人看，能赚多少打赏。不过，你可能不会相信，有一位朋友，在我每次发了一篇文章后，都会给我打赏 10 元。这真的不是一个小数目。开头每次收到打赏，我都会及时给予回复和感谢，同时心里也是充满了内疚。因为，我知道自己的写并没有那么好。当然，我也没有为了打赏，每天不顾质量的产出。慢慢地，我没有每次回复和表达感谢，内疚的感觉并没有那么强烈了。除了因为我觉得口头的感谢太微不足道外，或许也是有一点点习惯了。  </p>
<p>我觉的我自己还是比较克制和警觉的。而且，在他需要帮忙的时候，我都尽力出手相助。不过，当他停止打赏的那一刻，我察觉到心里还是有那么一丝失落。这份失落，是习惯的断裂造成的。可是，对于这份失落，每个人的解读都是不一样的。  </p>
<p><strong>倾向于内归因的人会想，是我不够好了吗？</strong>我就在想，是我写的没以前那么好了吗，还是我的观点和他不一致？如果处理不好内归因，可能就会打击自己的信心，动摇自己的方向。比如，写作者可能就会变得迎合读者，最终丧失了自我。  </p>
<p><strong>倾向于外归因的人会觉得，别人变坏了，也就是会攻击对方</strong>。当攻击对方的时候，就可能会忘却了本心。  </p>
<p>幸亏，我的本心还算稳定，打赏的停止，也释放了我心里的重担。  </p>
<h2 id="依靠而不依赖"><a href="#依靠而不依赖" class="headerlink" title="依靠而不依赖"></a>依靠而不依赖</h2><p>对于痛苦，人类通常都怕避之不及。对甜食，爱，等美好的事物，人是很容易上瘾的。而且这种瘾来的悄无声息，不容易察觉，等到失去的时候，你才突然发现可能无法失去。  </p>
<p>在亲密关系里面，依靠是很重要的。恰当的依靠，可以增加相互之间的安全感，放下对外部世界的武装，真正做自己。我以前对这两个概念区分的并不好，所以亲密关系维系的不好。但是，依靠和依赖不一样。<strong>依靠是互相支撑，依赖是你完全不使劲，没想过给对方支持，只向对方索取</strong>。  </p>
<p>希望我们能有人依靠的同时，不要依赖他人。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道大家有没有听过这么一个小故事，或者是谚语：  &lt;/p&gt;
&lt;p&gt;一个乞丐，每天都会有固定的一位善心人士给予 Ta 一元钱的施舍。但是，某一天，或许是因为那位善心人士没有了散钱，或者有急事在身，匆匆路过而没有给予这个乞丐施舍。结果，那个乞丐起来破口大骂，说：“你怎么今天不
    
    </summary>
    
      <category term="Psychology" scheme="http://www.thinkingincrowd.me/categories/Psychology/"/>
    
    
      <category term="Relationship" scheme="http://www.thinkingincrowd.me/tags/Relationship/"/>
    
  </entry>
  
  <entry>
    <title>区块链到底有没有价值</title>
    <link href="http://www.thinkingincrowd.me/2018/05/08/is-blockchain-valuable/"/>
    <id>http://www.thinkingincrowd.me/2018/05/08/is-blockchain-valuable/</id>
    <published>2018-05-08T00:00:16.000Z</published>
    <updated>2018-05-09T12:21:39.742Z</updated>
    
    <content type="html"><![CDATA[<p>区块链炒币和 ICO 热潮最近稍微降温下来，比特币从最高近 2W 美金，跌至最低 6K 多，现在再回升到 9K 左右。作为一个“盲目”认定比特币价值，但是又不敢“All In”投资/炒币的人，我并没有赚到很多钱，但是也没有损失。因为没有怎么卖出，所以账面价值看上去，资产还是增值不少的。  </p>
<p>单单谈论区块链技术，我也是认为其有特定的价值和应用场景的。但是，最近我在问自己，当前的各种应用场景，公链，它们真的有存在的价值吗？他们解决的是什么问题？  </p>
<h2 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h2><p>听起来，这是美好的，所有的东西都能从源头追踪定位，减少假货。但是，越是经过复杂加工，处理合成各种原材料的商品，我觉得区块链溯源就越值得怀疑。  </p>
<p>你说，一头猪，假设它的资料上了区块链，标明产地，编号。那，我怎么保证宰的时候，每块从它身上切下来的猪肉，还继续带上原来的“身份”？靠屠宰厂的自动化封闭流水线？如何防止调包？即便屠宰的时候没问题，物流运送的阶段呢？真货的保证，都需要流程中各方严格管控，防止造假的可能。可是，这真的需要区块链吗？这需要去中心化吗？显然是中心化，严格的管控，统一的流程更好啊。就单纯把编号上个链，和以前的防伪码有什么不一样？  </p>
<p>实物，我觉得硬要和区块链扯上关系，是有点牵强的。相反，虚拟货品（币，数字商品，游戏道具等）我觉得是可以通过区块链的物权和钱的同时转移（比如通过智能合约）来实现的，也是合理的。  </p>
<h2 id="用户数据出售"><a href="#用户数据出售" class="headerlink" title="用户数据出售"></a>用户数据出售</h2><p>像“网易星球”，淘宝的“麻吉宝” 等都是一样的。  </p>
<p>这些平台的出发点都是：“用户能更好的利用自己产生的数据（信用，浏览轨迹，文章，评论点赞，购物娱乐等行为），转化成资产和金钱”。但是，如果当前中心化的那些公司，真的愿意让用户售卖这些数据，有问题吗？如果它能定期给份报告给用户，说我们使用它时产生了多少数据，然后给回多少钱给我们，我们会在意它是区块链吗？其实是没有的。可能有人会反驳说，如果没有区块链，很容易造假。可是，这些产品，现在后面用没用链我们都不知道。况且，现在只有它们自己在维护，谁说他们不能造假？它们允许我们同步节点数据吗？我们能通过什么方式查询链上的数据吗？如果一家公司只是使用普通数据库，但是能开源代码，开放数据库的读权限，还能回馈奖励给我们，那有什么不可信的？  </p>
<p>最重要的问题，只是现在提供服务的公司没有意愿和必要，把我们产生的数据的再生产价值反馈给我们。当前标榜了区块链的公司或者产品，有价值只是因为它们能发个币在交易所，还可以卖钱。想象一下，如果 Facebook, QQ, 微信等社交巨头，内部推出积分制度，而且可以兑换成金钱，那些标榜区块链的平台还有竞争力吗？代表了价值的巨量内容当前都在巨头手里，当政策开放了，允许虚拟积分和法币互换，或者巨头被倒逼到一定程度，觉得内容价值有持续流出的趋势，它们可以马上补贴和复制模式（说不定现在的网易星球和其它巨头背后就在布局准备）。老巨头推动政策的发展，或者举政策大旗来封杀那些区块链产品都是很有可能的。  </p>
<h2 id="公链"><a href="#公链" class="headerlink" title="公链"></a>公链</h2><p>如果说前段时间 ICO 火热的是各种区块链应用，那最近遭争抢和吹捧的应该就是公链了，如出名的 EOS。公链的价值到底在哪？  </p>
<h3 id="可供公开查询的区块链账本"><a href="#可供公开查询的区块链账本" class="headerlink" title="可供公开查询的区块链账本"></a>可供公开查询的区块链账本</h3><p>正如 BTC，Ethereum 等公链，所有的数据都公开。理论上说，只有搭建在公链的 2C 应用，才是可信的面向个人的区块链应用场景。不然，你说你自己用了区块链，保证公开透明，谁相信？但是，真的有那么多应用，适合把数据公开，应该部署在公链上吗？  </p>
<h3 id="云平台"><a href="#云平台" class="headerlink" title="云平台"></a>云平台</h3><p>公链其实应当和亚马逊 AWS，Azure，腾讯云，阿里云等一样，是一个为开发者部署应用提供服务的云平台。只是，公链提供的是分布式的数据库（区块链）。  </p>
<p>我就拿云平台的老大 AWS 和当红公链 EOS 来比较一下吧。  </p>
<p>一般来说，云平台的收入，理应来自开发者应用使用云服务的费用。它的收益，就是所有开发者购买云服务的费用，减去云平台的所有运营成本。  </p>
<p>Amazon 当前的股价大概是 1580 USD，总股本是 4.85亿。根据 Amazon 2017 的财报，AWS 的营收大概为 43亿。假设它的股价全部归功于 AWS（ Amazon 的北美和国际商城总收益为负 2亿），AWS 的总体量约为 5亿 x 1500 USD = 7500亿 USD。  </p>
<p>EOS 的总发行量为 10亿，价格为 18 USD 左右，那它的总价值是 180亿 USD。  </p>
<p>到这里，你可能会想，EOS 岂不是还能升值很多倍？激动得要赶紧 All In 了是吧？别着急。  </p>
<p>首先，AWS 要达到这么多的收益，它的销售总额是 174亿，支出为 131亿。要达到这么多的销售额，需要有多少在使用着 AWS 服务的公司在支撑着，它们的营收又有多少？以后基于 EOS 之上搭建的应用，又能有多少，体量能有 AWS 的 1/40 吗？  </p>
<p>再说，EOS Token 的价值，还不能用和 Amazon 一样的股票价值估算方式。  </p>
<p>首先，EOS Token 每年会增发不超过 5%（这个值其实比一些国家的通胀要厉害了）。那这些 Token 会全部流通出去，造成贬值吗？  </p>
<p>在 EOS 的世界，应用开发者，是需要持有一定量的 EOS Token，才能给它们的服务维持一定量的存储，CPU，带宽资源。也就是说，假定所有人的持仓相对稳定的情况下，要保持服务质量不变，你的 Token 不能卖。假如，你提供的应用服务发展火爆，你就需要扩展（如日益增加的存储成本），也就是要买入和持有越来越多的 EOS Token。  </p>
<p>而那些争抢拉票的区块 producer 节点，要维持节点的地位，也要保持一定的 Token 在手，才能拥有足够的投票权力。而且，要成为节点，按照 EOS 团队公布的硬件门槛，最少需要达到亚马逊 AWS EC2主机x1.32xlarge 型，128核处理器，2TB内存，2x1920GB SSD，25Gb带宽。一台服务器的成本，一年就需要高达约 76 万人民币。按现在一个 EOS 100元人民币算，一年成本约为 7600 个 EOS。  </p>
<p>增发的 Token 当中，其中有 1% 是给区块 producer 节点的。那 Token 的价值，和节点的运营成本，到底哪个高一些呢？10 亿 EOS 的 1% 为 1 千万，如果平均分配给 121 个区块 producer 节点，那每个节点约拿到 8 万个。如果需要一半来维持服务质量和地位，剩下一半变现。假如要 2万个来覆盖成本，那获益还是很可观的。但是，如果 EOS 生态如果没产生足够的价值，变现的量可能不小，贬值的风险也是很高的。  </p>
<p>EOS 的模型实在是很复杂，我觉得真的可以算是一个有趣的社会实验。如果 EOS 生态有价值，能良性发展，就像一家好的公司一样，等模式稳定后投资，是不错的。但是，如果现在盲目 All In，风险也不小。  </p>
<h3 id="分叉，ICO，Airdrop"><a href="#分叉，ICO，Airdrop" class="headerlink" title="分叉，ICO，Airdrop"></a>分叉，ICO，Airdrop</h3><p>BTC 分了无数个叉，好一些又上了交易所，“随便”定了一个价，基本就凭空多了一个市值巨大的“数字货币”。  </p>
<p>在数字货币火热的时候，在 Ethereum 发个 Token，ICO 一下，然后上交易所，就可以凭空吸引无数的资金进场。  </p>
<p>ETH 的价格，在某种程度上来说，由于它在 ICO，和 Airdrop 中作为基本参与凭证的需要，被争抢。物以稀为贵，它的价格也在此期间大涨。但是它的技术面有改变吗？能支持的最大交易数有提高吗？智能合约支持的功能有增多吗？似乎都没有很大变化。它的上涨，基本是因为经济学上的供求关系的变化引起的。所以，ICO 降温后，又遇上数字货币遭打压，ETH 就跌了不少。  </p>
<p>很多人（包括我），拿 EOS 对标 ETH，觉得它具备那么多先进的功能，那么快的交易速度，肯定会涨到 ETH 的价格，然后替代 ETH。可是这个逻辑真的成立吗？即便它能替代 ETH，但 ETH 的价格，有多少提现的是公链应有的价值，哪些只是 ICO 的需求泡沫？美国 SEC 当前也要查 ETH 到底是否属于证券，加以监管了。  </p>
<h2 id="数字货币"><a href="#数字货币" class="headerlink" title="数字货币"></a>数字货币</h2><p>为什么公链分个叉出来，就可以为新的分叉币随便定价了？这些真的是数字货币，有货币的价值吗？  </p>
<p>货币，本质来说，是一种在某个经济体中，被人们承认的交易媒介。无论是古代的贝壳，黄金，还是纸币，甚至是监狱里的香烟，都一样。  </p>
<p>能被人们承认，要么它有实质价值，要么它有中心化的机构或人背书。而现在的“数字货币”，价值是怎么确定的呢？我觉得，它们确实是为了信仰而充值的。  </p>
<p>到底是什么信仰呢？拿 BTC 来说，它由算法背书，无法篡改，永不增发，有一定的匿名性。所以，一开始它流通于灰色领域，被某些追随特定经济理论的人士追捧。但这些信仰值多少钱，为什么能从一美分不到，变成现在的一万美元？这些信仰能被追随多久？除了信仰外，我也曾觉得它是数字时代的黄金，甚至比它更优。但是，BTC 却需要依赖矿工才能维持运转，那等到所有的币都挖完了，单单收交易费能覆盖矿机运作的成本吗？  </p>
<p>上面似乎我都在一直贬低火热的，和曾经自己深信的东西，但是这并不代表我对它们都失去信心。只是稍微更冷静地思考它们的可能，即便这样做我没法像那些站在风口鼓吹的人那样赚那么多钱。我依然觉得区块链技术有它适用的场景，去中心化的数字货币也是未来的一部分。我觉得它绝不是荷兰的郁金香泡沫，但它的真正价值，会到达什么高度，给我们带来什么改变呢？  </p>
<p>附赠两篇我很喜欢的公众号最近关于区块链的文章吧，有弹有赞，多方面了解认识更有助于我们全面思考。  </p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&amp;mid=2649867685&amp;idx=1&amp;sn=3ce18dc2f2d872bf56ea8238ac440188&amp;chksm=f1075fc8c670d6de1dde354f7ce9c8fd125092591c1aa50e4b3618a5b4b2a332dd52dc4b8ec6&amp;scene=21#wechat_redirect" target="_blank" rel="external">竞价排名永不倒</a>  </p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=2649827999&amp;idx=1&amp;sn=5374d71f1baa677ffe6805d36fac2af0&amp;chksm=8704a883b07321953c6e713bb86a08ca546a18f661522bbbf89a8832fbdb897f82babdc7a11e&amp;scene=21#wechat_redirect" target="_blank" rel="external">欢迎来到区块链的世界</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链炒币和 ICO 热潮最近稍微降温下来，比特币从最高近 2W 美金，跌至最低 6K 多，现在再回升到 9K 左右。作为一个“盲目”认定比特币价值，但是又不敢“All In”投资/炒币的人，我并没有赚到很多钱，但是也没有损失。因为没有怎么卖出，所以账面价值看上去，资产还是
    
    </summary>
    
      <category term="Think" scheme="http://www.thinkingincrowd.me/categories/Think/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Bitcoin" scheme="http://www.thinkingincrowd.me/tags/Bitcoin/"/>
    
      <category term="EOS" scheme="http://www.thinkingincrowd.me/tags/EOS/"/>
    
  </entry>
  
  <entry>
    <title>很多所谓的“区块链”项目，在比特币面前就是渣</title>
    <link href="http://www.thinkingincrowd.me/2018/03/30/many-blockchain-products-are-trash-compared-to-bitcoin/"/>
    <id>http://www.thinkingincrowd.me/2018/03/30/many-blockchain-products-are-trash-compared-to-bitcoin/</id>
    <published>2018-03-30T15:23:51.000Z</published>
    <updated>2018-05-09T12:15:18.785Z</updated>
    
    <content type="html"><![CDATA[<p>说来惭愧，从自己知道比特币，买比特币到现在也有三四年了吧，我也是最近才认真地看完了它的白皮书。可能也是因为这个原因吧，虽然我相信它有价值，但是也不敢说自己是“坚信”。所以，这也是我并不敢花太多钱去买它的原因，即便当时比特币才 3000 元人民币左右。当时就想着万一它成了，就留给儿子吧。  </p>
<p>比特币的白皮书 （<a href="https://bitcoin.org/bitcoin.pdf）" target="_blank" rel="external">https://bitcoin.org/bitcoin.pdf）</a> 其实才短短 9 页，最后一页还是参考文章列表。可在这短短的 8 页里，中本聪却能非常清晰明白地说明，比特币是用来解决什么问题，里面使用的每个技术是为了解决其中哪部分问题，为什么。整个论文的论述是非常自洽的。最重要的是，他不是从技术出发，而是从业务问题出发，再论证每个使用的技术如何解决局部问题，最终实现了目标。  </p>
<p>我尝试来解释一下这个自洽的论证是如何做的。</p>
<p>比特币是什么？  </p>
<blockquote>
<p>无须依赖中央金融机构，点对点的电子货币交易系统。  </p>
</blockquote>
<ul>
<li><p>中央金融机构有什么问题？  </p>
<p>跨国支付，尤其是小额支付，成本，等待时间太高，覆盖范围也受影响。支付可行性，灵活性受限于此中央金融机构。  </p>
</li>
<li><p>那为什么我们还需要中央金融机构？  </p>
<p>不考虑假钞的前提下，面对面的金钱交易才能解决交易双方的信任问题。但是，在线和跨地区的电子交易，必须交由可信的第三方中央金融机构监督，才能保证卖方确实收到买方的钱。因为中央机构可以确保买方承诺支付的钱，不会也不能同时给另一个人。这也就是所谓的杜绝“双花（double spending）”问题。  </p>
</li>
<li><p>如何可以不通过中央金融机构，也能防止“双花”问题呢？  </p>
<p>要防止“双花”，就必须知道支付方的所有出入账记录。所以，如果不通过中央金融机构监管，那就是每个人的每一笔交易记录，都必须广播给其它所有人知道，由此可以让大家都一致认定每笔交易，和它们的先后顺序。账本的公开，也就是让每个人都可以承担记账的功能，通过<strong>分布式</strong>来代替集中式。  </p>
</li>
<li><p>谁做的交易统计才可信？  </p>
<p>由于每笔交易都广播给全世界知道，但每个人接收到的广播信息，还是可能会有偏差的，因为分布式的网络是不稳定的，每个人也不确定是否确实收到了所有的广播。或者，中间有人作假，甚至联合作假怎么办？这里就需要引入一种<strong>共识机制</strong>，也就是记账的人要遵循的统一的规则，来确保什么样的记账才算数。  </p>
</li>
<li><p>共识机制是什么？  </p>
<p>比特币系统选择的是<strong>工作量证明（POW）</strong>。每一个记账方，都需要按特定的算法一直做数学运算，直到算出来的值，是符合约定的某种特定规范，它才可以把之前一直接收到的有效的交易数据，统计打包（生成一个 block），然后向外公布。一但某个记账方，收到了其它记账方的交易统计（block），它就要停止手上的计算，验证这个统计的正确性，并加入到账本（blockchain）最末尾。这里有个很特别的地方还包括，每一个 block 会有自己的 Hash 值（计算机术语，可以理解为唯一的指纹），而且它还和上一个 block 的 Hash 有关。  </p>
</li>
<li><p>为什么这种机制保证安全和公平？  </p>
<p>首先，这种数学运算有统一的规则，需要拿上一个 block 里定的某个随机数来做下一次的计算。这里既有透明的规则，又有随机成分，没有人可以提前算出一批结果，参与的人只需要贡献他们计算机的算力，相对公平。  </p>
</li>
<li><p>有人垄断算力怎么办？  </p>
<p>如果有记账方很有钱，它占有整个网络很多的算力，是不是就能比其它记账方，算的快呢？这个算法还有一个特点，就是如果发现 block 生成的速度变快，还能自动调节难度，让计算更复杂，减慢 block 生成的速度，大概维持在 10 分钟左右一个。  </p>
</li>
<li><p>速度慢还有什么好处？  </p>
<p>前面提到，分布式的交易记账，不同的记账方，是有可能有偏差的。导致的结果是，你接收到的 block 信息，也有可能和其它人不一致。也就是一条交易统计链，从全世界角度来看，可能会有几条不同的分支。那么，最终是以哪条为准呢？链最长的那条。所以，每个记账方，除了记录自己正在记账的链，还要记录公布出来的其它链的信息，一但发现某条链越来越长，它就应该切换到最长的链去接着统计。block 生成速度慢，加上随机性的存在，就不至于让算力垄断方，那么容易生成最长的链。要一直维持绝对优势，需要比别人超出很多算力。  </p>
</li>
<li><p>真的值得作假吗？  </p>
<p>假如真的有人具有垄断性的优势，真的值得作假吗？首先，交易数据的结构设计，使得它只可能修改自己的交易记录，把自己的钱偷回来，它是没法偷别人的钱的。而且，要修改记录，由于前面提到的，每个 block 都是有各自的 Hash，还包含了上一个 block 的 Hash。也就是说，它修改了某一个 block 的数据，就要把后面所有的 block 都改掉，<strong>篡改记录的成本是很高的</strong>。最后，作为一个诚实的记账者，只要能争取算出正确的值，生成 block，就能获得一定量的比特币奖励。所以，如果某个记账方，或者黑客，真的拥有垄断性的算力，那它是用来争取获得奖励划算些，还是尝试偷回自己那么点币划算些呢？  </p>
</li>
</ul>
<p>以上的每一个点，都环环相扣。每个技术的使用，都有特定的考量。所以，为什么说比特币是区块链上的第一个有真正价值的应用，真不是说说而已。  </p>
<p>反观，现在一些项目介绍和白皮书，堆砌了各种名词技术，吹的天花乱坠，只是说能干嘛，但是为什么需要用到这些技术，怎么使用它来解决某个问题都没说清楚。只是泛泛地说它的共识算法要更先进，吞吐量高，不耗电等，更别说有没有解释清楚这个项目为什么非得用区块链来解决了。  </p>
<p>还有，很多公司做的所谓“区块链”项目，我感觉都是营销噱头，包括网易星球，和这两天刷朋友圈的淘宝弄的麻吉宝等。这些项目，和普通的导流，积分系统有啥区别？为什么要用区块链？用户怎么知道你用了区块链没？除了项目方自己外，谁还 host 了节点保证记录没那么容易被篡改？一些公司动不动就说自己用区块链技术，给用户带来信任，因为它不可篡改。可是它们根本不知道在什么情况下才不可篡改。  </p>
<p>比特币虽然有缺陷，但是更多的项目还都是渣。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说来惭愧，从自己知道比特币，买比特币到现在也有三四年了吧，我也是最近才认真地看完了它的白皮书。可能也是因为这个原因吧，虽然我相信它有价值，但是也不敢说自己是“坚信”。所以，这也是我并不敢花太多钱去买它的原因，即便当时比特币才 3000 元人民币左右。当时就想着万一它成了，就
    
    </summary>
    
      <category term="Think" scheme="http://www.thinkingincrowd.me/categories/Think/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Bitcoin" scheme="http://www.thinkingincrowd.me/tags/Bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>被愤怒之火烧毁的，不仅有敌人，还可能有自己</title>
    <link href="http://www.thinkingincrowd.me/2018/03/21/anger-begets-greater-anger/"/>
    <id>http://www.thinkingincrowd.me/2018/03/21/anger-begets-greater-anger/</id>
    <published>2018-03-21T00:06:13.000Z</published>
    <updated>2018-04-10T08:46:23.605Z</updated>
    
    <content type="html"><![CDATA[<p>很早就听到许多人都在推荐《三块广告牌》（3 Billboards）这个电影，它的主题，和保姆纵火案，江歌案，为母报仇的张扣扣事件类似，都和至亲失去有关。  </p>
<p>Momself 的<a href="https://mp.weixin.qq.com/s/VCOmyr5JDKFOQdkEcrT86g" target="_blank" rel="external">文章</a>说，对于一个愤怒的，失去至亲的人来说，还有另一种当今时代的非政治正确的选择：<strong>不，绝不放下。</strong>。  </p>
<p>我觉得，很难说什么是政治正确和不正确，只是你想用什么态度来和失去的至亲，以及这个世界相处。  </p>
<p>《三块广告牌》里面的主角，是一位失去了女儿的母亲，在一条不太有人出入小镇的路边，竖立了三块广告牌：「RAPED WHILE DYING」，「AND STILL NO ARRESTS?」，「HOW COME, CHIEF WILLOUGHBY」，意思是「垂死时还被强奸」，「怎么还没逮捕？」，「威洛比警长，怎么一回事」。  </p>
<p>电影开始没多久，我们就感受到了那位母亲的愤怒，和绝不放下的态度。  </p>
<p>但是，这仅仅是因为 Momself 里面的文章所说，<strong>她想让全世界看到她的愤怒</strong>吗？是“<strong>她不放弃，正是为了她自己。因为一旦放弃，她就会跌进失去女儿痛苦的万丈深渊里。复仇，是她巨大而唯一的力量。</strong>”吗？  </p>
<p>我觉得不仅仅是这样。而且那不是真正的原因。下文大量剧透，建议你还是先看了电影，再回头来看看我说的对不对。  </p>
<h2 id="外因"><a href="#外因" class="headerlink" title="外因"></a>外因</h2><p>挂广告牌的黑人工人和一名警察之间的唇枪舌战；女主的黑人朋友知道她竖起广告牌后支持她说：“加油，整死那帮警察”。广告商老板（白人），在面对警察来质问：“你真的想和警察局过不去吗？”，回答到：“我想是的”。  </p>
<p>电影中相当多的画面，都体现了普通民众，和警察之间的紧张情绪，甚至是对立，互不信任的状态。  </p>
<p>所以，<strong>主角不妥协的态度，我觉得一方面的原因，还因为她对警察不信任，认为他们不作为，没有尽力调查。</strong><br>电视台采访女主角的时候，她说：“威洛比警长，有着不可推卸的责任”。  </p>
<p>可是，当警长亲自和她解释，说全国没任何一个人的 DNA 能匹配上，也没有任何目击证人，他真的没有没办法的时候，女主觉得甚至可以侵犯民权法，让全镇，全国的男士去验 DNA。当警长和她坦白自己有癌症后，她还说：“等你死了后，广告牌上话的不就没用了吗？”  </p>
<p>显然，她觉得，自己可以用任何手段，甚至侵犯任何人合法的隐私权益，来为自己服务。所有的外人，都有责任协助她。  </p>
<p>为什么她这么迫切寻找外因，把责任归咎于他人呢？  </p>
<h2 id="内因"><a href="#内因" class="headerlink" title="内因"></a>内因</h2><p>剧中有一幕，她经过自己女儿房间，回想起当天女儿向她借车的情景。她们大吵了一架，她不借车给女儿，让她走路去，还附和着斗气说，希望女儿半路被强奸。  </p>
<p>还有，她前任丈夫回来劝她别登广告。临走前告诉她：“女儿死前一周，问能不能搬去和他住，说忍受不了她妈妈和哥哥，不想再和他们争吵了。“ 他还自责地说：“如果当时不是他劝说女儿留在这，女儿可能就不会死了。” 女主得知后非常痛苦，不愿意相信，但向儿子求证，儿子却有话不说。  </p>
<p>这，显然就是内因。<strong>她不愿意面对，不愿意接受，她女儿的死，和她也有“关系”。</strong></p>
<p>我这里说有“关系”，并不是指她的气话，和不借车造成女儿的遇害。很多人在至亲出事后，都会归咎于自己，过度自责，这也不是健康的心理行为。但是，如果因为无法承受心中的悲痛，逃避自身的情感，而转化为对外的愤怒和指责，那带来的伤害也会很大。  </p>
<p>武志红老师说过，一个人如果无法独自承受和化解一些黑色的死亡能量，同时也没有一段良好的关系帮助 Ta，这份死亡能量要么向内攻击自己，要么就会向外攻击他人。  </p>
<p>过度自责就是攻击自己，迁怒就是攻击他人。  </p>
<h2 id="迁怒之罪"><a href="#迁怒之罪" class="headerlink" title="迁怒之罪"></a>迁怒之罪</h2><blockquote>
<p>Anger begets greater anger</p>
</blockquote>
<p>这句确实是本片的中心思想。Momself 的文章那里翻译为：“压抑之怒将催生出更大的愤怒”。但我觉的并不是，因为不仅仅压抑会催生，而是<strong>愤怒直接催生更大的愤怒</strong>。  </p>
<p>整个电影，展示了大量的迁怒，报复等行为，如：  </p>
<ul>
<li>女主咒骂前任丈夫找的年轻女人，是闻起来像屎一样的野鸡。  </li>
<li>支持警长的牙医，不怎么认真检查女主的牙，就说要拔了。  </li>
<li>自称警长好朋友的不明身份之人，到女主上班的店铺生事。  </li>
<li>一名警察为了死去的警长，把提供广告服务给女主的老板，从二楼丢了下去。  </li>
</ul>
<p>这些行为，并不是那些人压抑自己的愤怒而导致，而是肆意表达，和发泄他们的愤怒。每个人都认定心中的正义，甚至或多或少利用职能之便，行报复之事。最终，导致自己的愤怒不断升级，或者他人更严重的报复。  </p>
<p>电影里面最突出的两个人物，就是女主和警长身边的那位警察。他们都自认为手握真理，习惯于按自己的逻辑和做事方式来对待他人的。认定了谁是过错方，就用自己的方式去惩罚他。所以，他们俩，也因为警长的事情，势不两立。  </p>
<p><strong>迁怒实在是太容易，也是很自然的事情。人总是本能的回避黑色的死亡能量</strong>。想想你是否曾经带着工作的情绪，回家后发泄到妻子或者孩子身上。  </p>
<h2 id="重要的是看到"><a href="#重要的是看到" class="headerlink" title="重要的是看到"></a>重要的是看到</h2><p>电影后期，女主和那位警察竟然能相互理解了。为什么会有这样的转变呢？  </p>
<p>那位警察，一直没看到自己压抑的愤怒，是如何通过其它方式释放出来的。但是，当他看了警长留给他的信后，他的内心，被看到；他的愤怒和黑色死亡能量被接纳了。  </p>
<blockquote>
<p>我觉得你太易怒了，这都归因于你父亲的去世，你不得不全身心去照顾你妈妈。可是，只要你把那么多的仇恨都深深埋入心底，你都无法成为你想成为的那样一名侦探。<br>…<br>成为一名真正的侦探的要诀是，爱。只有通过爱，才能内心获得平衡。通过内心的平衡，才能拥有思想，有思想才能侦查到一些东西。<br>…<br>没人觉得你是同性恋有什么问题。如果有人觉得是问题，你就以恐同罪逮捕他们。  </p>
</blockquote>
<p>而女主，我觉得是她一次次的犯事后，警察因为没有真正的证据，而不能逮捕她。她身为罪犯，却能逃脱刑责，理解到了警察必须依据证据办事的态度和方式。那个为了袒护她而说谎的侏儒，在约会当晚愤怒地爆发。她终于看到，自己的黑色死能量是如何伤害到其他人，也慢慢意识到，自己开始成为自己原来厌恶的人。  </p>
<p>更重要的是，她火烧警察局当晚，那个警察拼死保护一份案卷（可能是她女儿的）。他还积极查案，为了收集证据而被暴打。这些行为都深深地震惊了她。当关系中的另一方，接纳了她的死能量，还以生能量的时候。她的愤怒才得以吸纳转化。  </p>
<p>如 Momself 文章所说，<strong>愤怒，需要被看到。但是，我觉得更重要的是要自己真正看到，并合理表达，而不是故意发泄，让别人看到</strong>。  </p>
<p>电影里，有两个理想的处理愤怒的模范。警长老婆，在丈夫自杀当天，给女主送丈夫的遗信，愤怒地表达对女主的不满，和释放自己的情绪。那个广告商老板，得知同病房的烧重伤病友，是扔他下楼的那个警察，被气的发抖和乱吼后，还是给他递上橙汁，准备好吸管。  </p>
<p>现实生活中，保姆纵火案的林爸爸，我觉得也把愤怒处理的非常好。我自问可能没那么强大的自我容器来处理这种愤怒和悲伤。  </p>
<p>电影最后，女主和那位警察，打算联手去抓那位他们认定的强奸犯。开车途中，女主问：“你确定要去吗？”。警察回答到：“杀了那个人？不太确定。你呢？” “不太确定。”</p>
<p>或许我们没法把愤怒处理的很好，但也许可以像电影两个主角最后那样，多问问自己，多尝试去体会自己的愤怒，而不是带着愤怒行事。<strong>至少，我们可以事后向被我们伤害的人，真诚地说声对不起。</strong>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早就听到许多人都在推荐《三块广告牌》（3 Billboards）这个电影，它的主题，和保姆纵火案，江歌案，为母报仇的张扣扣事件类似，都和至亲失去有关。  &lt;/p&gt;
&lt;p&gt;Momself 的&lt;a href=&quot;https://mp.weixin.qq.com/s/VCOmyr
    
    </summary>
    
      <category term="Psychology" scheme="http://www.thinkingincrowd.me/categories/Psychology/"/>
    
    
      <category term="Anger" scheme="http://www.thinkingincrowd.me/tags/Anger/"/>
    
  </entry>
  
  <entry>
    <title>Ethereum Dapp 开发 (5) - 页面开发集成</title>
    <link href="http://www.thinkingincrowd.me/2018/03/17/dapp-development-5-UI-integration/"/>
    <id>http://www.thinkingincrowd.me/2018/03/17/dapp-development-5-UI-integration/</id>
    <published>2018-03-17T05:40:40.000Z</published>
    <updated>2019-02-17T07:09:31.675Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要讲述 Dapp 前端页面，怎么和 Ethereum 帐号网络集成。不过，涉及的前端开发和代码，不会包括在覆盖范围内。因为前端开发框架太多（Vuejs, React, AngularJS，JQuery 等），使用什么都可以，所以本文仅解释合约相关的代码。本文代码以 Vuejs 代码为样例，也在 Github 上。  </p>
<p>本教程，也就是简化版的 Secret Note 页面如下图。页面的最上方，显示的是当前连接的 Ethereum 网络，Gas 价格，和登录的 Ethereum 帐号地址。  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/simple-secret-note-ui.png" alt="Simple Secret Note UI">  </p>
<h2 id="Web3"><a href="#Web3" class="headerlink" title="Web3"></a>Web3</h2><p>想要在页面集成 Ethereum 帐号网络，并且对智能合约进行操作，我们需要借助前一章提及的 <a href="https://github.com/ethereum/web3.js" target="_blank" rel="external">web3.js</a>，它是 Ethereum 兼容的 JavaScript API 库。  </p>
<p>在页面打开初始化的时候，我们需要初始化一个 Web3 的实例。这段代码放在 Vuejs 的 <code>created</code> 事件里。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">created() &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</div><div class="line">    <span class="comment">// Use MetaMask's provider</span></div><div class="line">    web3js = <span class="keyword">new</span> Web3(web3.currentProvider);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">this</span>.showAlertMsg(<span class="string">'Please install &lt;a href="https://metamask.io/" target="__blank"&gt;MetaMask&lt;/a&gt; extension for your browser before using.'</span>, <span class="string">'warning'</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Async</span></div><div class="line">  <span class="keyword">this</span>.detectNetwork();</div><div class="line">  <span class="keyword">this</span>.getGasPrice();</div><div class="line">  <span class="keyword">this</span>.initAccount();</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>当它检测到 <code>web3</code> 这个对象已经存在的时候，就根据当前 web3 的提供者（currentProvider），新建一个 Web3 的实例。只有当 Web3 实例初始化成功的情况下，我们才会继续检测当前的 Ethereum 网络，获取 Gas 价格，以及当前登录的帐号信息。  </p>
<p>那谁会提供 web3 对象呢？就是代码里提醒安装的 MetaMask。<a href="https://metamask.io/" target="_blank" rel="external">MetaMask</a> 是一个浏览器插件，你可以使用它来生成新的 Ethereum 地址帐号，或者登录你现有的帐号。  </p>
<h2 id="网络和帐号的初始化"><a href="#网络和帐号的初始化" class="headerlink" title="网络和帐号的初始化"></a>网络和帐号的初始化</h2><p>在 Ethereum 世界，Eth 地址，就是身份帐号。所以，Dapp 和 Ethereum 的集成，我们应该只需要用户使用它们特定的帐号登陆就可以了，完全没有必要再额外弄用户名密码什么的。集成和使用一个广泛接受的帐号管理工具，能让你的 Dapp 用户更放心。  </p>
<h3 id="代码集成"><a href="#代码集成" class="headerlink" title="代码集成"></a>代码集成</h3><p>帐号初始化的代码，就在 <code>initAccount</code> 这个方法里面：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">initAccount() &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_getAccount</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    web3js.eth.getAccounts(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (result.length === <span class="number">0</span> || result[<span class="number">0</span>] === that.account) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      that.account = result[<span class="number">0</span>];</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setInterval(_getAccount.bind(<span class="keyword">this</span>), <span class="number">100</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里比较特别的是，设置了一个定时器，每隔 100ms 就会检测当前的帐号是什么，然后更新页面的帐号信息。</p>
<p>如果你看了 <code>detectNetwork</code> 和 <code>getGasPrice</code> 里面的代码，可能会疑惑，为什么它们不需要设定定时器呢？因为，MetaMask 插件检测到你切换网络，并且当前页面曾经访问和使用过 web3 对象的话，它会自动刷新页面。  </p>
<h3 id="MetaMask-配置"><a href="#MetaMask-配置" class="headerlink" title="MetaMask 配置"></a>MetaMask 配置</h3><h4 id="本地网络设置"><a href="#本地网络设置" class="headerlink" title="本地网络设置"></a>本地网络设置</h4><p>因为我们当前是使用本地的 Ganache 网络来测试，所以我们先要在 MetaMask 上面配置好网络和相应的测试帐号。  </p>
<p>首先我们点击左上角的网络下拉选择器，然后点击 <code>Custom RPC</code>：  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/metamask-custom-rpc-menu.png" alt="MetaMask Custom RPC Menu">  </p>
<p>然后我们在 Current RPC 下面输入 <code>http://localhost:7545</code>，点击 <code>Save</code>。  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/metamask-custom-rpc-setup.png" alt="MetaMask Custom RPC Setup">  </p>
<h4 id="帐号设置"><a href="#帐号设置" class="headerlink" title="帐号设置"></a>帐号设置</h4><p>安装完 MetaMask 插件时，它默认会帮你创建了一个新帐号。但是，我们需要把 Ganache 自动生成的帐号导入 MetaMask，才能使用它们和我们部署的合约交互。  </p>
<p>在 Ganache 首页的帐号列表下，我们选择第一个（合约创建帐号），点击最右边的钥匙图标，查看它的私钥，并且复制下来。（这里是测试帐号，所以暴露私钥没关系。但是如果是你的真实 Ethereum 帐号，就一定不能暴露了）  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/ganache-account-show-key.png" alt="Ganache Account Show Key">  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/ganache-account-private-key.png" alt="Ganache Account Private Key">  </p>
<p>然后，我们点击 MetaMask 页面右上角的小人图标，会出来以下菜单：  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/metamask-account.png" alt="Metamask Account">  </p>
<p>最后，点击 <code>Import Account</code> 菜单，就进入以下输入私钥的页面。然后粘贴刚才复制的私钥，点击 <code>Import</code> 即可。  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/metamask-account-import.png" alt="Metamask Account Import">  </p>
<h2 id="智能合约的引入和交互"><a href="#智能合约的引入和交互" class="headerlink" title="智能合约的引入和交互"></a>智能合约的引入和交互</h2><p>既然 Ethereum 测试帐号和网络的集成已经准备好，我们就可以在代码引入智能合约，并与之交互了。  </p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>首先，我们要先在当前项目下安装和使用 <code>truffle-contract</code> 这个包。  </p>
<blockquote>
<p>npm install truffle-contract</p>
</blockquote>
<p>然后，在页面里 JavaScript 脚本的顶部，加入以下几行代码，引入上一章我们运行 <code>truffle compile</code> 后生成的合约 json。并且，配置好我们运行 <code>truffle migrate</code> 后部署在 Ganache 里面的合约地址。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Contract <span class="keyword">from</span> <span class="string">'truffle-contract'</span>;</div><div class="line"><span class="keyword">import</span> SecretNoteDef <span class="keyword">from</span> <span class="string">'../build/contracts/SecretNote.json'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> SecretNote = Contract(SecretNoteDef);</div><div class="line"><span class="keyword">const</span> CONTRACT_ADDRESS = <span class="string">'0x345ca3e014aaf5dca488057592ee47305d9b3e10'</span>;</div></pre></td></tr></table></figure>
<p>最后，在 Vue 组件的 <code>created</code> 事件里，等 web3js 初始化成功后，设置合约的 Ethereum 网络地址。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SecretNote.setProvider(web3.currentProvider);</div></pre></td></tr></table></figure>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>和智能合约的交互分两种：  </p>
<ol>
<li><p>Transaction  </p>
<p>Transaction 类型的交互是会永久改变 Ethereum 网络的状态，也就是涉及账户之间的转账，或者智能合约的数据的改变。这种交互是需要花费 Gas 的，而且交易需要确认，并不能马上返回。所以，这些交互需要绑定在某一个账户下来执行。SecretNote <code>setNote</code> 方法的调用就属于这种类型。  </p>
</li>
<li><p>Call  </p>
<p>Call 类型的交互只是从区块链中读取数据。所以，它是不需要消耗任何 Gas 的，而且也能马上获取返回值。SecretNote <code>getNote</code> 方法的调用则属于此类型。  </p>
</li>
</ol>
<h4 id="Transaction-调用"><a href="#Transaction-调用" class="headerlink" title="Transaction 调用"></a>Transaction 调用</h4><ol>
<li>调用 <code>SecretNote.at()</code> 方法从特定地址获取合约实例。  </li>
<li>在获取的实例对象上，像调用普通 JavaScript 方法一样使用。特别之处是要指定调用的帐号地址。  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">saveNote() &#123;</div><div class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  SecretNote.at(CONTRACT_ADDRESS)</div><div class="line">    .then((instance) =&gt; &#123;</div><div class="line">      <span class="keyword">return</span> instance.setNote(that.noteForm.noteName,</div><div class="line">        that.noteForm.noteContent, &#123; <span class="keyword">from</span>: that.account &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>执行成功后，会弹出如下页面：  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/metamask-trx-request.png" alt="Metamask Trx Request">  </p>
<p>点击 <code>Submit</code> 后，交易记录会出现在账户下并等待区块链的确认。  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/metamask-trx-confirm.png" alt="Metamask Trx Confirm">  </p>
<h4 id="Call-调用"><a href="#Call-调用" class="headerlink" title="Call 调用"></a>Call 调用</h4><p>SecretNote <code>getNote</code> 方法调用其实和 <code>setNote</code> 差不多，只是不需要指定帐号而已。  </p>
<p>有一点要注意的是，这个方法定义的返回值类型是 <code>bytes32</code>，所以要使用 <code>toAscii</code> 方法把内容转换后才使用。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">loadNote() &#123;</div><div class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  SecretNote.at(CONTRACT_ADDRESS)</div><div class="line">    .then((instance) =&gt; &#123;</div><div class="line">      <span class="keyword">return</span> instance.getNote(that.noteForm.noteName);</div><div class="line">    &#125;)</div><div class="line">    .then((noteContent) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (!noteContent) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      that.noteForm.noteContent = web3js.toAscii(noteContent);</div><div class="line">    &#125;);</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>由于我们现在是在本地 Ganache 测试网络上集成和调试的，而 Ganache 每次重启后，数据都被重置，在 Solidity 合约代码还不稳定，需要经常改的时候，这是一个好事。但是，如果合约代码已经稳定，我们要调试前端代码，就不需要合约经常变了。下一章我们再看看如何把合约部署到 Ethereum 的一些公共的测试网络吧。  </p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="http://www.thinkingincrowd.me/2018/02/25/dapp-development-1-what-should-be-in-blockchain/">Ethereum Dapp 开发 (1) - 什么应放在区块链上</a><br><a href="http://www.thinkingincrowd.me/2018/02/27/dapp-development-2-contract-development-in-solidity/">Ethereum Dapp 开发 (2) - 用 Solidity 开发智能合约</a><br><a href="http://www.thinkingincrowd.me/2018/03/05/dapp-development-3-contract-testing-remix-ide/">Ethereum Dapp 开发 (3) - 智能合约测试（Remix IDE）</a><br><a href="http://www.thinkingincrowd.me/2018/03/11/dapp-development-4-contract-testing-truffle/">Ethereum Dapp 开发 (4) - 智能合约测试（Truffle）</a><br><a href="http://www.thinkingincrowd.me/2018/03/17/dapp-development-5-UI-integration/">Ethereum Dapp 开发 (5) - 页面开发集成</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要讲述 Dapp 前端页面，怎么和 Ethereum 帐号网络集成。不过，涉及的前端开发和代码，不会包括在覆盖范围内。因为前端开发框架太多（Vuejs, React, AngularJS，JQuery 等），使用什么都可以，所以本文仅解释合约相关的代码。本文代码以
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Ethereum" scheme="http://www.thinkingincrowd.me/tags/Ethereum/"/>
    
      <category term="Dapp" scheme="http://www.thinkingincrowd.me/tags/Dapp/"/>
    
      <category term="Smart Contract" scheme="http://www.thinkingincrowd.me/tags/Smart-Contract/"/>
    
  </entry>
  
  <entry>
    <title>Ethereum Dapp 开发 (4) - 智能合约测试（Truffle）</title>
    <link href="http://www.thinkingincrowd.me/2018/03/11/dapp-development-4-contract-testing-truffle/"/>
    <id>http://www.thinkingincrowd.me/2018/03/11/dapp-development-4-contract-testing-truffle/</id>
    <published>2018-03-11T08:44:16.000Z</published>
    <updated>2019-02-17T06:41:48.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Truffle-是什么？"><a href="#Truffle-是什么？" class="headerlink" title="Truffle 是什么？"></a>Truffle 是什么？</h2><p>上一篇文章我们已经介绍了如何使用 Remix 来初步测试智能合约。虽然它使用起来很方便，但是还是有一些不适合拿来当测试工具的地方。我们来尝试用另一个叫 <a href="http://truffleframework.com/" target="_blank" rel="external">Truffle</a> 的工具来测试。  </p>
<p>Truffle 是什么呢？它的官方介绍是这样的：  </p>
<blockquote>
<p><strong>YOUR ETHEREUM SWISS ARMY KNIFE</strong></p>
<p>Truffle is the most popular development framework for Ethereum with a mission to make your life a whole lot easier.</p>
</blockquote>
<p>霸气吧？既然敢称自己为 Ethereum 的瑞士军刀，那它肯定不仅仅只能拿来当测试框架用。它其实是 Ethereum Dapp 的一套开发框架。后面的文章我们会再介绍如何使用它来开发，这篇文章暂时只关注如何使用它来测试智能合约。  </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Truffle 是完全基于 JavaScript 写的。它的安装非常容易。  </p>
<blockquote>
<p>npm install -g truffle</p>
</blockquote>
<p>npm 是 <a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a> 的包管理系统，这里我就不介绍了。大家自行到官网下载安装最新的 LTS 版本就可以了。  </p>
<p>另外，我们还要安装 <a href="http://truffleframework.com/ganache/" target="_blank" rel="external">Ganache</a>。这个工具可以很容易地帮我们配置一个本地的 Ethereum blockchain 节点，方便我们测试。这个工具的安装需要根据不同操作系统下载安装包，也非常简单。  </p>
<h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><p>必要的工具安装好以后，我们要配置一个 Truffle 使用的项目目录结构，和一点配置文件。  </p>
<p>我建了一个 Ethereum Dapp 开发的<a href="https://github.com/kenspirit/eth-dapp-base.git" target="_blank" rel="external">模板结构项目</a>放在 Github 上，大家 clone 下来就可以了。里面还有一些前端相关的文件，这些在后面做 Dapp 前端交互的时候再关注，暂时可以不用理会。  </p>
<p>代码克隆下来后，大家先进入项目的文件夹内，运行以下命令，安装一些必要的包。  </p>
<blockquote>
<p>npm install</p>
</blockquote>
<p>整个目录里面，我使用红色框标出和 Truffle 以及测试相关的部分。  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/eth-dapp-base-project-structure.png" alt="Project Structure">  </p>
<ol>
<li><p><code>contracts</code> 目录下放的是智能合约文件。<br>那个特殊的 <code>Migrations.sql</code> 是 Truffle 拿来运行智能合约升级脚本，记录版本的合约。你无须理会。  </p>
</li>
<li><p><code>migrations</code> 目录下，是按顺序要运行的智能合约脚本。<br>这就像你跑数据库升级脚本一样，增量式的。第一个是部署 truffle 那个 <code>Migrations</code> 合约，第二个就是部署我们自己的合约。  </p>
</li>
<li><p><code>test</code> 目录下，存放智能合约的测试脚本。<br>Truffle 支持写 JavaScript 或者 Solidity 来测试智能合约。这次我只介绍怎么用 JavaScript 来测试。  </p>
</li>
</ol>
<ol>
<li><code>truffle.js</code> 和 <code>truffle-config.js</code> 都是它的配置文件。<br>正常来说应该是放在 <code>truffle.js</code> 里面的。但是，在 Windows 环境下，<code>truffle.js</code> 可能会和 truffle 的命令产生冲突。<a href="http://truffleframework.com/docs/advanced/configuration" target="_blank" rel="external">官方文档</a>列了一些解决方案，重命名为 <code>truffle-config.js</code> 是其中一种。  </li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在 <code>truffle.js</code> 里面，我们已经配置了连接的环境是本地的 blockchain。所以，在运行测试前，我们要先启动前面安装好的 Ganache。  </p>
<h3 id="框架和基本规则"><a href="#框架和基本规则" class="headerlink" title="框架和基本规则"></a>框架和基本规则</h3><p>如果你曾经写过 JavaScript 的测试，那你可能已经接触过 <a href="https://mochajs.org/" target="_blank" rel="external">Mocha</a> 和 <a href="http://chaijs.com/" target="_blank" rel="external">Chai</a>。Truffle 就是使用这两个工具来测试的。  </p>
<p>那 Truffle 的测试，和普通的 Mocha 能识别的测试有什么不同呢？  </p>
<ol>
<li><p>Truffle 里面使用的是 <code>contract</code> 关键字，而不是 <code>describe</code> 关键字。  </p>
</li>
<li><p>Truffle 为 <code>contract</code> function 代码块提供了 <a href="http://truffleframework.com/docs/getting_started/testing#clean-room-environment" target="_blank" rel="external">clean-room features</a>。<br>意思就是，在每个 <code>contract</code> 函数运行前，你的合约都会重新部署。那么，在 <code>contract</code> function 里面的所有测试都运行在干净的合约状态之下。（<code>contract</code> 里面的代码都共享一个合约状态，下面会解释）</p>
</li>
<li><p><code>contract</code> 方法提供了一些测试帐号，方便测试使用。  </p>
</li>
</ol>
<h3 id="语法和编写"><a href="#语法和编写" class="headerlink" title="语法和编写"></a>语法和编写</h3><p>Truffle 支持 <code>async/await</code> 和 <code>then</code> 的 Promise 写法。因为前者比较节省篇幅，本文就只介绍 <code>async/await</code> 的写法。如果你还看不惯 <code>async/await</code> 的语法，Truffle 还支持 <code>then</code> 的写法，详细的例子大家可以看看<a href="http://truffleframework.com/docs/getting_started/javascript-tests" target="_blank" rel="external">官网</a>。  </p>
<p>测试文件的整体结构是这样的。  </p>
<p>一开始我们需要使用 <code>artifacts.require(&#39;SecretNote&#39;)</code> 来获得某个特定合约的抽象类，从而可以操作这个智能合约。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> SecretNote = artifacts.require(<span class="string">'SecretNote'</span>);</div><div class="line"></div><div class="line">contract(<span class="string">'SecretNote async/await style full test'</span>, <span class="keyword">async</span> (accounts) =&gt; &#123;</div><div class="line">  <span class="comment">// `it` 测试代码块在这</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>假定我们的第一个测试用例是判定合约最开始的笔记数量是否为 0，那么，相应的 <code>it</code> 测试代码块可以这样写：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'Initial Note Count should be 0'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> instance = <span class="keyword">await</span> SecretNote.deployed();</div><div class="line">  <span class="keyword">const</span> initalCount = <span class="keyword">await</span> instance.getTotalNoteCount();</div><div class="line"></div><div class="line">  <span class="comment">// initalCount is BigNumber object</span></div><div class="line">  assert.equal(initalCount.valueOf(), <span class="number">0</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里有两点要注意的：  </p>
<ol>
<li><p><code>await SecretNote.deployed()</code> 部署和获取一个合约实例。这段代码，只要在一个 <code>contract</code> function 里面调用，无论多少次，获得的合约实例都是同一个。  </p>
</li>
<li><p><code>instance.getTotalNoteCount()</code> 获取的数据，都是被包装成 <a href="https://github.com/MikeMcl/bignumber.js" target="_blank" rel="external">BigNumber</a> 对象的，因为 JavaScript 处理不了大额数字，和浮点数据。  </p>
</li>
</ol>
<p>剩下来我们可以写另外两个测试了：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'Set and get Note'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> instance = <span class="keyword">await</span> SecretNote.deployed();</div><div class="line">  <span class="keyword">const</span> noteKey = <span class="string">'key'</span>;</div><div class="line">  <span class="keyword">const</span> originNoteValue = <span class="string">'value'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">await</span> instance.setNote(noteKey, originNoteValue)</div><div class="line">  <span class="keyword">const</span> noteValue = <span class="keyword">await</span> instance.getNote(noteKey);</div><div class="line">  <span class="comment">// Github issue: https://github.com/ethereum/web3.js/issues/337</span></div><div class="line">  assert.equal(web3.toAscii(noteValue).replace(<span class="regexp">/\u0000/g</span>, <span class="string">''</span>), originNoteValue);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">it(<span class="string">'Note Count is Correct After Setting Note'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> instance = <span class="keyword">await</span> SecretNote.deployed();</div><div class="line">  <span class="keyword">const</span> initalCount = <span class="keyword">await</span> instance.getTotalNoteCount();</div><div class="line"></div><div class="line">  assert.equal(initalCount.valueOf(), <span class="number">1</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里也有两点要注意的：  </p>
<ol>
<li><p><code>web3</code> 是自动注入的 <a href="https://github.com/ethereum/web3.js" target="_blank" rel="external">web3.js</a> 实例，它是 Ethereum 兼容的 JavaScript API 库。  </p>
</li>
<li><p><code>toAscii</code> 在 web3.js 0.1x 版本有数据转换的问题。在 1.0 版本后，会有另外适合人看的转换 API。  </p>
</li>
</ol>
<p>我们测试的最后一个场景是，非合约创建者（Ownable），不能调用 <code>getTotalNoteCount</code> 接口获取到数据：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'Exception should throw if not owner call getTotalNoteCount'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="comment">// accounts[1] 是合约部署地址</span></div><div class="line">  <span class="keyword">const</span> notOwnerAccount = accounts[<span class="number">2</span>];</div><div class="line"></div><div class="line">  <span class="keyword">const</span> instance = <span class="keyword">await</span> SecretNote.deployed();</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">const</span> initalCount = <span class="keyword">await</span> instance.getTotalNoteCount.call(&#123; <span class="keyword">from</span>: notOwnerAccount &#125;);</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="comment">// Chai BDD style.  From truffle v4.0.7</span></div><div class="line">    expect(e, <span class="string">'I know it'</span>).to.exist;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>有需要的话，我们在 Truffle 测试脚本里，还可以用另一种方式和<a href="http://truffleframework.com/docs/getting_started/contracts" target="_blank" rel="external">智能合约交互</a>：  </p>
<blockquote>
<p>const contract = await SecretNote.at(‘0x123456…’);</p>
</blockquote>
<p>‘0x123456…’ 只是示例，它实际上应该放你的智能合约地址。  </p>
<p>那我们怎么在本地编译部署智能合约，和获取它的地址呢？  </p>
<h2 id="编译部署合约"><a href="#编译部署合约" class="headerlink" title="编译部署合约"></a>编译部署合约</h2><p>Ganache 启动后是这个样子的，默认已经准备好了一些测试帐号。  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/ganache-startup.png" alt="Ganache Startup">  </p>
<p>然后，我们在命令行依次运行 <code>truffle compile</code> 和 <code>truffle migrate</code> 命令。运行 <code>truffle migrate</code> 前，要确保你在 <code>truffle.js</code> 配置的 Ethereum 节点已经起来了。当前的配置，就是你的 Ganache。  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/truffle-compile-migrate.png" alt="Truffle Compile Migrate">  </p>
<p>运行完后，你可以再去看 Ganache 里面的第一个账户余额已经不是 100 ETH 了，因为扣除了一部分 Gas 来建立智能合约。点击 Transactions 那个按钮，也可以看到刚才部署智能合约产生的交易记录。  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/ganache-account.png" alt="Ganache Account">  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/ganache-trx.png" alt="Ganache Transactions">  </p>
<p>到这里，你的智能合约已经在本地的 Ethereum blockchain 节点部署完成了。部署到测试环境或者正式 Ethereum 公链的方法，我们后面再介绍。  </p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="http://www.thinkingincrowd.me/2018/02/25/dapp-development-1-what-should-be-in-blockchain/">Ethereum Dapp 开发 (1) - 什么应放在区块链上</a><br><a href="http://www.thinkingincrowd.me/2018/02/27/dapp-development-2-contract-development-in-solidity/">Ethereum Dapp 开发 (2) - 用 Solidity 开发智能合约</a><br><a href="http://www.thinkingincrowd.me/2018/03/05/dapp-development-3-contract-testing-remix-ide/">Ethereum Dapp 开发 (3) - 智能合约测试（Remix IDE）</a><br><a href="http://www.thinkingincrowd.me/2018/03/11/dapp-development-4-contract-testing-truffle/">Ethereum Dapp 开发 (4) - 智能合约测试（Truffle）</a><br><a href="http://www.thinkingincrowd.me/2018/03/17/dapp-development-5-UI-integration/">Ethereum Dapp 开发 (5) - 页面开发集成</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Truffle-是什么？&quot;&gt;&lt;a href=&quot;#Truffle-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Truffle 是什么？&quot;&gt;&lt;/a&gt;Truffle 是什么？&lt;/h2&gt;&lt;p&gt;上一篇文章我们已经介绍了如何使用 Remix 来初步测试智能
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Ethereum" scheme="http://www.thinkingincrowd.me/tags/Ethereum/"/>
    
      <category term="Dapp" scheme="http://www.thinkingincrowd.me/tags/Dapp/"/>
    
      <category term="Smart Contract" scheme="http://www.thinkingincrowd.me/tags/Smart-Contract/"/>
    
  </entry>
  
  <entry>
    <title>Ethereum Dapp 开发 (3) - 智能合约测试（Remix IDE）</title>
    <link href="http://www.thinkingincrowd.me/2018/03/05/dapp-development-3-contract-testing-remix-ide/"/>
    <id>http://www.thinkingincrowd.me/2018/03/05/dapp-development-3-contract-testing-remix-ide/</id>
    <published>2018-03-05T04:20:20.000Z</published>
    <updated>2019-02-17T07:01:19.359Z</updated>
    
    <content type="html"><![CDATA[<p>我们在前面一篇说到，智能合约发布后就没法修改了。所以，在真正发布前，我们必须进行详细的测试。那智能合约怎么测试呢？难不成我们自己要部署一个自己的 Ethereum 网络节点？  </p>
<p>这篇文章，我先介绍一种最简单直接的测试方式。  </p>
<h2 id="完整合约代码"><a href="#完整合约代码" class="headerlink" title="完整合约代码"></a>完整合约代码</h2><p>上一篇教程完成后，智能合约的完整代码应该是这样的。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.18;</div><div class="line"></div><div class="line">contract Ownable &#123;</div><div class="line">    address owner;</div><div class="line"></div><div class="line">    function Ownable() public &#123;</div><div class="line">        owner = msg.sender;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    modifier onlyOwner() &#123;</div><div class="line">        require(owner == msg.sender);</div><div class="line">        _;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">contract SecretNote is Ownable &#123;</div><div class="line">  mapping(address =&gt; mapping(bytes32 =&gt; bytes32)) notes;</div><div class="line">  uint256 noteCount;</div><div class="line"></div><div class="line">  event SecretNoteUpdated(address indexed _sender, bytes32 indexed _noteKey, bool _success);</div><div class="line"></div><div class="line">  function SecretNote() public &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function () public payable &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * @dev For user to get their own secret note</div><div class="line">   * @param _noteKey The key identifier for particular note</div><div class="line">   */</div><div class="line">  function getNote(bytes32 _noteKey) public view returns (bytes32) &#123;</div><div class="line">      return notes[msg.sender][_noteKey];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * @dev For user to update their own secret note</div><div class="line">   * @param _noteKey The key identifier for particular note</div><div class="line">   * @param _content The note path hash</div><div class="line">   */</div><div class="line">  function setNote(bytes32 _noteKey, bytes32 _content) public payable &#123;</div><div class="line">      require(_noteKey != &quot;&quot;);</div><div class="line">      require(_content != &quot;&quot;);</div><div class="line"></div><div class="line">      notes[msg.sender][_noteKey] = _content;</div><div class="line">      noteCount++;</div><div class="line"></div><div class="line">      SecretNoteUpdated(msg.sender, _noteKey, true);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function getTotalNoteCount() public view onlyOwner returns(uint256) &#123;</div><div class="line">      return noteCount;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Remix-IDE"><a href="#Remix-IDE" class="headerlink" title="Remix IDE"></a>Remix IDE</h2><p><a href="https://remix.ethereum.org" target="_blank" rel="external">Remix IDE</a> 是一个在线的智能合约编译，测试和部署工具。使用它可以很方便的和智能合约交互，虽然有些地方不是那么便利。  </p>
<h3 id="合约编译检查"><a href="#合约编译检查" class="headerlink" title="合约编译检查"></a>合约编译检查</h3><p>当我们打开 Remix 的页面，把我们的智能合约代码贴进去的时候，它已经会自动帮你编译代码。右侧是主要的操作区。它有好几个功能标签。<code>Compile</code> 标签会显示出编译后有哪些合约，已经它发现的一些 Warning。  </p>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/Remix_compile_contract.png" alt="Remix IDE - Compile">  </p>
<h3 id="合约创建"><a href="#合约创建" class="headerlink" title="合约创建"></a>合约创建</h3><p>既然编译没有问题，我们点击旁边的 <code>Run</code> 标签看看怎么部署运行这个合约。  </p>
<ol>
<li>选择 <code>JavaScript VM</code> 这个 Environment。你会发现它马上帮你创建了好几个拥有了 100 eth 的帐号。  </li>
<li>在合约名字下拉框选择我们将要部署的合约 <code>SecretNote</code>。  </li>
<li>点击 Create</li>
<li>合约就生成了。它的接口 <code>fallback</code>，<code>getTotalNoteCount</code>，<code>getNote</code>，<code>setNote</code> 都分别显示出来。  </li>
<li>因为我们用了默认提供的第一个帐号来创建合约，它的帐号余额已经不是 100 eth 了。  </li>
</ol>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/Remix_create_contract.png" alt="Remix IDE - Create">  </p>
<h3 id="合约调用"><a href="#合约调用" class="headerlink" title="合约调用"></a>合约调用</h3><p>合约创建完，我们就可以调用合约提供的对外的接口了，有几点值得留意的是：  </p>
<ol>
<li>只读 <code>view</code> 的方法，它的名字是蓝色的；其它的方法名字是粉红色的。  </li>
<li>方法调用时，我们需要用双引号，和逗号把参数分开。  </li>
</ol>
<p>现在我们按 <code>setNote</code>, <code>getNote</code>, <code>getTotalNoteCount</code> 的执行顺序来操作一下。  </p>
<ol>
<li>在 <code>setNote</code> 旁边的输入框填入：<code>&quot;0x1&quot;, &quot;Ken&quot;</code>，点击方法名。点完后好像什么都没有发生，但是你在中间的执行日志区可以看到类似的日志：  </li>
</ol>
<blockquote>
<p>transact to SecretNote.setNote pending …<br>[vm] from:0xca3…a733c, to:SecretNote.setNote(bytes32,bytes32) 0xbbf…732db, value:0 wei, data:0x7b7…00000, 1 logs, hash:0xbbe…7df4d</p>
</blockquote>
<ol>
<li>在 <code>getNote</code> 旁的输入框填入：<code>&quot;0x1&quot;</code>，点击方法名。它的右边就会给出这样的显示：  </li>
</ol>
<blockquote>
<p>0: bytes32: 0x4b656e0000000000000000000000000000000000000000000000000000000000</p>
</blockquote>
<p>因为 Solidity 的 function 是可以有多个返回值的，所以这里显示的是第一个返回值的类型和数值。  </p>
<ol>
<li>同样，点击 <code>getTotalNoteCount</code> 会返回当前的笔记数量。  </li>
</ol>
<blockquote>
<p>0: uint256: 1</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/kenspirit/blog-cdn-data/master/Remix_call_contract.png" alt="Remix IDE - Call">  </p>
<p>现在，我们来看一看如果用另一个帐号（非合约创建帐号），来调用 <code>getTotalNoteCount</code> 会出现什么效果。  </p>
<ol>
<li>在 <code>Account</code> 下拉框选择另外的一个帐号。这个帐号应该有 100 eth，因为从来没操作过。  </li>
<li>点击 <code>getTotalNoteCount</code> 调用方法。  </li>
</ol>
<p>这时候，你会发现中间的执行日志区出现类似下面的日志。其实，你的操作是失败了的。但是它的报错信息实在是太让人困惑了。  </p>
<blockquote>
<p>call to SecretNote.getTotalNoteCount errored: VM error: revert.<br>revert  The transaction has been reverted to the initial state.<br>Note: The constructor should be payable if you send value.  Debug the transaction to get more information. </p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Remix IDE 的基本使用和智能合约的测试就介绍到这里。使用它来测试是比较方便的，你也不用设置什么环境。但是它上面的操作并不是那么灵活，而且是在线工具。  </p>
<p>我们能不能像写 JAVA, JavaScript Unit Test 那样来测试智能合约呢？下一篇文章我将介绍 Truffle 这个框架的使用。  </p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="http://www.thinkingincrowd.me/2018/02/25/dapp-development-1-what-should-be-in-blockchain/">Ethereum Dapp 开发 (1) - 什么应放在区块链上</a><br><a href="http://www.thinkingincrowd.me/2018/02/27/dapp-development-2-contract-development-in-solidity/">Ethereum Dapp 开发 (2) - 用 Solidity 开发智能合约</a><br><a href="http://www.thinkingincrowd.me/2018/03/05/dapp-development-3-contract-testing-remix-ide/">Ethereum Dapp 开发 (3) - 智能合约测试（Remix IDE）</a><br><a href="http://www.thinkingincrowd.me/2018/03/11/dapp-development-4-contract-testing-truffle/">Ethereum Dapp 开发 (4) - 智能合约测试（Truffle）</a><br><a href="http://www.thinkingincrowd.me/2018/03/17/dapp-development-5-UI-integration/">Ethereum Dapp 开发 (5) - 页面开发集成</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在前面一篇说到，智能合约发布后就没法修改了。所以，在真正发布前，我们必须进行详细的测试。那智能合约怎么测试呢？难不成我们自己要部署一个自己的 Ethereum 网络节点？  &lt;/p&gt;
&lt;p&gt;这篇文章，我先介绍一种最简单直接的测试方式。  &lt;/p&gt;
&lt;h2 id=&quot;完整合
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Ethereum" scheme="http://www.thinkingincrowd.me/tags/Ethereum/"/>
    
      <category term="Dapp" scheme="http://www.thinkingincrowd.me/tags/Dapp/"/>
    
      <category term="Smart Contract" scheme="http://www.thinkingincrowd.me/tags/Smart-Contract/"/>
    
  </entry>
  
  <entry>
    <title>Ethereum Dapp 开发 (2) - 用 Solidity 开发智能合约</title>
    <link href="http://www.thinkingincrowd.me/2018/02/27/dapp-development-2-contract-development-in-solidity/"/>
    <id>http://www.thinkingincrowd.me/2018/02/27/dapp-development-2-contract-development-in-solidity/</id>
    <published>2018-02-27T12:20:20.000Z</published>
    <updated>2019-02-17T07:01:36.214Z</updated>
    
    <content type="html"><![CDATA[<p>Ethereum 的 Dapp 开发，保存数据在公链上，最基本的就是要实现一个智能合约。我们先来看一下 <a href="http://www.secret-note.one" target="_blank" rel="external">Secret Note</a> 的智能合约怎么实现。  </p>
<h2 id="Solidity-简介"><a href="#Solidity-简介" class="headerlink" title="Solidity 简介"></a>Solidity 简介</h2><blockquote>
<p>Solidity is a <strong>contract-oriented</strong>, high-level language for implementing smart contracts. It was influenced by C++, Python and JavaScript and is designed to target the Ethereum Virtual Machine (EVM).  </p>
<p>Solidity is <strong>statically typed, supports inheritance</strong>, libraries and complex user-defined types among other features.</p>
</blockquote>
<p>我高亮了几点我们在这次开发上需要用到的特性。  </p>
<p>学习过其它高级编程语言的开发可能对这些名词已经比较熟悉了。什么是 <strong>contract-oriented</strong> 啊？这好像是新玩意啊。其实你想想 JAVA 的 <strong>class-oriented</strong> 基本就能猜出七七八八了。</p>
<h2 id="合约编写"><a href="#合约编写" class="headerlink" title="合约编写"></a>合约编写</h2><p>早在 2012 年，我在自己的一篇关于 JavaScript 测试的文章提到一个理念：需要测试的，是双方之间协定的合约。这个合约就是交互的接口和行为。  </p>
<p>这个理念放到智能合约的编写上，我感觉更加直接了。所以，我们需要怎么编写智能合约，最重要的是想清楚，今后这个合约和外界交互的行为是什么。  </p>
<h3 id="与普通后端开发最大区别"><a href="#与普通后端开发最大区别" class="headerlink" title="与普通后端开发最大区别"></a>与普通后端开发最大区别</h3><p>智能合约的开发，不像普通后端的开发，有 bug 或者想加功能了，重新发一版就好了。  </p>
<p><strong>智能合约发布出去，就没法修改了。</strong>  </p>
<p>所以，把智能合约发布上公链前，一定要想清楚需求，做好测试。如果合约的链上行为，业务上真的很可能需要升级和修改，就应该提前想好策略，比如隔离接口和业务逻辑合约，使用类似 proxy 的设计等。这属于比较高级的开发需求，我也还不是了解的很清楚，这篇教程暂时不涉及这方面的内容。  </p>
<h3 id="Secret-Note-合约设计编写"><a href="#Secret-Note-合约设计编写" class="headerlink" title="Secret Note 合约设计编写"></a>Secret Note 合约设计编写</h3><p>对于 Secret Note 这个 Dapp 来说，它对外提供的行为，智能合约的接口应该有什么呢？  </p>
<ol>
<li>保存资料的索引  </li>
<li>获取资料的索引  </li>
</ol>
<p>最核心的功能，好像就这两个了，是吧？按照这个简单的设计，合约的代码大致是这样的。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.18;</div><div class="line"></div><div class="line">contract SecretNote &#123;</div><div class="line">  mapping(address =&gt; mapping(bytes32 =&gt; bytes32)) notes;</div><div class="line"></div><div class="line">  event SecretNoteUpdated(address indexed _sender, bytes32 indexed _noteKey, bool _success);</div><div class="line"></div><div class="line">  function SecretNote() public &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function () public payable &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * @dev For user to get their own secret note</div><div class="line">   * @param _noteKey The key identifier for particular note</div><div class="line">   */</div><div class="line">  function getNote(bytes32 _noteKey) public view returns (bytes32) &#123;</div><div class="line">      return notes[msg.sender][_noteKey];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * @dev For user to update their own secret note</div><div class="line">   * @param _noteKey The key identifier for particular note</div><div class="line">   * @param _content The note path hash</div><div class="line">   */</div><div class="line">  function setNote(bytes32 _noteKey, bytes32 _content) public payable &#123;</div><div class="line">      require(_noteKey != &quot;&quot;);</div><div class="line">      require(_content != &quot;&quot;);</div><div class="line"></div><div class="line">      notes[msg.sender][_noteKey] = _content;</div><div class="line"></div><div class="line">      SecretNoteUpdated(msg.sender, _noteKey, true);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p>代码文件最开始的一行，<code>pragma solidity ^0.4.18;</code>，标记了代码应该由什么版本的编译器编译，以避免在不同环境出现问题。  </p>
<p>智能合约，是通过 <strong>contract</strong> 关键字，和它的名字来定义的。合约的主体内容在最外层的 <code>{</code> and <code>}</code> 之间。  </p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>Solidity 作为一种高级的静态类型编程语言，当然也有自己支持的数据类型。在这个合约里面，我们用了三种：  </p>
<ul>
<li>address  </li>
</ul>
<p>这种类型可以保存一个 Ethereum 地址。比较特殊的是，它还有自己的成员属性和方法。最常见的是 <code>balance</code> 属性和 <code>transfer</code> 方法。  </p>
<ul>
<li>bytes32  </li>
</ul>
<p>Solidity 里面有分定长和变长的 byte 数组。  </p>
<p>定长的有 <code>bytes1</code>, <code>bytes2</code>, <code>bytes3</code>, …, <code>bytes32</code>. <code>byte</code> 是 bytes1 的别名。它们都有只读属性 <code>length</code>。  </p>
<p>变长的有 <code>bytes</code> 和 <code>string</code>。  </p>
<p><code>string</code> 是用来保存不定长 UTF-8 字符数据的。其它的都是 byte 数组。如果可以，尽量用定长的可以节省资源，减少 Gas 的使用等。  </p>
<ul>
<li>mapping  </li>
</ul>
<p>我们可以把 <code>mapping</code> 当作一个哈希表。这个哈希表的 key 几乎可以是任何类型，除了 <code>mapping</code>，变长 byte 数组，contract，enum 和 struct 结构体。哈希表的 value 就可以是任何类型的数据。  </p>
<p><code>mapping</code> 有个很特殊的地方就是它没有长度，你也无法检查一个 key 是否在它里面。因为它是虚拟地记录了每一个可能的 key，对应值为全 0 字节，也就是任何数据类型的默认值。  </p>
<p><code>mapping</code> 也无法遍历。所以，我们只能通过一种绕一些的方式来遍历它。可以参看官网的 <a href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol" target="_blank" rel="external">iterable mapping</a> 例子，或我的 Secret Note 源码。  </p>
<p><em>复杂的用户定义类型：在这篇文章就不介绍了，有兴趣的朋友可以直接看 Secret Note 的<a href="https://github.com/kenspirit/secret-note" target="_blank" rel="external">源码</a></em></p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>Solidity 有 4 种作用域修饰符。<code>public</code> 是合约的接口，可内部或通过外部消息调用。<code>external</code> 也是合约接口，但是不能内部调用。<code>internal</code> 只能内部，或者由继承的合约调用。<code>private</code> 只能在定义的合约内可调用，但是，它不代表区块链外不可见。  </p>
<p><code>view</code> 修饰符表示这个方法承诺不会修改合约的状态。<code>constant</code> 是它的别名。不过，虽然这么说，编译器是没有检查，或者强制限制这个方法不能改变合约状态的。  </p>
<p><code>payable</code> 修饰符用来标记某个方法可以同时接收发过来的 Ether。  </p>
<p><code>msg.sender</code> 特指调用此方法的 Ethereum 地址。<code>msg</code> 还有其它全局属性，详情可查看 Solidity 文档。  </p>
<p><code>require()</code> 就像其它语言的 <code>assert</code> 那样检查前置条件。不满足的话，会抛错。它通常用于检查外部输入等有效条件。另一个类似用法的 <code>assert</code> 则用户内部错误的检查。  </p>
<h4 id="Fallback-方法"><a href="#Fallback-方法" class="headerlink" title="Fallback 方法"></a>Fallback 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function () public payable &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个没有任何名字的是 <code>Fallback</code> 方法。一个合约只能存在一个。这个方法没有参数，也没有任何返回值。如果有人调用这个合约，但是指定的方法找不到，它会被触发。  </p>
<p>还有，当这个合约地址单纯地收到 Ether 的时候（比如他人转账到这个合约地址），这个方法也会被调用。所以，它必须被标记为 <code>payable</code>。不然，这个合约地址就没法通过普通的交易接收 Ether 了。  </p>
<p>要注意的是，如果这个方法里面有逻辑，一定要确保它的 Gas 消耗要小于 2300。  </p>
<h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>事件是 EVM 日志记录的使用方式。如果你在你开发的 Dapp 里监听了某一个事件，当这个时间被触发后，你在 Dapp 设的监听器就会收到通知。  </p>
<p>事件的数据是存储在交易日志里的。它们可以被检索，但是合约代码里面没法访问它们。  </p>
<p>每个事件最多有 3 个索引的（<code>indexed</code>）参数，我们可以根据这些参数进行过滤检索。非索引的参数存在记录日志的数据部分里，但是索引的参数是没有存的。你只能用某个值去查索引，但是没法罗列有哪些值。  </p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>上面两个合约方法是公开的，每个人都可以调用。那如果我想添加一些只有合约创建者才能调用的方法呢？假如，我想让只有创建者能查这个合约里面存了多少资料呢？  </p>
<p>我们可以利用继承和修饰符来实现上面的目的。  </p>
<p>首先，我们定义一个父合约 <code>Ownable</code>，这个合约在它的构造函数（constructor）里面把合约创建者保存到一个合约变量。然后，提供一个特殊的修饰符给子合约使用。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">contract Ownable &#123;</div><div class="line">    address owner;</div><div class="line"></div><div class="line">    function Ownable() public &#123;</div><div class="line">        owner = msg.sender;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    modifier onlyOwner() &#123;</div><div class="line">        require(owner == msg.sender);</div><div class="line">        _;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来的智能合约，作为子合约，稍微修改一下就可以了。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">contract SecretNote is Ownable &#123;</div><div class="line">  uint256 noteCount;</div><div class="line"></div><div class="line">  // 省略部分合约代码</div><div class="line"></div><div class="line">  function setNote(bytes32 _noteKey, bytes32 _content) public payable &#123;</div><div class="line">      require(_noteKey != &quot;&quot;);</div><div class="line">      require(_content != &quot;&quot;);</div><div class="line"></div><div class="line">      notes[msg.sender][_noteKey] = _content;</div><div class="line">      noteCount++;</div><div class="line"></div><div class="line">      SecretNoteUpdated(msg.sender, _noteKey, true);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function getTotalNoteCount() public view onlyOwner returns(uint256) &#123;</div><div class="line">      return noteCount;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们只需要吧 <code>onlyOwner</code> 这个修饰符添加到任何希望只有合约 owner 才能执行的 function 签名处，这个 function 就拥有检查调用者的能力了。加了 <code>onlyOwner</code> 的 function，其实就是把代码替换到 <code>_</code> 的位置。  </p>
<h2 id="安全方面的考量"><a href="#安全方面的考量" class="headerlink" title="安全方面的考量"></a>安全方面的考量</h2><p>因为合约一旦部署，就无法修改，而且很多的智能合约都和加密货币或者 token 挂钩。所以，如果一个智能合约的实现出现了安全漏洞，就有可能引起很大的问题。  </p>
<p>Solidity <a href="https://solidity.readthedocs.io/en/develop/security-considerations.html" target="_blank" rel="external">文档</a> 里有专门的一章写了一些推荐做法，大家应该至少看 <strong>Use the Checks-Effects-Interactions Pattern</strong> 和 <strong>Include a Fail-Safe Mode</strong> 两点。  </p>
<p>到这里为止，我们就把简化版 Secret Note 的智能合约写好了。下一篇我们来看看如何测试它。  </p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="http://www.thinkingincrowd.me/2018/02/25/dapp-development-1-what-should-be-in-blockchain/">Ethereum Dapp 开发 (1) - 什么应放在区块链上</a><br><a href="http://www.thinkingincrowd.me/2018/02/27/dapp-development-2-contract-development-in-solidity/">Ethereum Dapp 开发 (2) - 用 Solidity 开发智能合约</a><br><a href="http://www.thinkingincrowd.me/2018/03/05/dapp-development-3-contract-testing-remix-ide/">Ethereum Dapp 开发 (3) - 智能合约测试（Remix IDE）</a><br><a href="http://www.thinkingincrowd.me/2018/03/11/dapp-development-4-contract-testing-truffle/">Ethereum Dapp 开发 (4) - 智能合约测试（Truffle）</a><br><a href="http://www.thinkingincrowd.me/2018/03/17/dapp-development-5-UI-integration/">Ethereum Dapp 开发 (5) - 页面开发集成</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ethereum 的 Dapp 开发，保存数据在公链上，最基本的就是要实现一个智能合约。我们先来看一下 &lt;a href=&quot;http://www.secret-note.one&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Secret Note&lt;/a&gt; 的
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Ethereum" scheme="http://www.thinkingincrowd.me/tags/Ethereum/"/>
    
      <category term="Dapp" scheme="http://www.thinkingincrowd.me/tags/Dapp/"/>
    
      <category term="Smart Contract" scheme="http://www.thinkingincrowd.me/tags/Smart-Contract/"/>
    
  </entry>
  
</feed>
