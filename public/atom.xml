<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thinking in Crowd / 鹄思乱想</title>
  <subtitle>Swan flying in the immense sky</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.thinkingincrowd.me/"/>
  <updated>2018-05-09T12:20:58.921Z</updated>
  <id>http://www.thinkingincrowd.me/</id>
  
  <author>
    <name>鹄思乱想</name>
    <email>chengusky@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>习惯了别人的好是很危险的</title>
    <link href="http://www.thinkingincrowd.me/2018/05/09/addictive-to-others-goodness-is-dangerous/"/>
    <id>http://www.thinkingincrowd.me/2018/05/09/addictive-to-others-goodness-is-dangerous/</id>
    <published>2018-05-09T12:25:12.000Z</published>
    <updated>2018-05-09T12:20:58.921Z</updated>
    
    <content type="html"><![CDATA[<p>不知道大家有没有听过这么一个小故事，或者是谚语：  </p>
<p>一个乞丐，每天都会有固定的一位善心人士给予 Ta 一元钱的施舍。但是，某一天，或许是因为那位善心人士没有了散钱，或者有急事在身，匆匆路过而没有给予这个乞丐施舍。结果，那个乞丐起来破口大骂，说：“你怎么今天不给钱了？” 结果就是，这位善心人士再也不给予 Ta 更多的施舍。  </p>
<p>在看社会心理学的书时，还有另一个小故事。  </p>
<p>一群小朋友，喜欢在一个老人家外的空地玩耍。但是这个老人家喜欢安静，怕吵，他就出去和小朋友说：“你们的快乐和笑声真的给我带来很美好的时光。我人老了，没收入，所以只能打赏你们 1 元。不过现在我想休息一下，你们去别的地方玩好吗？” 小朋友们本来就很开心，没想到还能收到钱，说了声谢谢就离开了。往后，老人家都会打赏。但是，渐渐的减少了金额。后来某一天，老人家只给了 1 毛钱，那些小朋友生气地说：“我们给你带来那么多欢乐，你才给 1 毛钱那么少。我们以后再也不来这里玩了！” 所以，最后，老人家收获到了他想要的安静。  </p>
<p>通过这两个故事，我想说什么呢？依赖会：  </p>
<h2 id="丧失独立能力和感恩"><a href="#丧失独立能力和感恩" class="headerlink" title="丧失独立能力和感恩"></a>丧失独立能力和感恩</h2><p>独立，是成年人很重要的能力。依赖，就像是还在襁褓中的婴儿对母亲的“剥削”。婴儿子所以如此，是因为 Ta 能力不足。可是如果成年后还不能独立，成为了巨婴，问题是很严重的。没有一个人有义务一辈子对你好，即便 Ta 是你的父母，子女，或者伴侣，更别说素不相识的善心人士了。以前报纸时不时都有报道说一些学生收到捐助，出来工作后也不知道要报答一下，甚至一些感恩的心都没有。更别说拿了助学贷款不还的了。  </p>
<p>当然，有一些人无法长大，其实是父母的问题，他们不想子女离开，出各种手段要留他们在身边。很多人对待伴侣也一样。  </p>
<p>在亲密关系里面，依靠是很重要的。恰当的依靠，可以增加相互之间的安全感，放下对外部世界的武装，真正做自己。我以前对这两个概念区分的并不好，所以亲密关系维系的不好。但是，依靠和依赖不一样。<strong>依靠是互相支撑，依赖是你完全不使劲，没想过给对方支持，只向对方索取</strong>。  </p>
<h2 id="迷失自己，忘却了本心"><a href="#迷失自己，忘却了本心" class="headerlink" title="迷失自己，忘却了本心"></a>迷失自己，忘却了本心</h2><p>依赖，有时并不是你一开始就故意想这么做的。生活中的美好，可能在你意料不到的时候到来，然后由于对方的善和爱，你持续收获到了关注和温暖。渐渐地，你习惯了这种美好，把它当作理所当然。就像是第二个故事的小朋友那样，本来是为了自己的欢乐而玩耍，最后因为没有钱的奖励而丧失了原来的本心。  </p>
<h2 id="好，是那么的容易上瘾"><a href="#好，是那么的容易上瘾" class="headerlink" title="好，是那么的容易上瘾"></a>好，是那么的容易上瘾</h2><p>不像是痛苦，人类通常都怕避之不及。对甜食，爱，等美好的事物，人是很容易上瘾的。这应该是人的本能。但这种瘾来的悄无声息，一开始你并不察觉，等到失去的时候，才发现无法失去。  </p>
<p>我自己就经历过两个事情。  </p>
<p>以前，在某些慈善机构爆出丑闻后，我觉得自己应该直接捐款给某个具体的人，而不是机构，这样可以减少中间的腐败浪费环节。刚好我在某份报纸上看到有个母亲，患有恶性疾病，还有一个小孩要照顾，我连续四五个月给他们家汇款给予捐助。后来，忙得不记得汇款了，他主动发信息过来询问，要钱。我顿时感觉到了恶心，也停止了对他的捐助。  </p>
<p>另一件事情是，我现在在写公众号，本心的目的就是提高自己的思考和写作能力。虽然我也会被自恋影响，希望能得到更多的关注，但确实没幻想过能有很多人看，能赚多少打赏。不过，你可能不会相信，有一位朋友，在我每次发了一篇文章后，都会给我打赏 10 元。这真的不是一个小数目。开头每次收到打赏，我都是及时给予回复和感谢，同时心里也是充满了内疚。因为，我知道自己的写并没有那么好。我当然也没有为了这打赏，每天产出垃圾。但是，慢慢地，我也没有每次回复和表达感谢了。除了因为觉得这些口头的感谢太微不足道外，可能也有一点点习惯了。内疚的感觉并没有那么强烈了，但是我还是会在他需要的时候，尽量提供帮忙。当我察觉到可能有一丝丝习惯他的打赏时，也是他停止打赏的那一刻。我察觉到心里有那么一丝失落。  </p>
<p>这份失落，是习惯的断裂造成的。对份失落，每个人的解读都是不一样的。倾向于内归因的人，可能会想，是我不够好了吗？我就在想，是我写的没以前那么好了吗，还是我的观点和他不一致？如果处理不好内归因，可能就会打击自己丧失信心。或者像写作者，就会去变得迎合 Ta 的读者，而丧失了自我。倾向于外归因的人，可能想的就是，别人变坏了，也就可能会攻击对方。当攻击对方的时候，也很可能是忘却了本心的时候。  </p>
<p>希望我们能有人依靠的同时，不要依赖他人。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道大家有没有听过这么一个小故事，或者是谚语：  &lt;/p&gt;
&lt;p&gt;一个乞丐，每天都会有固定的一位善心人士给予 Ta 一元钱的施舍。但是，某一天，或许是因为那位善心人士没有了散钱，或者有急事在身，匆匆路过而没有给予这个乞丐施舍。结果，那个乞丐起来破口大骂，说：“你怎么今天不
    
    </summary>
    
      <category term="Psychology" scheme="http://www.thinkingincrowd.me/categories/Psychology/"/>
    
    
      <category term="Dependency" scheme="http://www.thinkingincrowd.me/tags/Dependency/"/>
    
  </entry>
  
  <entry>
    <title>区块链到底有没有价值</title>
    <link href="http://www.thinkingincrowd.me/2018/05/08/is-blockchain-valuable/"/>
    <id>http://www.thinkingincrowd.me/2018/05/08/is-blockchain-valuable/</id>
    <published>2018-05-08T00:00:16.000Z</published>
    <updated>2018-05-09T12:21:39.742Z</updated>
    
    <content type="html"><![CDATA[<p>区块链炒币和 ICO 热潮最近稍微降温下来，比特币从最高近 2W 美金，跌至最低 6K 多，现在再回升到 9K 左右。作为一个“盲目”认定比特币价值，但是又不敢“All In”投资/炒币的人，我并没有赚到很多钱，但是也没有损失。因为没有怎么卖出，所以账面价值看上去，资产还是增值不少的。  </p>
<p>单单谈论区块链技术，我也是认为其有特定的价值和应用场景的。但是，最近我在问自己，当前的各种应用场景，公链，它们真的有存在的价值吗？他们解决的是什么问题？  </p>
<h2 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h2><p>听起来，这是美好的，所有的东西都能从源头追踪定位，减少假货。但是，越是经过复杂加工，处理合成各种原材料的商品，我觉得区块链溯源就越值得怀疑。  </p>
<p>你说，一头猪，假设它的资料上了区块链，标明产地，编号。那，我怎么保证宰的时候，每块从它身上切下来的猪肉，还继续带上原来的“身份”？靠屠宰厂的自动化封闭流水线？如何防止调包？即便屠宰的时候没问题，物流运送的阶段呢？真货的保证，都需要流程中各方严格管控，防止造假的可能。可是，这真的需要区块链吗？这需要去中心化吗？显然是中心化，严格的管控，统一的流程更好啊。就单纯把编号上个链，和以前的防伪码有什么不一样？  </p>
<p>实物，我觉得硬要和区块链扯上关系，是有点牵强的。相反，虚拟货品（币，数字商品，游戏道具等）我觉得是可以通过区块链的物权和钱的同时转移（比如通过智能合约）来实现的，也是合理的。  </p>
<h2 id="用户数据出售"><a href="#用户数据出售" class="headerlink" title="用户数据出售"></a>用户数据出售</h2><p>像“网易星球”，淘宝的“麻吉宝” 等都是一样的。  </p>
<p>这些平台的出发点都是：“用户能更好的利用自己产生的数据（信用，浏览轨迹，文章，评论点赞，购物娱乐等行为），转化成资产和金钱”。但是，如果当前中心化的那些公司，真的愿意让用户售卖这些数据，有问题吗？如果它能定期给份报告给用户，说我们使用它时产生了多少数据，然后给回多少钱给我们，我们会在意它是区块链吗？其实是没有的。可能有人会反驳说，如果没有区块链，很容易造假。可是，这些产品，现在后面用没用链我们都不知道。况且，现在只有它们自己在维护，谁说他们不能造假？它们允许我们同步节点数据吗？我们能通过什么方式查询链上的数据吗？如果一家公司只是使用普通数据库，但是能开源代码，开放数据库的读权限，还能回馈奖励给我们，那有什么不可信的？  </p>
<p>最重要的问题，只是现在提供服务的公司没有意愿和必要，把我们产生的数据的再生产价值反馈给我们。当前标榜了区块链的公司或者产品，有价值只是因为它们能发个币在交易所，还可以卖钱。想象一下，如果 Facebook, QQ, 微信等社交巨头，内部推出积分制度，而且可以兑换成金钱，那些标榜区块链的平台还有竞争力吗？代表了价值的巨量内容当前都在巨头手里，当政策开放了，允许虚拟积分和法币互换，或者巨头被倒逼到一定程度，觉得内容价值有持续流出的趋势，它们可以马上补贴和复制模式（说不定现在的网易星球和其它巨头背后就在布局准备）。老巨头推动政策的发展，或者举政策大旗来封杀那些区块链产品都是很有可能的。  </p>
<h2 id="公链"><a href="#公链" class="headerlink" title="公链"></a>公链</h2><p>如果说前段时间 ICO 火热的是各种区块链应用，那最近遭争抢和吹捧的应该就是公链了，如出名的 EOS。公链的价值到底在哪？  </p>
<h3 id="可供公开查询的区块链账本"><a href="#可供公开查询的区块链账本" class="headerlink" title="可供公开查询的区块链账本"></a>可供公开查询的区块链账本</h3><p>正如 BTC，Ethereum 等公链，所有的数据都公开。理论上说，只有搭建在公链的 2C 应用，才是可信的面向个人的区块链应用场景。不然，你说你自己用了区块链，保证公开透明，谁相信？但是，真的有那么多应用，适合把数据公开，应该部署在公链上吗？  </p>
<h3 id="云平台"><a href="#云平台" class="headerlink" title="云平台"></a>云平台</h3><p>公链其实应当和亚马逊 AWS，Azure，腾讯云，阿里云等一样，是一个为开发者部署应用提供服务的云平台。只是，公链提供的是分布式的数据库（区块链）。  </p>
<p>我就拿云平台的老大 AWS 和当红公链 EOS 来比较一下吧。  </p>
<p>一般来说，云平台的收入，理应来自开发者应用使用云服务的费用。它的收益，就是所有开发者购买云服务的费用，减去云平台的所有运营成本。  </p>
<p>Amazon 当前的股价大概是 1580 USD，总股本是 4.85亿。根据 Amazon 2017 的财报，AWS 的营收大概为 43亿。假设它的股价全部归功于 AWS（ Amazon 的北美和国际商城总收益为负 2亿），AWS 的总体量约为 5亿 x 1500 USD = 7500亿 USD。  </p>
<p>EOS 的总发行量为 10亿，价格为 18 USD 左右，那它的总价值是 180亿 USD。  </p>
<p>到这里，你可能会想，EOS 岂不是还能升值很多倍？激动得要赶紧 All In 了是吧？别着急。  </p>
<p>首先，AWS 要达到这么多的收益，它的销售总额是 174亿，支出为 131亿。要达到这么多的销售额，需要有多少在使用着 AWS 服务的公司在支撑着，它们的营收又有多少？以后基于 EOS 之上搭建的应用，又能有多少，体量能有 AWS 的 1/40 吗？  </p>
<p>再说，EOS Token 的价值，还不能用和 Amazon 一样的股票价值估算方式。  </p>
<p>首先，EOS Token 每年会增发不超过 5%（这个值其实比一些国家的通胀要厉害了）。那这些 Token 会全部流通出去，造成贬值吗？  </p>
<p>在 EOS 的世界，应用开发者，是需要持有一定量的 EOS Token，才能给它们的服务维持一定量的存储，CPU，带宽资源。也就是说，假定所有人的持仓相对稳定的情况下，要保持服务质量不变，你的 Token 不能卖。假如，你提供的应用服务发展火爆，你就需要扩展（如日益增加的存储成本），也就是要买入和持有越来越多的 EOS Token。  </p>
<p>而那些争抢拉票的区块 producer 节点，要维持节点的地位，也要保持一定的 Token 在手，才能拥有足够的投票权力。而且，要成为节点，按照 EOS 团队公布的硬件门槛，最少需要达到亚马逊 AWS EC2主机x1.32xlarge 型，128核处理器，2TB内存，2x1920GB SSD，25Gb带宽。一台服务器的成本，一年就需要高达约 76 万人民币。按现在一个 EOS 100元人民币算，一年成本约为 7600 个 EOS。  </p>
<p>增发的 Token 当中，其中有 1% 是给区块 producer 节点的。那 Token 的价值，和节点的运营成本，到底哪个高一些呢？10 亿 EOS 的 1% 为 1 千万，如果平均分配给 121 个区块 producer 节点，那每个节点约拿到 8 万个。如果需要一半来维持服务质量和地位，剩下一半变现。假如要 2万个来覆盖成本，那获益还是很可观的。但是，如果 EOS 生态如果没产生足够的价值，变现的量可能不小，贬值的风险也是很高的。  </p>
<p>EOS 的模型实在是很复杂，我觉得真的可以算是一个有趣的社会实验。如果 EOS 生态有价值，能良性发展，就像一家好的公司一样，等模式稳定后投资，是不错的。但是，如果现在盲目 All In，风险也不小。  </p>
<h3 id="分叉，ICO，Airdrop"><a href="#分叉，ICO，Airdrop" class="headerlink" title="分叉，ICO，Airdrop"></a>分叉，ICO，Airdrop</h3><p>BTC 分了无数个叉，好一些又上了交易所，“随便”定了一个价，基本就凭空多了一个市值巨大的“数字货币”。  </p>
<p>在数字货币火热的时候，在 Ethereum 发个 Token，ICO 一下，然后上交易所，就可以凭空吸引无数的资金进场。  </p>
<p>ETH 的价格，在某种程度上来说，由于它在 ICO，和 Airdrop 中作为基本参与凭证的需要，被争抢。物以稀为贵，它的价格也在此期间大涨。但是它的技术面有改变吗？能支持的最大交易数有提高吗？智能合约支持的功能有增多吗？似乎都没有很大变化。它的上涨，基本是因为经济学上的供求关系的变化引起的。所以，ICO 降温后，又遇上数字货币遭打压，ETH 就跌了不少。  </p>
<p>很多人（包括我），拿 EOS 对标 ETH，觉得它具备那么多先进的功能，那么快的交易速度，肯定会涨到 ETH 的价格，然后替代 ETH。可是这个逻辑真的成立吗？即便它能替代 ETH，但 ETH 的价格，有多少提现的是公链应有的价值，哪些只是 ICO 的需求泡沫？美国 SEC 当前也要查 ETH 到底是否属于证券，加以监管了。  </p>
<h2 id="数字货币"><a href="#数字货币" class="headerlink" title="数字货币"></a>数字货币</h2><p>为什么公链分个叉出来，就可以为新的分叉币随便定价了？这些真的是数字货币，有货币的价值吗？  </p>
<p>货币，本质来说，是一种在某个经济体中，被人们承认的交易媒介。无论是古代的贝壳，黄金，还是纸币，甚至是监狱里的香烟，都一样。  </p>
<p>能被人们承认，要么它有实质价值，要么它有中心化的机构或人背书。而现在的“数字货币”，价值是怎么确定的呢？我觉得，它们确实是为了信仰而充值的。  </p>
<p>到底是什么信仰呢？拿 BTC 来说，它由算法背书，无法篡改，永不增发，有一定的匿名性。所以，一开始它流通于灰色领域，被某些追随特定经济理论的人士追捧。但这些信仰值多少钱，为什么能从一美分不到，变成现在的一万美元？这些信仰能被追随多久？除了信仰外，我也曾觉得它是数字时代的黄金，甚至比它更优。但是，BTC 却需要依赖矿工才能维持运转，那等到所有的币都挖完了，单单收交易费能覆盖矿机运作的成本吗？  </p>
<p>上面似乎我都在一直贬低火热的，和曾经自己深信的东西，但是这并不代表我对它们都失去信心。只是稍微更冷静地思考它们的可能，即便这样做我没法像那些站在风口鼓吹的人那样赚那么多钱。我依然觉得区块链技术有它适用的场景，去中心化的数字货币也是未来的一部分。我觉得它绝不是荷兰的郁金香泡沫，但它的真正价值，会到达什么高度，给我们带来什么改变呢？  </p>
<p>附赠两篇我很喜欢的公众号最近关于区块链的文章吧，有弹有赞，多方面了解认识更有助于我们全面思考。  </p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&amp;mid=2649867685&amp;idx=1&amp;sn=3ce18dc2f2d872bf56ea8238ac440188&amp;chksm=f1075fc8c670d6de1dde354f7ce9c8fd125092591c1aa50e4b3618a5b4b2a332dd52dc4b8ec6&amp;scene=21#wechat_redirect" target="_blank" rel="external">竞价排名永不倒</a>  </p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=2649827999&amp;idx=1&amp;sn=5374d71f1baa677ffe6805d36fac2af0&amp;chksm=8704a883b07321953c6e713bb86a08ca546a18f661522bbbf89a8832fbdb897f82babdc7a11e&amp;scene=21#wechat_redirect" target="_blank" rel="external">欢迎来到区块链的世界</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链炒币和 ICO 热潮最近稍微降温下来，比特币从最高近 2W 美金，跌至最低 6K 多，现在再回升到 9K 左右。作为一个“盲目”认定比特币价值，但是又不敢“All In”投资/炒币的人，我并没有赚到很多钱，但是也没有损失。因为没有怎么卖出，所以账面价值看上去，资产还是
    
    </summary>
    
      <category term="Think" scheme="http://www.thinkingincrowd.me/categories/Think/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Bitcoin" scheme="http://www.thinkingincrowd.me/tags/Bitcoin/"/>
    
      <category term="EOS" scheme="http://www.thinkingincrowd.me/tags/EOS/"/>
    
  </entry>
  
  <entry>
    <title>很多所谓的“区块链”项目，在比特币面前就是渣</title>
    <link href="http://www.thinkingincrowd.me/2018/03/30/many-blockchain-products-are-trash-compared-to-bitcoin/"/>
    <id>http://www.thinkingincrowd.me/2018/03/30/many-blockchain-products-are-trash-compared-to-bitcoin/</id>
    <published>2018-03-30T15:23:51.000Z</published>
    <updated>2018-05-09T12:15:18.785Z</updated>
    
    <content type="html"><![CDATA[<p>说来惭愧，从自己知道比特币，买比特币到现在也有三四年了吧，我也是最近才认真地看完了它的白皮书。可能也是因为这个原因吧，虽然我相信它有价值，但是也不敢说自己是“坚信”。所以，这也是我并不敢花太多钱去买它的原因，即便当时比特币才 3000 元人民币左右。当时就想着万一它成了，就留给儿子吧。  </p>
<p>比特币的白皮书 （<a href="https://bitcoin.org/bitcoin.pdf）" target="_blank" rel="external">https://bitcoin.org/bitcoin.pdf）</a> 其实才短短 9 页，最后一页还是参考文章列表。可在这短短的 8 页里，中本聪却能非常清晰明白地说明，比特币是用来解决什么问题，里面使用的每个技术是为了解决其中哪部分问题，为什么。整个论文的论述是非常自洽的。最重要的是，他不是从技术出发，而是从业务问题出发，再论证每个使用的技术如何解决局部问题，最终实现了目标。  </p>
<p>我尝试来解释一下这个自洽的论证是如何做的。</p>
<p>比特币是什么？  </p>
<blockquote>
<p>无须依赖中央金融机构，点对点的电子货币交易系统。  </p>
</blockquote>
<ul>
<li><p>中央金融机构有什么问题？  </p>
<p>跨国支付，尤其是小额支付，成本，等待时间太高，覆盖范围也受影响。支付可行性，灵活性受限于此中央金融机构。  </p>
</li>
<li><p>那为什么我们还需要中央金融机构？  </p>
<p>不考虑假钞的前提下，面对面的金钱交易才能解决交易双方的信任问题。但是，在线和跨地区的电子交易，必须交由可信的第三方中央金融机构监督，才能保证卖方确实收到买方的钱。因为中央机构可以确保买方承诺支付的钱，不会也不能同时给另一个人。这也就是所谓的杜绝“双花（double spending）”问题。  </p>
</li>
<li><p>如何可以不通过中央金融机构，也能防止“双花”问题呢？  </p>
<p>要防止“双花”，就必须知道支付方的所有出入账记录。所以，如果不通过中央金融机构监管，那就是每个人的每一笔交易记录，都必须广播给其它所有人知道，由此可以让大家都一致认定每笔交易，和它们的先后顺序。账本的公开，也就是让每个人都可以承担记账的功能，通过<strong>分布式</strong>来代替集中式。  </p>
</li>
<li><p>谁做的交易统计才可信？  </p>
<p>由于每笔交易都广播给全世界知道，但每个人接收到的广播信息，还是可能会有偏差的，因为分布式的网络是不稳定的，每个人也不确定是否确实收到了所有的广播。或者，中间有人作假，甚至联合作假怎么办？这里就需要引入一种<strong>共识机制</strong>，也就是记账的人要遵循的统一的规则，来确保什么样的记账才算数。  </p>
</li>
<li><p>共识机制是什么？  </p>
<p>比特币系统选择的是<strong>工作量证明（POW）</strong>。每一个记账方，都需要按特定的算法一直做数学运算，直到算出来的值，是符合约定的某种特定规范，它才可以把之前一直接收到的有效的交易数据，统计打包（生成一个 block），然后向外公布。一但某个记账方，收到了其它记账方的交易统计（block），它就要停止手上的计算，验证这个统计的正确性，并加入到账本（blockchain）最末尾。这里有个很特别的地方还包括，每一个 block 会有自己的 Hash 值（计算机术语，可以理解为唯一的指纹），而且它还和上一个 block 的 Hash 有关。  </p>
</li>
<li><p>为什么这种机制保证安全和公平？  </p>
<p>首先，这种数学运算有统一的规则，需要拿上一个 block 里定的某个随机数来做下一次的计算。这里既有透明的规则，又有随机成分，没有人可以提前算出一批结果，参与的人只需要贡献他们计算机的算力，相对公平。  </p>
</li>
<li><p>有人垄断算力怎么办？  </p>
<p>如果有记账方很有钱，它占有整个网络很多的算力，是不是就能比其它记账方，算的快呢？这个算法还有一个特点，就是如果发现 block 生成的速度变快，还能自动调节难度，让计算更复杂，减慢 block 生成的速度，大概维持在 10 分钟左右一个。  </p>
</li>
<li><p>速度慢还有什么好处？  </p>
<p>前面提到，分布式的交易记账，不同的记账方，是有可能有偏差的。导致的结果是，你接收到的 block 信息，也有可能和其它人不一致。也就是一条交易统计链，从全世界角度来看，可能会有几条不同的分支。那么，最终是以哪条为准呢？链最长的那条。所以，每个记账方，除了记录自己正在记账的链，还要记录公布出来的其它链的信息，一但发现某条链越来越长，它就应该切换到最长的链去接着统计。block 生成速度慢，加上随机性的存在，就不至于让算力垄断方，那么容易生成最长的链。要一直维持绝对优势，需要比别人超出很多算力。  </p>
</li>
<li><p>真的值得作假吗？  </p>
<p>假如真的有人具有垄断性的优势，真的值得作假吗？首先，交易数据的结构设计，使得它只可能修改自己的交易记录，把自己的钱偷回来，它是没法偷别人的钱的。而且，要修改记录，由于前面提到的，每个 block 都是有各自的 Hash，还包含了上一个 block 的 Hash。也就是说，它修改了某一个 block 的数据，就要把后面所有的 block 都改掉，<strong>篡改记录的成本是很高的</strong>。最后，作为一个诚实的记账者，只要能争取算出正确的值，生成 block，就能获得一定量的比特币奖励。所以，如果某个记账方，或者黑客，真的拥有垄断性的算力，那它是用来争取获得奖励划算些，还是尝试偷回自己那么点币划算些呢？  </p>
</li>
</ul>
<p>以上的每一个点，都环环相扣。每个技术的使用，都有特定的考量。所以，为什么说比特币是区块链上的第一个有真正价值的应用，真不是说说而已。  </p>
<p>反观，现在一些项目介绍和白皮书，堆砌了各种名词技术，吹的天花乱坠，只是说能干嘛，但是为什么需要用到这些技术，怎么使用它来解决某个问题都没说清楚。只是泛泛地说它的共识算法要更先进，吞吐量高，不耗电等，更别说有没有解释清楚这个项目为什么非得用区块链来解决了。  </p>
<p>还有，很多公司做的所谓“区块链”项目，我感觉都是营销噱头，包括网易星球，和这两天刷朋友圈的淘宝弄的麻吉宝等。这些项目，和普通的导流，积分系统有啥区别？为什么要用区块链？用户怎么知道你用了区块链没？除了项目方自己外，谁还 host 了节点保证记录没那么容易被篡改？一些公司动不动就说自己用区块链技术，给用户带来信任，因为它不可篡改。可是它们根本不知道在什么情况下才不可篡改。  </p>
<p>比特币虽然有缺陷，但是更多的项目还都是渣。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说来惭愧，从自己知道比特币，买比特币到现在也有三四年了吧，我也是最近才认真地看完了它的白皮书。可能也是因为这个原因吧，虽然我相信它有价值，但是也不敢说自己是“坚信”。所以，这也是我并不敢花太多钱去买它的原因，即便当时比特币才 3000 元人民币左右。当时就想着万一它成了，就
    
    </summary>
    
      <category term="Think" scheme="http://www.thinkingincrowd.me/categories/Think/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Bitcoin" scheme="http://www.thinkingincrowd.me/tags/Bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>被愤怒之火烧毁的，不仅有敌人，还可能有自己</title>
    <link href="http://www.thinkingincrowd.me/2018/03/21/anger-begets-greater-anger/"/>
    <id>http://www.thinkingincrowd.me/2018/03/21/anger-begets-greater-anger/</id>
    <published>2018-03-21T00:06:13.000Z</published>
    <updated>2018-04-10T08:46:23.605Z</updated>
    
    <content type="html"><![CDATA[<p>很早就听到许多人都在推荐《三块广告牌》（3 Billboards）这个电影，它的主题，和保姆纵火案，江歌案，为母报仇的张扣扣事件类似，都和至亲失去有关。  </p>
<p>Momself 的<a href="https://mp.weixin.qq.com/s/VCOmyr5JDKFOQdkEcrT86g" target="_blank" rel="external">文章</a>说，对于一个愤怒的，失去至亲的人来说，还有另一种当今时代的非政治正确的选择：<strong>不，绝不放下。</strong>。  </p>
<p>我觉得，很难说什么是政治正确和不正确，只是你想用什么态度来和失去的至亲，以及这个世界相处。  </p>
<p>《三块广告牌》里面的主角，是一位失去了女儿的母亲，在一条不太有人出入小镇的路边，竖立了三块广告牌：「RAPED WHILE DYING」，「AND STILL NO ARRESTS?」，「HOW COME, CHIEF WILLOUGHBY」，意思是「垂死时还被强奸」，「怎么还没逮捕？」，「威洛比警长，怎么一回事」。  </p>
<p>电影开始没多久，我们就感受到了那位母亲的愤怒，和绝不放下的态度。  </p>
<p>但是，这仅仅是因为 Momself 里面的文章所说，<strong>她想让全世界看到她的愤怒</strong>吗？是“<strong>她不放弃，正是为了她自己。因为一旦放弃，她就会跌进失去女儿痛苦的万丈深渊里。复仇，是她巨大而唯一的力量。</strong>”吗？  </p>
<p>我觉得不仅仅是这样。而且那不是真正的原因。下文大量剧透，建议你还是先看了电影，再回头来看看我说的对不对。  </p>
<h2 id="外因"><a href="#外因" class="headerlink" title="外因"></a>外因</h2><p>挂广告牌的黑人工人和一名警察之间的唇枪舌战；女主的黑人朋友知道她竖起广告牌后支持她说：“加油，整死那帮警察”。广告商老板（白人），在面对警察来质问：“你真的想和警察局过不去吗？”，回答到：“我想是的”。  </p>
<p>电影中相当多的画面，都体现了普通民众，和警察之间的紧张情绪，甚至是对立，互不信任的状态。  </p>
<p>所以，<strong>主角不妥协的态度，我觉得一方面的原因，还因为她对警察不信任，认为他们不作为，没有尽力调查。</strong><br>电视台采访女主角的时候，她说：“威洛比警长，有着不可推卸的责任”。  </p>
<p>可是，当警长亲自和她解释，说全国没任何一个人的 DNA 能匹配上，也没有任何目击证人，他真的没有没办法的时候，女主觉得甚至可以侵犯民权法，让全镇，全国的男士去验 DNA。当警长和她坦白自己有癌症后，她还说：“等你死了后，广告牌上话的不就没用了吗？”  </p>
<p>显然，她觉得，自己可以用任何手段，甚至侵犯任何人合法的隐私权益，来为自己服务。所有的外人，都有责任协助她。  </p>
<p>为什么她这么迫切寻找外因，把责任归咎于他人呢？  </p>
<h2 id="内因"><a href="#内因" class="headerlink" title="内因"></a>内因</h2><p>剧中有一幕，她经过自己女儿房间，回想起当天女儿向她借车的情景。她们大吵了一架，她不借车给女儿，让她走路去，还附和着斗气说，希望女儿半路被强奸。  </p>
<p>还有，她前任丈夫回来劝她别登广告。临走前告诉她：“女儿死前一周，问能不能搬去和他住，说忍受不了她妈妈和哥哥，不想再和他们争吵了。“ 他还自责地说：“如果当时不是他劝说女儿留在这，女儿可能就不会死了。” 女主得知后非常痛苦，不愿意相信，但向儿子求证，儿子却有话不说。  </p>
<p>这，显然就是内因。<strong>她不愿意面对，不愿意接受，她女儿的死，和她也有“关系”。</strong></p>
<p>我这里说有“关系”，并不是指她的气话，和不借车造成女儿的遇害。很多人在至亲出事后，都会归咎于自己，过度自责，这也不是健康的心理行为。但是，如果因为无法承受心中的悲痛，逃避自身的情感，而转化为对外的愤怒和指责，那带来的伤害也会很大。  </p>
<p>武志红老师说过，一个人如果无法独自承受和化解一些黑色的死亡能量，同时也没有一段良好的关系帮助 Ta，这份死亡能量要么向内攻击自己，要么就会向外攻击他人。  </p>
<p>过度自责就是攻击自己，迁怒就是攻击他人。  </p>
<h2 id="迁怒之罪"><a href="#迁怒之罪" class="headerlink" title="迁怒之罪"></a>迁怒之罪</h2><blockquote>
<p>Anger begets greater anger</p>
</blockquote>
<p>这句确实是本片的中心思想。Momself 的文章那里翻译为：“压抑之怒将催生出更大的愤怒”。但我觉的并不是，因为不仅仅压抑会催生，而是<strong>愤怒直接催生更大的愤怒</strong>。  </p>
<p>整个电影，展示了大量的迁怒，报复等行为，如：  </p>
<ul>
<li>女主咒骂前任丈夫找的年轻女人，是闻起来像屎一样的野鸡。  </li>
<li>支持警长的牙医，不怎么认真检查女主的牙，就说要拔了。  </li>
<li>自称警长好朋友的不明身份之人，到女主上班的店铺生事。  </li>
<li>一名警察为了死去的警长，把提供广告服务给女主的老板，从二楼丢了下去。  </li>
</ul>
<p>这些行为，并不是那些人压抑自己的愤怒而导致，而是肆意表达，和发泄他们的愤怒。每个人都认定心中的正义，甚至或多或少利用职能之便，行报复之事。最终，导致自己的愤怒不断升级，或者他人更严重的报复。  </p>
<p>电影里面最突出的两个人物，就是女主和警长身边的那位警察。他们都自认为手握真理，习惯于按自己的逻辑和做事方式来对待他人的。认定了谁是过错方，就用自己的方式去惩罚他。所以，他们俩，也因为警长的事情，势不两立。  </p>
<p><strong>迁怒实在是太容易，也是很自然的事情。人总是本能的回避黑色的死亡能量</strong>。想想你是否曾经带着工作的情绪，回家后发泄到妻子或者孩子身上。  </p>
<h2 id="重要的是看到"><a href="#重要的是看到" class="headerlink" title="重要的是看到"></a>重要的是看到</h2><p>电影后期，女主和那位警察竟然能相互理解了。为什么会有这样的转变呢？  </p>
<p>那位警察，一直没看到自己压抑的愤怒，是如何通过其它方式释放出来的。但是，当他看了警长留给他的信后，他的内心，被看到；他的愤怒和黑色死亡能量被接纳了。  </p>
<blockquote>
<p>我觉得你太易怒了，这都归因于你父亲的去世，你不得不全身心去照顾你妈妈。可是，只要你把那么多的仇恨都深深埋入心底，你都无法成为你想成为的那样一名侦探。<br>…<br>成为一名真正的侦探的要诀是，爱。只有通过爱，才能内心获得平衡。通过内心的平衡，才能拥有思想，有思想才能侦查到一些东西。<br>…<br>没人觉得你是同性恋有什么问题。如果有人觉得是问题，你就以恐同罪逮捕他们。  </p>
</blockquote>
<p>而女主，我觉得是她一次次的犯事后，警察因为没有真正的证据，而不能逮捕她。她身为罪犯，却能逃脱刑责，理解到了警察必须依据证据办事的态度和方式。那个为了袒护她而说谎的侏儒，在约会当晚愤怒地爆发。她终于看到，自己的黑色死能量是如何伤害到其他人，也慢慢意识到，自己开始成为自己原来厌恶的人。  </p>
<p>更重要的是，她火烧警察局当晚，那个警察拼死保护一份案卷（可能是她女儿的）。他还积极查案，为了收集证据而被暴打。这些行为都深深地震惊了她。当关系中的另一方，接纳了她的死能量，还以生能量的时候。她的愤怒才得以吸纳转化。  </p>
<p>如 Momself 文章所说，<strong>愤怒，需要被看到。但是，我觉得更重要的是要自己真正看到，并合理表达，而不是故意发泄，让别人看到</strong>。  </p>
<p>电影里，有两个理想的处理愤怒的模范。警长老婆，在丈夫自杀当天，给女主送丈夫的遗信，愤怒地表达对女主的不满，和释放自己的情绪。那个广告商老板，得知同病房的烧重伤病友，是扔他下楼的那个警察，被气的发抖和乱吼后，还是给他递上橙汁，准备好吸管。  </p>
<p>现实生活中，保姆纵火案的林爸爸，我觉得也把愤怒处理的非常好。我自问可能没那么强大的自我容器来处理这种愤怒和悲伤。  </p>
<p>电影最后，女主和那位警察，打算联手去抓那位他们认定的强奸犯。开车途中，女主问：“你确定要去吗？”。警察回答到：“杀了那个人？不太确定。你呢？” “不太确定。”</p>
<p>或许我们没法把愤怒处理的很好，但也许可以像电影两个主角最后那样，多问问自己，多尝试去体会自己的愤怒，而不是带着愤怒行事。<strong>至少，我们可以事后向被我们伤害的人，真诚地说声对不起。</strong>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早就听到许多人都在推荐《三块广告牌》（3 Billboards）这个电影，它的主题，和保姆纵火案，江歌案，为母报仇的张扣扣事件类似，都和至亲失去有关。  &lt;/p&gt;
&lt;p&gt;Momself 的&lt;a href=&quot;https://mp.weixin.qq.com/s/VCOmyr
    
    </summary>
    
      <category term="Psychology" scheme="http://www.thinkingincrowd.me/categories/Psychology/"/>
    
    
      <category term="Anger" scheme="http://www.thinkingincrowd.me/tags/Anger/"/>
    
  </entry>
  
  <entry>
    <title>Ethereum Dapp 开发 (5) - 页面开发集成</title>
    <link href="http://www.thinkingincrowd.me/2018/03/17/dapp-development-5-UI-integration/"/>
    <id>http://www.thinkingincrowd.me/2018/03/17/dapp-development-5-UI-integration/</id>
    <published>2018-03-17T05:40:40.000Z</published>
    <updated>2018-04-10T08:46:23.603Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要讲述 Dapp 前端页面，怎么和 Ethereum 帐号网络集成。不过，涉及的前端开发和代码，不会包括在覆盖范围内。因为前端开发框架太多（Vuejs, React, AngularJS，JQuery 等），使用什么都可以，所以本文仅解释合约相关的代码。本文代码以 Vuejs 代码为样例，也在 Github 上。  </p>
<p>本教程，也就是简化版的 Secret Note 页面如下图。页面的最上方，显示的是当前连接的 Ethereum 网络，Gas 价格，和登录的 Ethereum 帐号地址。  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/simple-secret-note-ui.png" alt="Simple Secret Note UI">  </p>
<h2 id="Web3"><a href="#Web3" class="headerlink" title="Web3"></a>Web3</h2><p>想要在页面集成 Ethereum 帐号网络，并且对智能合约进行操作，我们需要借助前一章提及的 <a href="https://github.com/ethereum/web3.js" target="_blank" rel="external">web3.js</a>，它是 Ethereum 兼容的 JavaScript API 库。  </p>
<p>在页面打开初始化的时候，我们需要初始化一个 Web3 的实例。这段代码放在 Vuejs 的 <code>created</code> 事件里。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">created() &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</div><div class="line">    <span class="comment">// Use MetaMask's provider</span></div><div class="line">    web3js = <span class="keyword">new</span> Web3(web3.currentProvider);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">this</span>.showAlertMsg(<span class="string">'Please install &lt;a href="https://metamask.io/" target="__blank"&gt;MetaMask&lt;/a&gt; extension for your browser before using.'</span>, <span class="string">'warning'</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Async</span></div><div class="line">  <span class="keyword">this</span>.detectNetwork();</div><div class="line">  <span class="keyword">this</span>.getGasPrice();</div><div class="line">  <span class="keyword">this</span>.initAccount();</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>当它检测到 <code>web3</code> 这个对象已经存在的时候，就根据当前 web3 的提供者（currentProvider），新建一个 Web3 的实例。只有当 Web3 实例初始化成功的情况下，我们才会继续检测当前的 Ethereum 网络，获取 Gas 价格，以及当前登录的帐号信息。  </p>
<p>那谁会提供 web3 对象呢？就是代码里提醒安装的 MetaMask。<a href="https://metamask.io/" target="_blank" rel="external">MetaMask</a> 是一个浏览器插件，你可以使用它来生成新的 Ethereum 地址帐号，或者登录你现有的帐号。  </p>
<h2 id="网络和帐号的初始化"><a href="#网络和帐号的初始化" class="headerlink" title="网络和帐号的初始化"></a>网络和帐号的初始化</h2><p>在 Ethereum 世界，Eth 地址，就是身份帐号。所以，Dapp 和 Ethereum 的集成，我们应该只需要用户使用它们特定的帐号登陆就可以了，完全没有必要再额外弄用户名密码什么的。集成和使用一个广泛接受的帐号管理工具，能让你的 Dapp 用户更放心。  </p>
<h3 id="代码集成"><a href="#代码集成" class="headerlink" title="代码集成"></a>代码集成</h3><p>帐号初始化的代码，就在 <code>initAccount</code> 这个方法里面：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">initAccount() &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_getAccount</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    web3js.eth.getAccounts(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (result.length === <span class="number">0</span> || result[<span class="number">0</span>] === that.account) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      that.account = result[<span class="number">0</span>];</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setInterval(_getAccount.bind(<span class="keyword">this</span>), <span class="number">100</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里比较特别的是，设置了一个定时器，每隔 100ms 就会检测当前的帐号是什么，然后更新页面的帐号信息。</p>
<p>如果你看了 <code>detectNetwork</code> 和 <code>getGasPrice</code> 里面的代码，可能会疑惑，为什么它们不需要设定定时器呢？因为，MetaMask 插件检测到你切换网络，并且当前页面曾经访问和使用过 web3 对象的话，它会自动刷新页面。  </p>
<h3 id="MetaMask-配置"><a href="#MetaMask-配置" class="headerlink" title="MetaMask 配置"></a>MetaMask 配置</h3><h4 id="本地网络设置"><a href="#本地网络设置" class="headerlink" title="本地网络设置"></a>本地网络设置</h4><p>因为我们当前是使用本地的 Ganache 网络来测试，所以我们先要在 MetaMask 上面配置好网络和相应的测试帐号。  </p>
<p>首先我们点击左上角的网络下拉选择器，然后点击 <code>Custom RPC</code>：  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/metamask-custom-rpc-menu.png" alt="MetaMask Custom RPC Menu">  </p>
<p>然后我们在 Current RPC 下面输入 <code>http://localhost:7545</code>，点击 <code>Save</code>。  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/metamask-custom-rpc-setup.png" alt="MetaMask Custom RPC Setup">  </p>
<h4 id="帐号设置"><a href="#帐号设置" class="headerlink" title="帐号设置"></a>帐号设置</h4><p>安装完 MetaMask 插件时，它默认会帮你创建了一个新帐号。但是，我们需要把 Ganache 自动生成的帐号导入 MetaMask，才能使用它们和我们部署的合约交互。  </p>
<p>在 Ganache 首页的帐号列表下，我们选择第一个（合约创建帐号），点击最右边的钥匙图标，查看它的私钥，并且复制下来。（这里是测试帐号，所以暴露私钥没关系。但是如果是你的真实 Ethereum 帐号，就一定不能暴露了）  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/ganache-account-show-key.png" alt="Ganache Account Show Key">  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/ganache-account-private-key.png" alt="Ganache Account Private Key">  </p>
<p>然后，我们点击 MetaMask 页面右上角的小人图标，会出来以下菜单：  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/metamask-account.png" alt="Metamask Account">  </p>
<p>最后，点击 <code>Import Account</code> 菜单，就进入以下输入私钥的页面。然后粘贴刚才复制的私钥，点击 <code>Import</code> 即可。  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/metamask-account-import.png" alt="Metamask Account Import">  </p>
<h2 id="智能合约的引入和交互"><a href="#智能合约的引入和交互" class="headerlink" title="智能合约的引入和交互"></a>智能合约的引入和交互</h2><p>既然 Ethereum 测试帐号和网络的集成已经准备好，我们就可以在代码引入智能合约，并与之交互了。  </p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>首先，我们要先在当前项目下安装和使用 <code>truffle-contract</code> 这个包。  </p>
<blockquote>
<p>npm install truffle-contract</p>
</blockquote>
<p>然后，在页面里 JavaScript 脚本的顶部，加入以下几行代码，引入上一章我们运行 <code>truffle compile</code> 后生成的合约 json。并且，配置好我们运行 <code>truffle migrate</code> 后部署在 Ganache 里面的合约地址。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Contract <span class="keyword">from</span> <span class="string">'truffle-contract'</span>;</div><div class="line"><span class="keyword">import</span> SecretNoteDef <span class="keyword">from</span> <span class="string">'../build/contracts/SecretNote.json'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> SecretNote = Contract(SecretNoteDef);</div><div class="line"><span class="keyword">const</span> CONTRACT_ADDRESS = <span class="string">'0x345ca3e014aaf5dca488057592ee47305d9b3e10'</span>;</div></pre></td></tr></table></figure>
<p>最后，在 Vue 组件的 <code>created</code> 事件里，等 web3js 初始化成功后，设置合约的 Ethereum 网络地址。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SecretNote.setProvider(web3.currentProvider);</div></pre></td></tr></table></figure>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>和智能合约的交互分两种：  </p>
<ol>
<li><p>Transaction  </p>
<p>Transaction 类型的交互是会永久改变 Ethereum 网络的状态，也就是涉及账户之间的转账，或者智能合约的数据的改变。这种交互是需要花费 Gas 的，而且交易需要确认，并不能马上返回。所以，这些交互需要绑定在某一个账户下来执行。SecretNote <code>setNote</code> 方法的调用就属于这种类型。  </p>
</li>
<li><p>Call  </p>
<p>Call 类型的交互只是从区块链中读取数据。所以，它是不需要消耗任何 Gas 的，而且也能马上获取返回值。SecretNote <code>getNote</code> 方法的调用则属于此类型。  </p>
</li>
</ol>
<h4 id="Transaction-调用"><a href="#Transaction-调用" class="headerlink" title="Transaction 调用"></a>Transaction 调用</h4><ol>
<li>调用 <code>SecretNote.at()</code> 方法从特定地址获取合约实例。  </li>
<li>在获取的实例对象上，像调用普通 JavaScript 方法一样使用。特别之处是要指定调用的帐号地址。  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">saveNote() &#123;</div><div class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  SecretNote.at(CONTRACT_ADDRESS)</div><div class="line">    .then((instance) =&gt; &#123;</div><div class="line">      <span class="keyword">return</span> instance.setNote(that.noteForm.noteName,</div><div class="line">        that.noteForm.noteContent, &#123; <span class="keyword">from</span>: that.account &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>执行成功后，会弹出如下页面：  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/metamask-trx-request.png" alt="Metamask Trx Request">  </p>
<p>点击 <code>Submit</code> 后，交易记录会出现在账户下并等待区块链的确认。  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/metamask-trx-confirm.png" alt="Metamask Trx Confirm">  </p>
<h4 id="Call-调用"><a href="#Call-调用" class="headerlink" title="Call 调用"></a>Call 调用</h4><p>SecretNote <code>getNote</code> 方法调用其实和 <code>setNote</code> 差不多，只是不需要指定帐号而已。  </p>
<p>有一点要注意的是，这个方法定义的返回值类型是 <code>bytes32</code>，所以要使用 <code>toAscii</code> 方法把内容转换后才使用。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">loadNote() &#123;</div><div class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  SecretNote.at(CONTRACT_ADDRESS)</div><div class="line">    .then((instance) =&gt; &#123;</div><div class="line">      <span class="keyword">return</span> instance.getNote(that.noteForm.noteName);</div><div class="line">    &#125;)</div><div class="line">    .then((noteContent) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (!noteContent) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      that.noteForm.noteContent = web3js.toAscii(noteContent);</div><div class="line">    &#125;);</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>由于我们现在是在本地 Ganache 测试网络上集成和调试的，而 Ganache 每次重启后，数据都被重置，在 Solidity 合约代码还不稳定，需要经常改的时候，这是一个好事。但是，如果合约代码已经稳定，我们要调试前端代码，就不需要合约经常变了。下一章我们再看看如何把合约部署到 Ethereum 的一些公共的测试网络吧。  </p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="http://www.thinkingincrowd.me/2018/02/25/dapp-development-1-what-should-be-in-blockchain/">Ethereum Dapp 开发 (1) - 什么应放在区块链上</a><br><a href="http://www.thinkingincrowd.me/2018/02/27/dapp-development-2-contract-development-in-solidity/">Ethereum Dapp 开发 (2) - 用 Solidity 开发智能合约</a><br><a href="http://www.thinkingincrowd.me/2018/03/05/dapp-development-3-contract-testing-remix-ide/">Ethereum Dapp 开发 (3) - 智能合约测试（Remix IDE）</a><br><a href="http://www.thinkingincrowd.me/2018/03/11/dapp-development-4-contract-testing-truffle/">Ethereum Dapp 开发 (4) - 智能合约测试（Truffle）</a><br><a href="http://www.thinkingincrowd.me/2018/03/17/dapp-development-5-UI-integration/">Ethereum Dapp 开发 (5) - 页面开发集成</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要讲述 Dapp 前端页面，怎么和 Ethereum 帐号网络集成。不过，涉及的前端开发和代码，不会包括在覆盖范围内。因为前端开发框架太多（Vuejs, React, AngularJS，JQuery 等），使用什么都可以，所以本文仅解释合约相关的代码。本文代码以
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Ethereum" scheme="http://www.thinkingincrowd.me/tags/Ethereum/"/>
    
      <category term="Dapp" scheme="http://www.thinkingincrowd.me/tags/Dapp/"/>
    
      <category term="Smart Contract" scheme="http://www.thinkingincrowd.me/tags/Smart-Contract/"/>
    
      <category term="MetaMask" scheme="http://www.thinkingincrowd.me/tags/MetaMask/"/>
    
  </entry>
  
  <entry>
    <title>Ethereum Dapp 开发 (4) - 智能合约测试（Truffle）</title>
    <link href="http://www.thinkingincrowd.me/2018/03/11/dapp-development-4-contract-testing-truffle/"/>
    <id>http://www.thinkingincrowd.me/2018/03/11/dapp-development-4-contract-testing-truffle/</id>
    <published>2018-03-11T08:44:16.000Z</published>
    <updated>2018-04-10T08:46:23.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Truffle-是什么？"><a href="#Truffle-是什么？" class="headerlink" title="Truffle 是什么？"></a>Truffle 是什么？</h2><p>上一篇文章我们已经介绍了如何使用 Remix 来初步测试智能合约。虽然它使用起来很方便，但是还是有一些不适合拿来当测试工具的地方。我们来尝试用另一个叫 <a href="http://truffleframework.com/" target="_blank" rel="external">Truffle</a> 的工具来测试。  </p>
<p>Truffle 是什么呢？它的官方介绍是这样的：  </p>
<blockquote>
<p><strong>YOUR ETHEREUM SWISS ARMY KNIFE</strong></p>
<p>Truffle is the most popular development framework for Ethereum with a mission to make your life a whole lot easier.</p>
</blockquote>
<p>霸气吧？既然敢称自己为 Ethereum 的瑞士军刀，那它肯定不仅仅只能拿来当测试框架用。它其实是 Ethereum Dapp 的一套开发框架。后面的文章我们会再介绍如何使用它来开发，这篇文章暂时只关注如何使用它来测试智能合约。  </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Truffle 是完全基于 JavaScript 写的。它的安装非常容易。  </p>
<blockquote>
<p>npm install -g truffle</p>
</blockquote>
<p>npm 是 <a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a> 的包管理系统，这里我就不介绍了。大家自行到官网下载安装最新的 LTS 版本就可以了。  </p>
<p>另外，我们还要安装 <a href="http://truffleframework.com/ganache/" target="_blank" rel="external">Ganache</a>。这个工具可以很容易地帮我们配置一个本地的 Ethereum blockchain 节点，方便我们测试。这个工具的安装需要根据不同操作系统下载安装包，也非常简单。  </p>
<h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><p>必要的工具安装好以后，我们要配置一个 Truffle 使用的项目目录结构，和一点配置文件。  </p>
<p>我建了一个 Ethereum Dapp 开发的<a href="https://github.com/kenspirit/eth-dapp-base.git" target="_blank" rel="external">模板结构项目</a>放在 Github 上，大家 clone 下来就可以了。里面还有一些前端相关的文件，这些在后面做 Dapp 前端交互的时候再关注，暂时可以不用理会。  </p>
<p>代码克隆下来后，大家先进入项目的文件夹内，运行以下命令，安装一些必要的包。  </p>
<blockquote>
<p>npm install</p>
</blockquote>
<p>整个目录里面，我使用红色框标出和 Truffle 以及测试相关的部分。  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/eth-dapp-base-project-structure.png" alt="Project Structure">  </p>
<ol>
<li><p><code>contracts</code> 目录下放的是智能合约文件。<br>那个特殊的 <code>Migrations.sql</code> 是 Truffle 拿来运行智能合约升级脚本，记录版本的合约。你无须理会。  </p>
</li>
<li><p><code>migrations</code> 目录下，是按顺序要运行的智能合约脚本。<br>这就像你跑数据库升级脚本一样，增量式的。第一个是部署 truffle 那个 <code>Migrations</code> 合约，第二个就是部署我们自己的合约。  </p>
</li>
<li><p><code>test</code> 目录下，存放智能合约的测试脚本。<br>Truffle 支持写 JavaScript 或者 Solidity 来测试智能合约。这次我只介绍怎么用 JavaScript 来测试。  </p>
</li>
</ol>
<ol>
<li><code>truffle.js</code> 和 <code>truffle-config.js</code> 都是它的配置文件。<br>正常来说应该是放在 <code>truffle.js</code> 里面的。但是，在 Windows 环境下，<code>truffle.js</code> 可能会和 truffle 的命令产生冲突。<a href="http://truffleframework.com/docs/advanced/configuration" target="_blank" rel="external">官方文档</a>列了一些解决方案，重命名为 <code>truffle-config.js</code> 是其中一种。  </li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在 <code>truffle.js</code> 里面，我们已经配置了连接的环境是本地的 blockchain。所以，在运行测试前，我们要先启动前面安装好的 Ganache。  </p>
<h3 id="框架和基本规则"><a href="#框架和基本规则" class="headerlink" title="框架和基本规则"></a>框架和基本规则</h3><p>如果你曾经写过 JavaScript 的测试，那你可能已经接触过 <a href="https://mochajs.org/" target="_blank" rel="external">Mocha</a> 和 <a href="http://chaijs.com/" target="_blank" rel="external">Chai</a>。Truffle 就是使用这两个工具来测试的。  </p>
<p>那 Truffle 的测试，和普通的 Mocha 能识别的测试有什么不同呢？  </p>
<ol>
<li><p>Truffle 里面使用的是 <code>contract</code> 关键字，而不是 <code>describe</code> 关键字。  </p>
</li>
<li><p>Truffle 为 <code>contract</code> function 代码块提供了 <a href="http://truffleframework.com/docs/getting_started/testing#clean-room-environment" target="_blank" rel="external">clean-room features</a>。<br>意思就是，在每个 <code>contract</code> 函数运行前，你的合约都会重新部署。那么，在 <code>contract</code> function 里面的所有测试都运行在干净的合约状态之下。（<code>contract</code> 里面的代码都共享一个合约状态，下面会解释）</p>
</li>
<li><p><code>contract</code> 方法提供了一些测试帐号，方便测试使用。  </p>
</li>
</ol>
<h3 id="语法和编写"><a href="#语法和编写" class="headerlink" title="语法和编写"></a>语法和编写</h3><p>Truffle 支持 <code>async/await</code> 和 <code>then</code> 的 Promise 写法。因为前者比较节省篇幅，本文就只介绍 <code>async/await</code> 的写法。如果你还看不惯 <code>async/await</code> 的语法，Truffle 还支持 <code>then</code> 的写法，详细的例子大家可以看看<a href="http://truffleframework.com/docs/getting_started/javascript-tests" target="_blank" rel="external">官网</a>。  </p>
<p>测试文件的整体结构是这样的。  </p>
<p>一开始我们需要使用 <code>artifacts.require(&#39;SecretNote&#39;)</code> 来获得某个特定合约的抽象类，从而可以操作这个智能合约。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> SecretNote = artifacts.require(<span class="string">'SecretNote'</span>);</div><div class="line"></div><div class="line">contract(<span class="string">'SecretNote async/await style full test'</span>, <span class="keyword">async</span> (accounts) =&gt; &#123;</div><div class="line">  <span class="comment">// `it` 测试代码块在这</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>假定我们的第一个测试用例是判定合约最开始的笔记数量是否为 0，那么，相应的 <code>it</code> 测试代码块可以这样写：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'Initial Note Count should be 0'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> instance = <span class="keyword">await</span> SecretNote.deployed();</div><div class="line">  <span class="keyword">const</span> initalCount = <span class="keyword">await</span> instance.getTotalNoteCount();</div><div class="line"></div><div class="line">  <span class="comment">// initalCount is BigNumber object</span></div><div class="line">  assert.equal(initalCount.valueOf(), <span class="number">0</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里有两点要注意的：  </p>
<ol>
<li><p><code>await SecretNote.deployed()</code> 部署和获取一个合约实例。这段代码，只要在一个 <code>contract</code> function 里面调用，无论多少次，获得的合约实例都是同一个。  </p>
</li>
<li><p><code>instance.getTotalNoteCount()</code> 获取的数据，都是被包装成 <a href="https://github.com/MikeMcl/bignumber.js" target="_blank" rel="external">BigNumber</a> 对象的，因为 JavaScript 处理不了大额数字，和浮点数据。  </p>
</li>
</ol>
<p>剩下来我们可以写另外两个测试了：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'Set and get Note'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> instance = <span class="keyword">await</span> SecretNote.deployed();</div><div class="line">  <span class="keyword">const</span> noteKey = <span class="string">'key'</span>;</div><div class="line">  <span class="keyword">const</span> originNoteValue = <span class="string">'value'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">await</span> instance.setNote(noteKey, originNoteValue)</div><div class="line">  <span class="keyword">const</span> noteValue = <span class="keyword">await</span> instance.getNote(noteKey);</div><div class="line">  <span class="comment">// Github issue: https://github.com/ethereum/web3.js/issues/337</span></div><div class="line">  assert.equal(web3.toAscii(noteValue).replace(<span class="regexp">/\u0000/g</span>, <span class="string">''</span>), originNoteValue);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">it(<span class="string">'Note Count is Correct After Setting Note'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> instance = <span class="keyword">await</span> SecretNote.deployed();</div><div class="line">  <span class="keyword">const</span> initalCount = <span class="keyword">await</span> instance.getTotalNoteCount();</div><div class="line"></div><div class="line">  assert.equal(initalCount.valueOf(), <span class="number">1</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里也有两点要注意的：  </p>
<ol>
<li><p><code>web3</code> 是自动注入的 <a href="https://github.com/ethereum/web3.js" target="_blank" rel="external">web3.js</a> 实例，它是 Ethereum 兼容的 JavaScript API 库。  </p>
</li>
<li><p><code>toAscii</code> 在 web3.js 0.1x 版本有数据转换的问题。在 1.0 版本后，会有另外适合人看的转换 API。  </p>
</li>
</ol>
<p>我们测试的最后一个场景是，非合约创建者（Ownable），不能调用 <code>getTotalNoteCount</code> 接口获取到数据：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'Exception should throw if not owner call getTotalNoteCount'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="comment">// accounts[1] 是合约部署地址</span></div><div class="line">  <span class="keyword">const</span> notOwnerAccount = accounts[<span class="number">2</span>];</div><div class="line"></div><div class="line">  <span class="keyword">const</span> instance = <span class="keyword">await</span> SecretNote.deployed();</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">const</span> initalCount = <span class="keyword">await</span> instance.getTotalNoteCount.call(&#123; <span class="keyword">from</span>: notOwnerAccount &#125;);</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="comment">// Chai BDD style.  From truffle v4.0.7</span></div><div class="line">    expect(e, <span class="string">'I know it'</span>).to.exist;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>有需要的话，我们在 Truffle 测试脚本里，还可以用另一种方式和<a href="http://truffleframework.com/docs/getting_started/contracts" target="_blank" rel="external">智能合约交互</a>：  </p>
<blockquote>
<p>const contract = await SecretNote.at(‘0x123456…’);</p>
</blockquote>
<p>‘0x123456…’ 只是示例，它实际上应该放你的智能合约地址。  </p>
<p>那我们怎么在本地编译部署智能合约，和获取它的地址呢？  </p>
<h2 id="编译部署合约"><a href="#编译部署合约" class="headerlink" title="编译部署合约"></a>编译部署合约</h2><p>Ganache 启动后是这个样子的，默认已经准备好了一些测试帐号。  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/ganache-startup.png" alt="Ganache Startup">  </p>
<p>然后，我们在命令行依次运行 <code>truffle compile</code> 和 <code>truffle migrate</code> 命令。运行 <code>truffle migrate</code> 前，要确保你在 <code>truffle.js</code> 配置的 Ethereum 节点已经起来了。当前的配置，就是你的 Ganache。  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/truffle-compile-migrate.png" alt="Truffle Compile Migrate">  </p>
<p>运行完后，你可以再去看 Ganache 里面的第一个账户余额已经不是 100 ETH 了，因为扣除了一部分 Gas 来建立智能合约。点击 Transactions 那个按钮，也可以看到刚才部署智能合约产生的交易记录。  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/ganache-account.png" alt="Ganache Account">  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/ganache-trx.png" alt="Ganache Transactions">  </p>
<p>到这里，你的智能合约已经在本地的 Ethereum blockchain 节点部署完成了。部署到测试环境或者正式 Ethereum 公链的方法，我们后面再介绍。  </p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="http://www.thinkingincrowd.me/2018/02/25/dapp-development-1-what-should-be-in-blockchain/">Ethereum Dapp 开发 (1) - 什么应放在区块链上</a><br><a href="http://www.thinkingincrowd.me/2018/02/27/dapp-development-2-contract-development-in-solidity/">Ethereum Dapp 开发 (2) - 用 Solidity 开发智能合约</a><br><a href="http://www.thinkingincrowd.me/2018/03/05/dapp-development-3-contract-testing-remix-ide/">Ethereum Dapp 开发 (3) - 智能合约测试（Remix IDE）</a><br><a href="http://www.thinkingincrowd.me/2018/03/11/dapp-development-4-contract-testing-truffle/">Ethereum Dapp 开发 (4) - 智能合约测试（Truffle）</a><br><a href="http://www.thinkingincrowd.me/2018/03/17/dapp-development-5-UI-integration/">Ethereum Dapp 开发 (5) - 页面开发集成</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Truffle-是什么？&quot;&gt;&lt;a href=&quot;#Truffle-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Truffle 是什么？&quot;&gt;&lt;/a&gt;Truffle 是什么？&lt;/h2&gt;&lt;p&gt;上一篇文章我们已经介绍了如何使用 Remix 来初步测试智能
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Ethereum" scheme="http://www.thinkingincrowd.me/tags/Ethereum/"/>
    
      <category term="Dapp" scheme="http://www.thinkingincrowd.me/tags/Dapp/"/>
    
      <category term="Smart Contract" scheme="http://www.thinkingincrowd.me/tags/Smart-Contract/"/>
    
      <category term="Truffle" scheme="http://www.thinkingincrowd.me/tags/Truffle/"/>
    
      <category term="Ganache" scheme="http://www.thinkingincrowd.me/tags/Ganache/"/>
    
  </entry>
  
  <entry>
    <title>Ethereum Dapp 开发 (3) - 智能合约测试（Remix IDE）</title>
    <link href="http://www.thinkingincrowd.me/2018/03/05/dapp-development-3-contract-testing-remix-ide/"/>
    <id>http://www.thinkingincrowd.me/2018/03/05/dapp-development-3-contract-testing-remix-ide/</id>
    <published>2018-03-05T04:20:20.000Z</published>
    <updated>2018-04-10T08:46:23.600Z</updated>
    
    <content type="html"><![CDATA[<p>我们在前面一篇说到，智能合约发布后就没法修改了。所以，在真正发布前，我们必须进行详细的测试。那智能合约怎么测试呢？难不成我们自己要部署一个自己的 Ethereum 网络节点？  </p>
<p>这篇文章，我先介绍一种最简单直接的测试方式。  </p>
<h2 id="完整合约代码"><a href="#完整合约代码" class="headerlink" title="完整合约代码"></a>完整合约代码</h2><p>上一篇教程完成后，智能合约的完整代码应该是这样的。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.18;</div><div class="line"></div><div class="line">contract Ownable &#123;</div><div class="line">    address owner;</div><div class="line"></div><div class="line">    function Ownable() public &#123;</div><div class="line">        owner = msg.sender;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    modifier onlyOwner() &#123;</div><div class="line">        require(owner == msg.sender);</div><div class="line">        _;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">contract SecretNote is Ownable &#123;</div><div class="line">  mapping(address =&gt; mapping(bytes32 =&gt; bytes32)) notes;</div><div class="line">  uint256 noteCount;</div><div class="line"></div><div class="line">  event SecretNoteUpdated(address indexed _sender, bytes32 indexed _noteKey, bool _success);</div><div class="line"></div><div class="line">  function SecretNote() public &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function () public payable &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * @dev For user to get their own secret note</div><div class="line">   * @param _noteKey The key identifier for particular note</div><div class="line">   */</div><div class="line">  function getNote(bytes32 _noteKey) public view returns (bytes32) &#123;</div><div class="line">      return notes[msg.sender][_noteKey];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * @dev For user to update their own secret note</div><div class="line">   * @param _noteKey The key identifier for particular note</div><div class="line">   * @param _content The note path hash</div><div class="line">   */</div><div class="line">  function setNote(bytes32 _noteKey, bytes32 _content) public payable &#123;</div><div class="line">      require(_noteKey != &quot;&quot;);</div><div class="line">      require(_content != &quot;&quot;);</div><div class="line"></div><div class="line">      notes[msg.sender][_noteKey] = _content;</div><div class="line">      noteCount++;</div><div class="line"></div><div class="line">      SecretNoteUpdated(msg.sender, _noteKey, true);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function getTotalNoteCount() public view onlyOwner returns(uint256) &#123;</div><div class="line">      return noteCount;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Remix-IDE"><a href="#Remix-IDE" class="headerlink" title="Remix IDE"></a>Remix IDE</h2><p><a href="https://remix.ethereum.org" target="_blank" rel="external">Remix IDE</a> 是一个在线的智能合约编译，测试和部署工具。使用它可以很方便的和智能合约交互，虽然有些地方不是那么便利。  </p>
<h3 id="合约编译检查"><a href="#合约编译检查" class="headerlink" title="合约编译检查"></a>合约编译检查</h3><p>当我们打开 Remix 的页面，把我们的智能合约代码贴进去的时候，它已经会自动帮你编译代码。右侧是主要的操作区。它有好几个功能标签。<code>Compile</code> 标签会显示出编译后有哪些合约，已经它发现的一些 Warning。  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/Remix_compile_contract.png" alt="Remix IDE - Compile">  </p>
<h3 id="合约创建"><a href="#合约创建" class="headerlink" title="合约创建"></a>合约创建</h3><p>既然编译没有问题，我们点击旁边的 <code>Run</code> 标签看看怎么部署运行这个合约。  </p>
<ol>
<li>选择 <code>JavaScript VM</code> 这个 Environment。你会发现它马上帮你创建了好几个拥有了 100 eth 的帐号。  </li>
<li>在合约名字下拉框选择我们将要部署的合约 <code>SecretNote</code>。  </li>
<li>点击 Create</li>
<li>合约就生成了。它的接口 <code>fallback</code>，<code>getTotalNoteCount</code>，<code>getNote</code>，<code>setNote</code> 都分别显示出来。  </li>
<li>因为我们用了默认提供的第一个帐号来创建合约，它的帐号余额已经不是 100 eth 了。  </li>
</ol>
<p><img src="http://thinkingincrowd.u.qiniudn.com/Remix_create_contract.png" alt="Remix IDE - Create">  </p>
<h3 id="合约调用"><a href="#合约调用" class="headerlink" title="合约调用"></a>合约调用</h3><p>合约创建完，我们就可以调用合约提供的对外的接口了，有几点值得留意的是：  </p>
<ol>
<li>只读 <code>view</code> 的方法，它的名字是蓝色的；其它的方法名字是粉红色的。  </li>
<li>方法调用时，我们需要用双引号，和逗号把参数分开。  </li>
</ol>
<p>现在我们按 <code>setNote</code>, <code>getNote</code>, <code>getTotalNoteCount</code> 的执行顺序来操作一下。  </p>
<ol>
<li>在 <code>setNote</code> 旁边的输入框填入：<code>&quot;0x1&quot;, &quot;Ken&quot;</code>，点击方法名。点完后好像什么都没有发生，但是你在中间的执行日志区可以看到类似的日志：  </li>
</ol>
<blockquote>
<p>transact to SecretNote.setNote pending …<br>[vm] from:0xca3…a733c, to:SecretNote.setNote(bytes32,bytes32) 0xbbf…732db, value:0 wei, data:0x7b7…00000, 1 logs, hash:0xbbe…7df4d</p>
</blockquote>
<ol>
<li>在 <code>getNote</code> 旁的输入框填入：<code>&quot;0x1&quot;</code>，点击方法名。它的右边就会给出这样的显示：  </li>
</ol>
<blockquote>
<p>0: bytes32: 0x4b656e0000000000000000000000000000000000000000000000000000000000</p>
</blockquote>
<p>因为 Solidity 的 function 是可以有多个返回值的，所以这里显示的是第一个返回值的类型和数值。  </p>
<ol>
<li>同样，点击 <code>getTotalNoteCount</code> 会返回当前的笔记数量。  </li>
</ol>
<blockquote>
<p>0: uint256: 1</p>
</blockquote>
<p><img src="http://thinkingincrowd.u.qiniudn.com/Remix_call_contract.png" alt="Remix IDE - Call">  </p>
<p>现在，我们来看一看如果用另一个帐号（非合约创建帐号），来调用 <code>getTotalNoteCount</code> 会出现什么效果。  </p>
<ol>
<li>在 <code>Account</code> 下拉框选择另外的一个帐号。这个帐号应该有 100 eth，因为从来没操作过。  </li>
<li>点击 <code>getTotalNoteCount</code> 调用方法。  </li>
</ol>
<p>这时候，你会发现中间的执行日志区出现类似下面的日志。其实，你的操作是失败了的。但是它的报错信息实在是太让人困惑了。  </p>
<blockquote>
<p>call to SecretNote.getTotalNoteCount errored: VM error: revert.<br>revert  The transaction has been reverted to the initial state.<br>Note: The constructor should be payable if you send value.  Debug the transaction to get more information. </p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Remix IDE 的基本使用和智能合约的测试就介绍到这里。使用它来测试是比较方便的，你也不用设置什么环境。但是它上面的操作并不是那么灵活，而且是在线工具。  </p>
<p>我们能不能像写 JAVA, JavaScript Unit Test 那样来测试智能合约呢？下一篇文章我将介绍 Truffle 这个框架的使用。  </p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="http://www.thinkingincrowd.me/2018/02/25/dapp-development-1-what-should-be-in-blockchain/">Ethereum Dapp 开发 (1) - 什么应放在区块链上</a><br><a href="http://www.thinkingincrowd.me/2018/02/27/dapp-development-2-contract-development-in-solidity/">Ethereum Dapp 开发 (2) - 用 Solidity 开发智能合约</a><br><a href="http://www.thinkingincrowd.me/2018/03/05/dapp-development-3-contract-testing-remix-ide/">Ethereum Dapp 开发 (3) - 智能合约测试（Remix IDE）</a><br><a href="http://www.thinkingincrowd.me/2018/03/11/dapp-development-4-contract-testing-truffle/">Ethereum Dapp 开发 (4) - 智能合约测试（Truffle）</a><br><a href="http://www.thinkingincrowd.me/2018/03/17/dapp-development-5-UI-integration/">Ethereum Dapp 开发 (5) - 页面开发集成</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在前面一篇说到，智能合约发布后就没法修改了。所以，在真正发布前，我们必须进行详细的测试。那智能合约怎么测试呢？难不成我们自己要部署一个自己的 Ethereum 网络节点？  &lt;/p&gt;
&lt;p&gt;这篇文章，我先介绍一种最简单直接的测试方式。  &lt;/p&gt;
&lt;h2 id=&quot;完整合
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Ethereum" scheme="http://www.thinkingincrowd.me/tags/Ethereum/"/>
    
      <category term="Dapp" scheme="http://www.thinkingincrowd.me/tags/Dapp/"/>
    
      <category term="Smart Contract" scheme="http://www.thinkingincrowd.me/tags/Smart-Contract/"/>
    
      <category term="Remix" scheme="http://www.thinkingincrowd.me/tags/Remix/"/>
    
  </entry>
  
  <entry>
    <title>Ethereum Dapp 开发 (2) - 用 Solidity 开发智能合约</title>
    <link href="http://www.thinkingincrowd.me/2018/02/27/dapp-development-2-contract-development-in-solidity/"/>
    <id>http://www.thinkingincrowd.me/2018/02/27/dapp-development-2-contract-development-in-solidity/</id>
    <published>2018-02-27T12:20:20.000Z</published>
    <updated>2018-04-10T08:46:23.599Z</updated>
    
    <content type="html"><![CDATA[<p>Ethereum 的 Dapp 开发，保存数据在公链上，最基本的就是要实现一个智能合约。我们先来看一下 <a href="http://www.secret-note.one" target="_blank" rel="external">Secret Note</a> 的智能合约怎么实现。  </p>
<h2 id="Solidity-简介"><a href="#Solidity-简介" class="headerlink" title="Solidity 简介"></a>Solidity 简介</h2><blockquote>
<p>Solidity is a <strong>contract-oriented</strong>, high-level language for implementing smart contracts. It was influenced by C++, Python and JavaScript and is designed to target the Ethereum Virtual Machine (EVM).  </p>
<p>Solidity is <strong>statically typed, supports inheritance</strong>, libraries and complex user-defined types among other features.</p>
</blockquote>
<p>我高亮了几点我们在这次开发上需要用到的特性。  </p>
<p>学习过其它高级编程语言的开发可能对这些名词已经比较熟悉了。什么是 <strong>contract-oriented</strong> 啊？这好像是新玩意啊。其实你想想 JAVA 的 <strong>class-oriented</strong> 基本就能猜出七七八八了。</p>
<h2 id="合约编写"><a href="#合约编写" class="headerlink" title="合约编写"></a>合约编写</h2><p>早在 2012 年，我在自己的一篇关于 JavaScript 测试的文章提到一个理念：需要测试的，是双方之间协定的合约。这个合约就是交互的接口和行为。  </p>
<p>这个理念放到智能合约的编写上，我感觉更加直接了。所以，我们需要怎么编写智能合约，最重要的是想清楚，今后这个合约和外界交互的行为是什么。  </p>
<h3 id="与普通后端开发最大区别"><a href="#与普通后端开发最大区别" class="headerlink" title="与普通后端开发最大区别"></a>与普通后端开发最大区别</h3><p>智能合约的开发，不像普通后端的开发，有 bug 或者想加功能了，重新发一版就好了。  </p>
<p><strong>智能合约发布出去，就没法修改了。</strong>  </p>
<p>所以，把智能合约发布上公链前，一定要想清楚需求，做好测试。如果合约的链上行为，业务上真的很可能需要升级和修改，就应该提前想好策略，比如隔离接口和业务逻辑合约，使用类似 proxy 的设计等。这属于比较高级的开发需求，我也还不是了解的很清楚，这篇教程暂时不涉及这方面的内容。  </p>
<h3 id="Secret-Note-合约设计编写"><a href="#Secret-Note-合约设计编写" class="headerlink" title="Secret Note 合约设计编写"></a>Secret Note 合约设计编写</h3><p>对于 Secret Note 这个 Dapp 来说，它对外提供的行为，智能合约的接口应该有什么呢？  </p>
<ol>
<li>保存资料的索引  </li>
<li>获取资料的索引  </li>
</ol>
<p>最核心的功能，好像就这两个了，是吧？按照这个简单的设计，合约的代码大致是这样的。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.18;</div><div class="line"></div><div class="line">contract SecretNote &#123;</div><div class="line">  mapping(address =&gt; mapping(bytes32 =&gt; bytes32)) notes;</div><div class="line"></div><div class="line">  event SecretNoteUpdated(address indexed _sender, bytes32 indexed _noteKey, bool _success);</div><div class="line"></div><div class="line">  function SecretNote() public &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function () public payable &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * @dev For user to get their own secret note</div><div class="line">   * @param _noteKey The key identifier for particular note</div><div class="line">   */</div><div class="line">  function getNote(bytes32 _noteKey) public view returns (bytes32) &#123;</div><div class="line">      return notes[msg.sender][_noteKey];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * @dev For user to update their own secret note</div><div class="line">   * @param _noteKey The key identifier for particular note</div><div class="line">   * @param _content The note path hash</div><div class="line">   */</div><div class="line">  function setNote(bytes32 _noteKey, bytes32 _content) public payable &#123;</div><div class="line">      require(_noteKey != &quot;&quot;);</div><div class="line">      require(_content != &quot;&quot;);</div><div class="line"></div><div class="line">      notes[msg.sender][_noteKey] = _content;</div><div class="line"></div><div class="line">      SecretNoteUpdated(msg.sender, _noteKey, true);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p>代码文件最开始的一行，<code>pragma solidity ^0.4.18;</code>，标记了代码应该由什么版本的编译器编译，以避免在不同环境出现问题。  </p>
<p>智能合约，是通过 <strong>contract</strong> 关键字，和它的名字来定义的。合约的主体内容在最外层的 <code>{</code> and <code>}</code> 之间。  </p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>Solidity 作为一种高级的静态类型编程语言，当然也有自己支持的数据类型。在这个合约里面，我们用了三种：  </p>
<ul>
<li>address  </li>
</ul>
<p>这种类型可以保存一个 Ethereum 地址。比较特殊的是，它还有自己的成员属性和方法。最常见的是 <code>balance</code> 属性和 <code>transfer</code> 方法。  </p>
<ul>
<li>bytes32  </li>
</ul>
<p>Solidity 里面有分定长和变长的 byte 数组。  </p>
<p>定长的有 <code>bytes1</code>, <code>bytes2</code>, <code>bytes3</code>, …, <code>bytes32</code>. <code>byte</code> 是 bytes1 的别名。它们都有只读属性 <code>length</code>。  </p>
<p>变长的有 <code>bytes</code> 和 <code>string</code>。  </p>
<p><code>string</code> 是用来保存不定长 UTF-8 字符数据的。其它的都是 byte 数组。如果可以，尽量用定长的可以节省资源，减少 Gas 的使用等。  </p>
<ul>
<li>mapping  </li>
</ul>
<p>我们可以把 <code>mapping</code> 当作一个哈希表。这个哈希表的 key 几乎可以是任何类型，除了 <code>mapping</code>，变长 byte 数组，contract，enum 和 struct 结构体。哈希表的 value 就可以是任何类型的数据。  </p>
<p><code>mapping</code> 有个很特殊的地方就是它没有长度，你也无法检查一个 key 是否在它里面。因为它是虚拟地记录了每一个可能的 key，对应值为全 0 字节，也就是任何数据类型的默认值。  </p>
<p><code>mapping</code> 也无法遍历。所以，我们只能通过一种绕一些的方式来遍历它。可以参看官网的 <a href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol" target="_blank" rel="external">iterable mapping</a> 例子，或我的 Secret Note 源码。  </p>
<p><em>复杂的用户定义类型：在这篇文章就不介绍了，有兴趣的朋友可以直接看 Secret Note 的<a href="https://github.com/kenspirit/secret-note" target="_blank" rel="external">源码</a></em></p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>Solidity 有 4 种作用域修饰符。<code>public</code> 是合约的接口，可内部或通过外部消息调用。<code>external</code> 也是合约接口，但是不能内部调用。<code>internal</code> 只能内部，或者由继承的合约调用。<code>private</code> 只能在定义的合约内可调用，但是，它不代表区块链外不可见。  </p>
<p><code>view</code> 修饰符表示这个方法承诺不会修改合约的状态。<code>constant</code> 是它的别名。不过，虽然这么说，编译器是没有检查，或者强制限制这个方法不能改变合约状态的。  </p>
<p><code>payable</code> 修饰符用来标记某个方法可以同时接收发过来的 Ether。  </p>
<p><code>msg.sender</code> 特指调用此方法的 Ethereum 地址。<code>msg</code> 还有其它全局属性，详情可查看 Solidity 文档。  </p>
<p><code>require()</code> 就像其它语言的 <code>assert</code> 那样检查前置条件。不满足的话，会抛错。它通常用于检查外部输入等有效条件。另一个类似用法的 <code>assert</code> 则用户内部错误的检查。  </p>
<h4 id="Fallback-方法"><a href="#Fallback-方法" class="headerlink" title="Fallback 方法"></a>Fallback 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function () public payable &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个没有任何名字的是 <code>Fallback</code> 方法。一个合约只能存在一个。这个方法没有参数，也没有任何返回值。如果有人调用这个合约，但是指定的方法找不到，它会被触发。  </p>
<p>还有，当这个合约地址单纯地收到 Ether 的时候（比如他人转账到这个合约地址），这个方法也会被调用。所以，它必须被标记为 <code>payable</code>。不然，这个合约地址就没法通过普通的交易接收 Ether 了。  </p>
<p>要注意的是，如果这个方法里面有逻辑，一定要确保它的 Gas 消耗要小于 2300。  </p>
<h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>事件是 EVM 日志记录的使用方式。如果你在你开发的 Dapp 里监听了某一个事件，当这个时间被触发后，你在 Dapp 设的监听器就会收到通知。  </p>
<p>事件的数据是存储在交易日志里的。它们可以被检索，但是合约代码里面没法访问它们。  </p>
<p>每个事件最多有 3 个索引的（<code>indexed</code>）参数，我们可以根据这些参数进行过滤检索。非索引的参数存在记录日志的数据部分里，但是索引的参数是没有存的。你只能用某个值去查索引，但是没法罗列有哪些值。  </p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>上面两个合约方法是公开的，每个人都可以调用。那如果我想添加一些只有合约创建者才能调用的方法呢？假如，我想让只有创建者能查这个合约里面存了多少资料呢？  </p>
<p>我们可以利用继承和修饰符来实现上面的目的。  </p>
<p>首先，我们定义一个父合约 <code>Ownable</code>，这个合约在它的构造函数（constructor）里面把合约创建者保存到一个合约变量。然后，提供一个特殊的修饰符给子合约使用。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">contract Ownable &#123;</div><div class="line">    address owner;</div><div class="line"></div><div class="line">    function Ownable() public &#123;</div><div class="line">        owner = msg.sender;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    modifier onlyOwner() &#123;</div><div class="line">        require(owner == msg.sender);</div><div class="line">        _;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来的智能合约，作为子合约，稍微修改一下就可以了。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">contract SecretNote is Ownable &#123;</div><div class="line">  uint256 noteCount;</div><div class="line"></div><div class="line">  // 省略部分合约代码</div><div class="line"></div><div class="line">  function setNote(bytes32 _noteKey, bytes32 _content) public payable &#123;</div><div class="line">      require(_noteKey != &quot;&quot;);</div><div class="line">      require(_content != &quot;&quot;);</div><div class="line"></div><div class="line">      notes[msg.sender][_noteKey] = _content;</div><div class="line">      noteCount++;</div><div class="line"></div><div class="line">      SecretNoteUpdated(msg.sender, _noteKey, true);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function getTotalNoteCount() public view onlyOwner returns(uint256) &#123;</div><div class="line">      return noteCount;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们只需要吧 <code>onlyOwner</code> 这个修饰符添加到任何希望只有合约 owner 才能执行的 function 签名处，这个 function 就拥有检查调用者的能力了。加了 <code>onlyOwner</code> 的 function，其实就是把代码替换到 <code>_</code> 的位置。  </p>
<h2 id="安全方面的考量"><a href="#安全方面的考量" class="headerlink" title="安全方面的考量"></a>安全方面的考量</h2><p>因为合约一旦部署，就无法修改，而且很多的智能合约都和加密货币或者 token 挂钩。所以，如果一个智能合约的实现出现了安全漏洞，就有可能引起很大的问题。  </p>
<p>Solidity <a href="https://solidity.readthedocs.io/en/develop/security-considerations.html" target="_blank" rel="external">文档</a> 里有专门的一章写了一些推荐做法，大家应该至少看 <strong>Use the Checks-Effects-Interactions Pattern</strong> 和 <strong>Include a Fail-Safe Mode</strong> 两点。  </p>
<p>到这里为止，我们就把简化版 Secret Note 的智能合约写好了。下一篇我们来看看如何测试它。  </p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="http://www.thinkingincrowd.me/2018/02/25/dapp-development-1-what-should-be-in-blockchain/">Ethereum Dapp 开发 (1) - 什么应放在区块链上</a><br><a href="http://www.thinkingincrowd.me/2018/02/27/dapp-development-2-contract-development-in-solidity/">Ethereum Dapp 开发 (2) - 用 Solidity 开发智能合约</a><br><a href="http://www.thinkingincrowd.me/2018/03/05/dapp-development-3-contract-testing-remix-ide/">Ethereum Dapp 开发 (3) - 智能合约测试（Remix IDE）</a><br><a href="http://www.thinkingincrowd.me/2018/03/11/dapp-development-4-contract-testing-truffle/">Ethereum Dapp 开发 (4) - 智能合约测试（Truffle）</a><br><a href="http://www.thinkingincrowd.me/2018/03/17/dapp-development-5-UI-integration/">Ethereum Dapp 开发 (5) - 页面开发集成</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ethereum 的 Dapp 开发，保存数据在公链上，最基本的就是要实现一个智能合约。我们先来看一下 &lt;a href=&quot;http://www.secret-note.one&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Secret Note&lt;/a&gt; 的
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Ethereum" scheme="http://www.thinkingincrowd.me/tags/Ethereum/"/>
    
      <category term="Dapp" scheme="http://www.thinkingincrowd.me/tags/Dapp/"/>
    
      <category term="Smart Contract" scheme="http://www.thinkingincrowd.me/tags/Smart-Contract/"/>
    
      <category term="Solidity" scheme="http://www.thinkingincrowd.me/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>Ethereum Dapp 开发 (1) - 什么应放在区块链上</title>
    <link href="http://www.thinkingincrowd.me/2018/02/25/dapp-development-1-what-should-be-in-blockchain/"/>
    <id>http://www.thinkingincrowd.me/2018/02/25/dapp-development-1-what-should-be-in-blockchain/</id>
    <published>2018-02-24T23:55:24.000Z</published>
    <updated>2018-04-10T08:46:23.598Z</updated>
    
    <content type="html"><![CDATA[<p>Ethereum Dapp (decentralized application) 是在区块链 Ethereum 公链上的分布式应用。  </p>
<p>前不久，我刚接触 Dapp 的开发，做了一个应用叫 <a href="http://www.secret-note.one" target="_blank" rel="external">Secret Note</a>（可查看此<a href="http://www.thinkingincrowd.me/2018/01/23/how-to-store-your-secret-in-ethereum-blockchain/">介绍</a>）。接下来，我希望通过几篇文章，来分享一下想法，和开发过程。  </p>
<h2 id="区块链是否适合"><a href="#区块链是否适合" class="headerlink" title="区块链是否适合"></a>区块链是否适合</h2><p>不是什么东西都适合放在区块链上。它有自己的特性：  </p>
<ol>
<li>分布式存储，而且是不受某一主体控制  </li>
<li>写入信息永不磨灭  </li>
</ol>
<p>想想我们经常使用的网盘，或者一些提供笔记存储服务的系统，说是多大存储量，永不收费。然后，突然就说停止运营了。如果我们能利用区块链这两个特性保存数据，是不是就完全不一样了？  </p>
<p>所以，根据这两个特性，我做这个 Dapp 的意义就很明显：让大家可以保存信息在一个永不磨灭的地方，而且不受任何主体控制，也就不存在停止运营一说了。（当然，Ethereum 整个区块链技术被遗弃除外）</p>
<h2 id="保存什么在链上"><a href="#保存什么在链上" class="headerlink" title="保存什么在链上"></a>保存什么在链上</h2><p>保存数据在公链上是有成本的。每对区块链公链作出更改，都要耗费一定的 Gas（矿工费）。而 Gas 是要用一定量的 Ether (ETH) 币来支付的。  </p>
<p>而且，对公链做越复杂的操作，需要的 Gas 越多，成本越高，甚至矿工也会拒绝执行你的操作。所以，做复杂的运算，和存储大量的数据在区块链里面也是不合适的。我们只能把最关键的数据，存放在区块链里面。  </p>
<p>回到我这个应用，我应该放什么数据在区块链上呢？  </p>
<p>用户要保存的资料，数据量肯定是比较大，无法直接存在链上的。而且区块链里面的数据，都是公开的，保存关键隐私数据要很小心处理，不然很容易泄漏。这样的话，我们应该保存在链上的是用户资料的索引，然后再根据索引去获取内容。  </p>
<p>既然我们用区块链的目的是不希望依赖某一主体，那资料的内容当然也只能选择分布式存储的手段。<a href="https://ipfs.io/" target="_blank" rel="external">IPFS</a> 正是分布式的互联网平台，并可以承担内容存储的角色。所以，用户的资料内容就选择保存在它上面。  </p>
<h2 id="怎么保存到链上"><a href="#怎么保存到链上" class="headerlink" title="怎么保存到链上"></a>怎么保存到链上</h2><p>在 Ethereum 公链上执行逻辑和存储，是通过智能合约（Smart Contract）来处理的。Ethereum 的官方定义也是：  </p>
<blockquote>
<p>Ethereum is a decentralized platform that runs smart contracts</p>
</blockquote>
<p>所以，要开发 Dapp，我们首先要学习怎么开发定义一个 Smart Contract。开发 Smart Contract，需要我们使用一种新的语言 <a href="https://solidity.readthedocs.io/en/develop/" target="_blank" rel="external">Solidity</a>，下一章我们就使用它来定义我们的合约。  </p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="http://www.thinkingincrowd.me/2018/02/25/dapp-development-1-what-should-be-in-blockchain/">Ethereum Dapp 开发 (1) - 什么应放在区块链上</a><br><a href="http://www.thinkingincrowd.me/2018/02/27/dapp-development-2-contract-development-in-solidity/">Ethereum Dapp 开发 (2) - 用 Solidity 开发智能合约</a><br><a href="http://www.thinkingincrowd.me/2018/03/05/dapp-development-3-contract-testing-remix-ide/">Ethereum Dapp 开发 (3) - 智能合约测试（Remix IDE）</a><br><a href="http://www.thinkingincrowd.me/2018/03/11/dapp-development-4-contract-testing-truffle/">Ethereum Dapp 开发 (4) - 智能合约测试（Truffle）</a><br><a href="http://www.thinkingincrowd.me/2018/03/17/dapp-development-5-UI-integration/">Ethereum Dapp 开发 (5) - 页面开发集成</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ethereum Dapp (decentralized application) 是在区块链 Ethereum 公链上的分布式应用。  &lt;/p&gt;
&lt;p&gt;前不久，我刚接触 Dapp 的开发，做了一个应用叫 &lt;a href=&quot;http://www.secret-note.on
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Ethereum" scheme="http://www.thinkingincrowd.me/tags/Ethereum/"/>
    
      <category term="Dapp" scheme="http://www.thinkingincrowd.me/tags/Dapp/"/>
    
      <category term="Smart Contract" scheme="http://www.thinkingincrowd.me/tags/Smart-Contract/"/>
    
      <category term="IPFS" scheme="http://www.thinkingincrowd.me/tags/IPFS/"/>
    
  </entry>
  
  <entry>
    <title>你以为加入了创业公司，就是创业了吗？</title>
    <link href="http://www.thinkingincrowd.me/2018/02/24/start-up-already-after-joining-a-startup-company/"/>
    <id>http://www.thinkingincrowd.me/2018/02/24/start-up-already-after-joining-a-startup-company/</id>
    <published>2018-02-24T07:45:18.000Z</published>
    <updated>2018-04-10T08:46:23.596Z</updated>
    
    <content type="html"><![CDATA[<p>从北京回到珠海，算是（至少暂时是）结束了我的“创业”历程。这次经历，让我更深刻体会到，创业和上班的不同。  </p>
<p>加入一家创业公司，其实并不算创业，因为很多人也还是充其量在打工，只不过是在创业公司打工。  </p>
<p>如果不是按创业的方式来工作，这种打工或许只是稍微多一些加班的压力，可能还有所谓的期权的动力，但是和在非创业公司没什么区别。同样道理，在非创业公司，也可以按照创业的方式来工作。  </p>
<p>那什么样的方式才是创业的方式？  </p>
<h2 id="信念"><a href="#信念" class="headerlink" title="信念"></a>信念</h2><p>这里的信念，主要指的是：  </p>
<blockquote>
<p>对你要做的事情，发自内心地深信它的价值，并且坚定地认为自己值得花时间把它做对，做好。  </p>
</blockquote>
<h3 id="与使命同行"><a href="#与使命同行" class="headerlink" title="与使命同行"></a>与使命同行</h3><p>说使命有点大，但相信产品的理念，和它的价值是很重要的。  </p>
<p>一个厌恶玩游戏的人，怎么设计游戏？一个死宅，能体会旅游的乐趣和需求吗？  </p>
<p>如果你不觉得自己做的产品有价值，或者真正能满足用户的某一需求，那你怎么可能经常自己使用它，把玩它，和完善它？  </p>
<p>你自己都不相信，怎么能期待用户相信和使用你创造的产品？  </p>
<p>即便你说，我不是产品，美术，或者前端，我只是一个后端开发，运维等偏纯技术的，有必要遵守这点吗？  </p>
<p>还是有的。做游戏的，周末、大晚上的，还有很多玩家，什么时候能重启发版？做旅游相关的，过节可能是服务器压力大的时候。不与这些使命同行，过节、大晚上加班你能接受吗？  </p>
<h3 id="坚定的方向"><a href="#坚定的方向" class="headerlink" title="坚定的方向"></a>坚定的方向</h3><p>每个产品，都有自己的方向。创业一开始就大而全，是很难的，不然为什么有 MVP？大而全意味着开发周期长，而且落地困难。  </p>
<p>就拿我们做的知识付费类来说。得到专注大V，并协助他们进行内容编辑和生产，所以他们专注内容的质量。小鹅通专注工具，所以他们专注如何容易使用和接入，低平台手续费。红豆 Live，也从付费直播，转型 95后二次元垂直领域，等等。  </p>
<p>无论是实业的互联网+，Ｏ2Ｏ，还是纯互联网创业，产品要推广到用户手上并使用，都应该要有比较明确清晰的方向和落地策略。如果这个不坚定，当发展不理想，运营推广效果不佳，很容易就会怀疑自己的产品路线，不断调整方向，提出越来越多的产品特性来满足更多的需求。最后越做越泛，越偏，感觉什么都不对而气馁放弃。  </p>
<p>当然，我不是说完全不能改，不应该适时调整方向和策略，凡事都不应该极端。但能看清楚方向，克制而坚持的执行真的很难，很重要。  </p>
<h2 id="主人翁意识"><a href="#主人翁意识" class="headerlink" title="主人翁意识"></a>主人翁意识</h2><h3 id="你的职责，没有边界"><a href="#你的职责，没有边界" class="headerlink" title="你的职责，没有边界"></a>你的职责，没有边界</h3><p>公司是你的，产品是你的，团队是你的，花的钱是你的。  </p>
<p>除了写好代码，负责好自己职责领域的事情，还有很多事情，是在你有了主人翁意识后才能做的更好的。  </p>
<p>怎么才能和团队其他人沟通更顺畅？怎么才能更好配合兄弟部门，提高他们的效率？怎么才能提高性能，用少一点服务器？怎么才能减少羊毛党，防止被捋，降低成本？是否经常留意用户后台留言，发现问题，及时解决用户困难？  </p>
<p>没有边界，不是说你什么都要管。但是创业的心态，尤其在资源匮乏的创业公司，真的很多东西都要上心，当成是自己的东西，才能做好。  </p>
<p>上面说的这些方面，如果你有足够良好的职业操守，其实也能做的很好。我也只是在这个基础线上，尽量再拔高。但是，我觉得自己距离真正创业的标准还有很大距离。  </p>
<blockquote>
<p>Settle down or not, it’s in your heart, not where you are.  </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从北京回到珠海，算是（至少暂时是）结束了我的“创业”历程。这次经历，让我更深刻体会到，创业和上班的不同。  &lt;/p&gt;
&lt;p&gt;加入一家创业公司，其实并不算创业，因为很多人也还是充其量在打工，只不过是在创业公司打工。  &lt;/p&gt;
&lt;p&gt;如果不是按创业的方式来工作，这种打工或许只
    
    </summary>
    
      <category term="Think" scheme="http://www.thinkingincrowd.me/categories/Think/"/>
    
    
      <category term="Startup" scheme="http://www.thinkingincrowd.me/tags/Startup/"/>
    
      <category term="Belief" scheme="http://www.thinkingincrowd.me/tags/Belief/"/>
    
  </entry>
  
  <entry>
    <title>How to store your secret in Ethereum blockchain</title>
    <link href="http://www.thinkingincrowd.me/2018/01/23/how-to-store-your-secret-in-ethereum-blockchain/"/>
    <id>http://www.thinkingincrowd.me/2018/01/23/how-to-store-your-secret-in-ethereum-blockchain/</id>
    <published>2018-01-23T02:54:10.000Z</published>
    <updated>2018-04-10T08:46:23.595Z</updated>
    
    <content type="html"><![CDATA[<p>I am super excited that my first Ethereum blockchain Dapp product, <a href="http://www.secret-note.one/" target="_blank" rel="external">Decentralized Secret Note</a>, is online today.  It’s pretty straightforward if you are used to make transactions with MetaMask in Ethereum network.  My excitement mainly comes from two reasons below:  </p>
<ol>
<li>As a blockchain believer, I am not the one who only hold some coins, but also now make something beneficial for others.  </li>
<li>As a developer, I can learn blockchain development using Smart Contract, IPFS and Web3.  </li>
</ol>
<h2 id="Why-am-I-doing-this"><a href="#Why-am-I-doing-this" class="headerlink" title="Why am I doing this?"></a>Why am I doing this?</h2><p>Blockchain development has always been mysterious to me before.  Lately I finally got a chance to look into it.  </p>
<p>Really learning the blockchain and make something genuinely useful in decentralized scenario is quite difficult.  This idea comes to me because many so-promised life-long storage service can suddenly terminated.  Hence, a publicly accepted blockchain seems a perfect place to put something that you never want to lose.  Your information is never in control of some particular companies.  </p>
<h2 id="Is-it-really-decentralized-and-how-safe-is-my-secret"><a href="#Is-it-really-decentralized-and-how-safe-is-my-secret" class="headerlink" title="Is it really decentralized and how safe is my secret?"></a>Is it really decentralized and how safe is my secret?</h2><p>All your secret notes have their own name/key which are stored in a Smart Contract in Ethereum.  Each of it points to an address in <a href="https://ipfs.io/" target="_blank" rel="external">IPFS</a>, which is a distributed web.  The backbone of this tool is completely decentralized and last forever unless Ethereum and IPFS themselves vanished.  This tool itself is open-source and hosted in Github.  You are freely to make a backup and host yourself if you need further assurance.  </p>
<p>The concern you may have is that the data in public blockchain is viewable by anyone.  However, through normal access, each Ethereum address should only be able to see the note names stored by this address only.  Even if your notes’ names are revealed, so others can get the address in IPFS, they still cannot see your secret because they are protected by your private key (HTTPS private key, NOT WALLET private key).  And this key should be known by yourself only.  That is why I emphasize that “<strong>IF LOST, NO ONE is able to restore your notes</strong>“.</p>
<h2 id="How-to-use-it"><a href="#How-to-use-it" class="headerlink" title="How to use it"></a>How to use it</h2><p>The authentication of using this tool is completely based on <a href="https://metamask.io/" target="_blank" rel="external">MetaMask</a> which is another great Dapp in Ethereum.  Hence, this tool DOES NOT require you to input any password or provide your wallet private key.  And for god’s sake, you should not provide those info to anybody.  </p>
<p>Once you installed MetaMask in any of your favorite browser and connect your account to Ethereum network, you should see similar screen as below.  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/secret-note.png" alt="Screen Shot"></p>
<p>The Ethereum network connected to and what account is currently authenticated are shown at the top of the screen.  The tool hosted can only be used in Main network as the smart contract is deployed there at <a href="https://etherscan.io/address/0xb01b98a50781c454c9daa3d43eb5399ff5b604ee#code" target="_blank" rel="external">0xb01b98a50781c454c9daa3d43eb5399ff5b604ee</a>.  </p>
<p>Usage steps:  </p>
<ol>
<li>Input your own SSH-generated private key or ad-hoc generate one.  </li>
<li>Backup this private key no matter you decided to remember locally in your browser or not.  </li>
<li>Input note name and content, press Save.  </li>
<li>MetaMask will popup (this might be a little slow) and ask you to confirm the transaction to save your note to Ethereum smart contract.  </li>
<li>You only have to pay Gas for saving data in ETH blockchain.  </li>
<li>Once your transaction is submitted and confirmed, your note will be listed at the right hand side.  </li>
<li>Everytime you login using this ETH account and connected to Main net, you should see all your secrets.  Click on any item to view.  </li>
</ol>
<p><em>Notes: saving &amp; seeing data must have your private key inplace.  Viewing data doesn’t need to pay Gas.  Only changing data requires it.</em></p>
<h2 id="Donation-amp-Encouragement"><a href="#Donation-amp-Encouragement" class="headerlink" title="Donation &amp; Encouragement"></a>Donation &amp; Encouragement</h2><p>Blockchain &amp; Dapp development is really exciting.  I hope this tool can benefit any blockchain enthusiast as you.  </p>
<p>Donation of any ERC20 token to<br><code>0x713C8C77112858A3bd14A5FB380Fa0c4c5b1A8Bd</code> is greatly appreciated.  I wonder what kind of token I can get. ;)</p>
<p>Or send Bitcoin to <code>196XA8S8ZwBu7UNap2A84cLzCAKoPPGck3</code> if you are such a generous rich in blockchain world. :D</p>
<h2 id="For-developer"><a href="#For-developer" class="headerlink" title="For developer"></a>For developer</h2><p>If you are a developer, I think you can easily and freely use the source code in <a href="https://github.com/kenspirit/secret-note" target="_blank" rel="external">Github</a> to use any Test network and store your secret note there.  You have complete control and what is more important is that you do not need to pay real money for it.  Enjoy.  :D</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I am super excited that my first Ethereum blockchain Dapp product, &lt;a href=&quot;http://www.secret-note.one/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;D
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Blockchain" scheme="http://www.thinkingincrowd.me/tags/Blockchain/"/>
    
      <category term="Ethereum" scheme="http://www.thinkingincrowd.me/tags/Ethereum/"/>
    
      <category term="Dapp" scheme="http://www.thinkingincrowd.me/tags/Dapp/"/>
    
      <category term="Smart Contract" scheme="http://www.thinkingincrowd.me/tags/Smart-Contract/"/>
    
      <category term="IPFS" scheme="http://www.thinkingincrowd.me/tags/IPFS/"/>
    
      <category term="Web3" scheme="http://www.thinkingincrowd.me/tags/Web3/"/>
    
  </entry>
  
  <entry>
    <title>照顾好你自己，和你爱的人</title>
    <link href="http://www.thinkingincrowd.me/2018/01/20/take-good-care-of-yourself-and-the-ones-you-love/"/>
    <id>http://www.thinkingincrowd.me/2018/01/20/take-good-care-of-yourself-and-the-ones-you-love/</id>
    <published>2018-01-20T08:34:02.000Z</published>
    <updated>2018-04-10T08:46:23.594Z</updated>
    
    <content type="html"><![CDATA[<p>上周无聊的时候，又在翻着自己的硬盘看有什么美剧没看过的。在众多没看过的存货里面，也没什么头绪要看什么好，就按字母顺序，看了目录下第一个：「13 Reasons Why」。当然，它的名字也是有那么一点神秘和吸引。  </p>
<p>这个美剧有 13 集，说的是美国一所高中内的一些学生之间的“校园霸凌（bullying）”事件。里面的一些霸凌事件并不是很严重的事情，甚至有些根本算不上事，但是随着一系列事情的发生，女主最后还是选择割腕自杀。  </p>
<p>我们没法说清，到底是哪件霸凌事情导致了这个结果。即便你认为，最后的强暴是压死骆驼的最后一根稻草，但是，如果她有很好的朋友和值得信赖的关系在支持她，可能即便承受如此恶劣的事情，她也能撑过去。  </p>
<p>我以前一直不懂，为什么有些人会自杀，或者有深度抑郁。但是，慢慢地，我觉得那并不是不能理解的事情。并不是说我像武志红那样，曾经体验过和走出来。只是，在更多学习和了解心理学的知识，和一个人在异地的状况，让我更能感受到自己的感觉。以前的我肯定无法想象，我能那样感受到自己的那份孤独感，和允许它在身体流动，然后放纵地哭出来。悲伤并不是一件坏事，哭当然也不是。或许你们还记得迪士尼的那个动画片「头脑特工队」，头脑里的情绪小人忧忧，一开始最不受待见，但是后来却是它治愈了女主。所以，<strong>如果一些情绪没有被发现，接纳和释放，可能真的就会造成严重的后果</strong>。  </p>
<p>当然，仅仅接纳自己的情绪和找方法来释放，可能也不足以解决所有问题。或者说，有时独自一人是很难做到完全释放自己的负面情绪和死亡能量的。「头脑特工队」里的女主，失声痛哭的时候，是得到她父母在身旁的支持。「13 Reasons Why」的女主，最后是一直没有找到任何依靠，才选择自己独自承受和结束。所以说，<strong>稳健的，有支撑性的关系，对个人的心理健康，和面对逆境也非常必要</strong>。  </p>
<p>看这美剧的时候，蝴蝶效应这个词一直出现在我的脑里。人的一生，都是一系列的决定和选择造成的。你无法知道自己的哪一个小错误，最后可能被放大到多少倍而产生严重的后果。你无法知道哪句话，哪个行为，甚至眼神，把你关系中的另一方给推开。一点点地，最后无法挽回。  </p>
<p>当然，你也不可能每做一件事情，就担心这，担心那。只是，如果你一旦发现自己曾经做了错事，<strong>给别人造成伤害，就应该毫不犹豫地诚心道歉和补偿，而不是想当然地让它慢慢淡化</strong>。虽然伤害无法逆转，就像拔掉木板上的钉子也还有留下的伤痕，再也无法回到完好的状态。但是，诚心的回馈和补偿，能为伤痕涂上一层保护层，减轻和防止后续伤害。  </p>
<p>同时，你也可以<strong>更主动去留意你爱的人</strong>，爱人，孩子和父母。他们可能心里默默承受着一些苦楚。如果你能察觉，陪伴在他们身旁，主动问一句“你还好吗？”，“有什么需要帮忙的？”，那些苦楚也许就不会成为无法承受之重。  </p>
<p>2017 已经过去，如果说要做一个年终总结，我可以说，我很庆幸当时决定来北京，并孤独地过了那么长时间。这份孤独，让我成为一个更健全的人。  </p>
<p>踏入 2018 年，按照李笑来的 7 年是一辈子的说法，我已经活了 5 辈子了。当初在「<a href="http://www.thinkingincrowd.me/2015/12/31/2015-retrospect-and-2016-goal-setting/">2015 年总结与展望</a>」的时候说：“希望 2018 年，也就是我的下一个七年，能有一些较明显的转变。” 看来，愿望是在意料之外，也是好的方面达成了。希望这个更健全的人，未来能更好地照顾自己，和他爱的人。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周无聊的时候，又在翻着自己的硬盘看有什么美剧没看过的。在众多没看过的存货里面，也没什么头绪要看什么好，就按字母顺序，看了目录下第一个：「13 Reasons Why」。当然，它的名字也是有那么一点神秘和吸引。  &lt;/p&gt;
&lt;p&gt;这个美剧有 13 集，说的是美国一所高中内的
    
    </summary>
    
      <category term="Psychology" scheme="http://www.thinkingincrowd.me/categories/Psychology/"/>
    
    
      <category term="Relationship" scheme="http://www.thinkingincrowd.me/tags/Relationship/"/>
    
      <category term="Love" scheme="http://www.thinkingincrowd.me/tags/Love/"/>
    
  </entry>
  
  <entry>
    <title>数据的一致性只和数据库有关系吗？</title>
    <link href="http://www.thinkingincrowd.me/2017/12/13/is-data-consistency-only-about-db/"/>
    <id>http://www.thinkingincrowd.me/2017/12/13/is-data-consistency-only-about-db/</id>
    <published>2017-12-13T14:13:52.000Z</published>
    <updated>2018-04-10T08:46:23.592Z</updated>
    
    <content type="html"><![CDATA[<p>数据库的 <a href="https://en.wikipedia.org/wiki/ACID" target="_blank" rel="external">ACID</a>，应该所有后端程序员都听说过，也是我们必须了解的知识。ACID 里面的 C 就是 Consistency（一致性）。  </p>
<p>但是，一致性仅仅是 C 吗？从一个普通用户角度来考虑，当然不是。用户角度的一致性，应该是数据库实现了 ACID 后的效果。用现实的例子来说明就是：  </p>
<p>我发起银行转账，不能是我帐号的钱减少了，但是接收方却没收到；不能说银行职员能看到双方的钱是对的，但是用户自己看到的不对；不能说我刚刚看到的帐是对的，另一个时候，或者去另一台机器，或者换另一个方式查就不对了。  </p>
<p>那我们开发人员，是不是只要利用数据库提供的 ACID 特性，就能达到用户想要的效果呢？要注意什么呢？  </p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="关系型，单机"><a href="#关系型，单机" class="headerlink" title="关系型，单机"></a>关系型，单机</h3><p>在单机使用 RDBMS 数据库如 Oracle、MySQL、PostgreSQL 的情况下，数据库本身提供的 ACID 机制，已经能基本保证数据操作后的完整和一致性了。开发人员要做的，只是确保要维持数据一致性的变更操作代码，同在一个 transaction 里面。我刚工作的时候，当时还是用原始的 JDBC 连接 Oracle，还要手动打开关闭数据库 connection 的连接，统一 commit，或者出错后 rollback。现在，Spring 等框架已经能够用 AOP 和 Annotation 的方式来标注 transaction 的范围。  </p>
<h3 id="非关系型，单机"><a href="#非关系型，单机" class="headerlink" title="非关系型，单机"></a>非关系型，单机</h3><p>最近几年流行的 NoSQL，像 MongoDB, Redis，它们的 ACID 就不一样了。它们并不是 ACID compliant 的。MongoDB 的 ACID 是 Document 级别的。也就是说，一个数据操作，只能保证一个 Collection 里面的一个 Document 上的所有数据改动是同时成功和失败。假设一个数据操作涉及多 Document 的变动，比如用了 <code>multi: true</code> 参数，或者更改不同 Collection 的 Document，这些改动都不能保证所有 Document 的更改同时成功，或者同时失败。而 Redis 的 Transaction 就更不一样了。  </p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>在 Monolithic system 里面，数据库多数是单机。即便为了灾备需求，或者支持读写分离，甚至声称异地多活的系统，也只是启用了数据库的主从复制功能（ Master-Slave 模式的 replication ）。一般的主从复制，主库的数据和从库的数据肯定会有延时。即便是使用 Master-Master 和实时同步机制，也有可能有延时，或者数据冲突。如果强制使用更严格的一致性写入确认，如 MongoDB 的 Write Concern 设置为 majority 或者 jornal 的话，数据库的性能又会有很大的影响。  </p>
<p>我这方面的经验不多，而且现在还有像新出的 Google Spanner 这样的全球分布式，同步复制的 NewSQL 数据库，需要更多了解一下。欢迎大家给意见和指正。  </p>
<h2 id="外部组件或系统"><a href="#外部组件或系统" class="headerlink" title="外部组件或系统"></a>外部组件或系统</h2><p>可以看到，仅仅利用数据库提供的 ACID 支持，也不是一定能达到用户想要的一致性效果的。而且，很多时候，一些用户感知的一致性，背后还涉及到数据库以外的系统。  </p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存，可能会是为了解决性能问题，最早引入的组件了。但是，一旦引入缓存，数据的一致性就有可能更容易有偏差，即便是在使用单机服务器的情况下。在文章「<a href="http://www.thinkingincrowd.me/2017/05/02/cache-and-business-characteristics/">业务与缓存</a>」里面，提到的缓存失效和更新的策略，是影响数据一致性的重要因素。  </p>
<h3 id="外部系统"><a href="#外部系统" class="headerlink" title="外部系统"></a>外部系统</h3><p>有些时候，当数据发生改动时，我们还需要通知外部系统，比如，用户注册成功后发送邮件，或短信通知；给用户打款后，发送微信，或短信通知；SOA 架构下，上游系统的数据改变后，需要通知下游系统等。这时候，用户角度的数据一致性，其实还包含了这些外部系统的相应操作，也应该被触发，被体现。内部系统的数据变动，和外部系统的反应，如何能保持一致？能保持一致吗？  </p>
<p>在上一家公司的时候，我们利用 Oracle 的 XA Transaction 支持，来尽量确保数据库的改动，能和 JMS 的消息发送 保持同时成功或者失败。但是，如果数据改动后要发邮件，短信，或微信通知，这些现在没类似的支持，是极有可能无法保持一致的。  </p>
<p>很巧的是，公众号「程序人生」最新的文章「<a href="http://mp.weixin.qq.com/s/zvviHdTpXaeHKLhtGVx26w" target="_blank" rel="external">不要等客户来通知问题</a>」里面的摩拜单车解锁问题，刚好为我提供了一个很好的例子。作者扫码后，单车锁一直没开，但是又认为作者已经成功开锁使用了。所以，它一直不让作者自己操作结束，又不让他重新扫新的单车。最后，要等问题被反应到摩拜开发人员内部，才得以解决。这个状况发生的原因可能是，手机端上传单车开锁指令后，后台的数据状态已经标记为使用状态了，甚至开锁指令都已经下达到自行车上了，但是自行车锁就是没有成功打开。你说，这里数据一致了吗？对系统来说可能勉强算是，但对用户来说就不是了。  </p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然那么多情况可能导致数据的不一致，怎么解决呢？  </p>
<h3 id="恰当的建模"><a href="#恰当的建模" class="headerlink" title="恰当的建模"></a>恰当的建模</h3><p>使用 NoSQL 和 RDBMS 建模的时候，要考虑的因素很不一样。MongoDB 更多是考虑嵌套，冗余，而不是追求更高的范式要求。这在「<a href="http://www.thinkingincrowd.me/2016/11/13/Node-js-Wechat-Web-App-Tutorial-Data-Modeling/">Node.js 微信后台搭建系列 - 数据建模</a>」，「<a href="http://www.thinkingincrowd.me/2017/11/11/model-evolvement-for-a-simple-payment-system/">一个简单的支付业务与模型演变</a>」一文里面也稍微提过。  </p>
<h3 id="两阶段提交（2PC）"><a href="#两阶段提交（2PC）" class="headerlink" title="两阶段提交（2PC）"></a>两阶段提交（2PC）</h3><p>两阶段提交（<a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="external">Two-Phase Commit</a>）是一种协议和分布式算法，来协调多操作的原子性。前面说的 Oracle XA Transaction 就是利用 2PC 实现的。MongoDB 里面没有提供多 Document 更改的原子性支持，所以一些场景可以通过在 <a href="https://docs.mongodb.com/manual/tutorial/perform-two-phase-commits/" target="_blank" rel="external">MongoDB 里面用 2PC</a> 来实现多 Document 的 Transaction 确保数据的一致性。但是，在业务复杂的情况下，自己模拟 2PC 还是很麻烦的。  </p>
<h3 id="任务重试"><a href="#任务重试" class="headerlink" title="任务重试"></a>任务重试</h3><p>出错重试，应该是很常见的操作了。但是，重试的处理，有几个地方是要注意的：  </p>
<ul>
<li>幂等原则  </li>
<li>同步还是异步？  </li>
<li>重试次数  </li>
</ul>
<p>出错能否重试，要看这个重试的逻辑是否幂等（Idempotency），或者多次执行都生效的影响到底严不严重。  </p>
<p>先说影响。比如说你的系统支持用户提现，成功后需要发通知。用户设置的通知有微信，短信，和邮件通知（这是有多担心钱被偷）。假设你实现的重试任务代码，负责所有通知（包括微信，短信，邮件等），而不是微信，短信，邮件等有各自的独立任务。那么在发通知的时候，假如第一次发微信的时候失败了，但是短信邮件成功了，这个重试任务如果还是被标记为失败。下次重试的时候，它就会重复发送了一些通知。这个任务多次执行的影响，对用户来说可能很烦，但是不大。  </p>
<p>另一个是幂等。幂等的意思是一个操作如果被多次执行，其结果和第一次执行后是相同的。上面的发通知的例子，如果我们定义结果是能发通知的话，它是幂等的。但是，如果结果是发且仅发一次的话，它就不是幂等了。关于幂等，我以前学 AngularJS 的时候就被自己坑了一次，详情可看「<a href="http://www.thinkingincrowd.me/2013/02/02/expression-in-angularjs-must-be-idempotent-and-for-multiple-calls/">Expression in AngularJS must be idempotent and for multiple calls</a>」。公众号「嘀嗒嘀嗒」的安姐近期一篇「<a href="https://mp.weixin.qq.com/s/EDkuMW5-hdIxs2GXMFnj_Q" target="_blank" rel="external">每个工程师都应该了解的：聊聊幂等</a>」更详细说明幂等和解决方法，我就不重复了。  </p>
<p>还有一个要考虑的是，选择同步还是异步重试。这取决于业务场景，和出错部分的严重程度。必须一致的关键数据部分出错，要么中止回滚，同时警告用户，要么只能同步重试处理。但是，如果是在 Node.js 这样的单线程服务，可能就不应该重试，或者要严格控制重试次数。要不然，除了当前用户受影响，说不定共用服务的其它用户也遭殃。  </p>
<h3 id="操作顺序"><a href="#操作顺序" class="headerlink" title="操作顺序"></a>操作顺序</h3><p>如果说数据不一致无法完全避免，那如何最大化避免数据不一致，并在出错后有迹可循呢？  </p>
<ul>
<li>先处理出错可能性低的部分  </li>
<li>先内部系统，再外部系统  </li>
<li>先记录操作唯一性，再标记不同状态  </li>
</ul>
<p>假如一个系统允许用户提现到微信零钱，这个系统是 MongoDB 作为后台，并且模型里面有 transaction 这样的流水纪录表，也需要更新用户表 user 里面的余额。应该怎么操作呢？  </p>
<ol>
<li>从用户表 user 中减少提取的额度  </li>
<li>把这个额度记录到 transaction 中的一条包含唯一性的流水记录里，标记处理中  </li>
<li>通过微信 API 通知把提取额度转到用户零钱 </li>
<li>成功后把 transaction 中的流水记录标记成功，否则标记失败  </li>
</ol>
<p>这里涉及 4 步操作。假如每一步都有可能出错，安排 1 和 2 两步在前面是因为同是内部系统，出错可能性低一些。即便第 1 步成功，但是第二步失败，用户的余额还是可以通过 replay transaction 里面所有的收支记录来刷新，或者这里做特定异常处理。  </p>
<p>这里面的第 3 步，是外部系统，涉及网络操作，所以是最有可能出错的。所以第 3 步前必须先有操作记录，而且有唯一性（比如订单号）标识。出错后可以通过此标识，像微信查询该转账操作是否成功。  </p>
<p>最后才更新流水记录的状态，也是为了能保证最终的完整性，和提供异常数据监控的可能。  </p>
<h3 id="异常数据主动监控，补偿"><a href="#异常数据主动监控，补偿" class="headerlink" title="异常数据主动监控，补偿"></a>异常数据主动监控，补偿</h3><p>一般来说，如果所有的操作，都是系统内部触发，那么出错的时候，都应该有记录，并且可以重试。但是，像前面提到的摩拜单车的例子，解锁部分的硬件操作，锁有没有打开这个状态并没有反馈回内部系统，导致不一致的状态已经脱离了内部系统范畴。这就不是重试能解决的了。异常数据的主动监控和补偿就派上用场了。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库的 &lt;a href=&quot;https://en.wikipedia.org/wiki/ACID&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ACID&lt;/a&gt;，应该所有后端程序员都听说过，也是我们必须了解的知识。ACID 里面的 C 就是 Consist
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="ACID" scheme="http://www.thinkingincrowd.me/tags/ACID/"/>
    
      <category term="Consistency" scheme="http://www.thinkingincrowd.me/tags/Consistency/"/>
    
      <category term="Atomicity" scheme="http://www.thinkingincrowd.me/tags/Atomicity/"/>
    
      <category term="Database" scheme="http://www.thinkingincrowd.me/tags/Database/"/>
    
      <category term="Distributed" scheme="http://www.thinkingincrowd.me/tags/Distributed/"/>
    
      <category term="Idempotency" scheme="http://www.thinkingincrowd.me/tags/Idempotency/"/>
    
      <category term="Architecture" scheme="http://www.thinkingincrowd.me/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>技术人眼中的实业与纯互联网业务差异</title>
    <link href="http://www.thinkingincrowd.me/2017/12/07/business-diff-between-industry-and-internet-from-engineer-pov/"/>
    <id>http://www.thinkingincrowd.me/2017/12/07/business-diff-between-industry-and-internet-from-engineer-pov/</id>
    <published>2017-12-07T10:22:13.000Z</published>
    <updated>2018-04-10T08:46:23.591Z</updated>
    
    <content type="html"><![CDATA[<p>工作那么久以来，前面一大半辈子都是做 J2EE 项目，参与的都是实业企业的业务系统。最近这一两年，接触了互联网产品的开发，我对这两领域的业务差异，以及它们对技术开发人员的影响有更切实的体会。（这里提及的纯互联网，是指不需要和实体行业接轨的领域，比如消息通信，游戏，社交，工具等）  </p>
<h2 id="无论哪个领域，都应了解业务"><a href="#无论哪个领域，都应了解业务" class="headerlink" title="无论哪个领域，都应了解业务"></a>无论哪个领域，都应了解业务</h2><p>我记得很早就有争论，技术人员是否有必要关心和理解业务。技术人员是否只需要深入技术细节，提高开发技能的深度和广度就可以了？  </p>
<p>我的观点是，假如你实现的系统，是和人打交道的，而不是单纯的硬件和机器，那么，你就需要接触业务。因为你做的系统，是人的操作工具，解决他可感知的问题。<strong>理解业务，和其它增值的软技能，如写作、演讲和沟通是一样的。而且，从技术的角度来说，只有你理解了业务，才能很好评估技术难度，并做出合理的系统设计和架构。</strong>  </p>
<ul>
<li><p>「<a href="http://www.thinkingincrowd.me/2017/05/02/cache-and-business-characteristics/">业务与缓存</a>」这篇文章大致介绍了如何结合业务来设计和使用缓存。  </p>
</li>
<li><p>「<a href="http://www.thinkingincrowd.me/2017/11/29/tingting-multi-region-architecture/">听听系统的多地部署改造</a>」这篇文章也举例说明了业务对性能的影响，接口权重取舍，以及任务异步化等。  </p>
</li>
</ul>
<h2 id="业务性质的差异"><a href="#业务性质的差异" class="headerlink" title="业务性质的差异"></a>业务性质的差异</h2><ul>
<li><p>实业企业的业务需求，是为了把实业往系统迁移，以简化流程，保证数据准确性，提升协作能力等目标为主。因为受产业现状约束，调整空间变化不大，功能实现路径相对单一。  </p>
</li>
<li><p>纯互联网的业务需求，即便功能或者要解决的问题类似，实现路径相对多样，发挥的空间较大。  </p>
</li>
</ul>
<h3 id="需求灵活度和空间"><a href="#需求灵活度和空间" class="headerlink" title="需求灵活度和空间"></a>需求灵活度和空间</h3><p><strong>企业系统的需求</strong>来源，小的层面是一线业务执行者，对功能和效率的需求；大的层面是老板对整体业务的规划。一般情况下，企业系统的需求到达开发阶段了，应该已经在业务部门达成共识。<strong>根据业务流程的指引，功能相对明确。但是，缺陷也明显，因为在没有业务流程配合的情况下，系统是没法优化的</strong>。当初我在航运物流公司的时候，曾经参与一些探索性项目。有些想法虽然美好，但是落地很难，因为业务配合很难。  </p>
<p><strong>纯互联网行业就不一样了。功能的探索空间大，需要更多的从人性，心理方面考虑，更容易突破常规做新尝试</strong>。  </p>
<p>比如说，在线直播课程的售票功能，仅仅买卖票吗？要分开提问票和普通票吗？到底是分开，还是不分开好，说不准。知乎 Live 一开始是先买先得，限量。为什么一开始我们听听要设置不同价格的提问票呢？  </p>
<ol>
<li>增加稀缺感  </li>
<li>让主讲人多赚一些钱  </li>
<li>保证问题的质量  </li>
<li>技术权衡。因为我们一开始的直播间，是在微信公众号里面。主讲人只能通过一条网址链接查看留言列表。如果用户发言的数量太多，质量不好，对主讲人是一个挺大的负担。  </li>
</ol>
<p>可是为什么后面又取消了呢？  </p>
<ol>
<li><p>一些主讲人反馈不希望做出区分。因为对于这些提问是否回答，他们是有压力的。即便卖票时已经声明不承诺回答，但是主讲人感觉还是不好。尤其是当一些人故意提问怼主讲人，或者提一些不方便回答的问题时，他们就会更尴尬。  </p>
</li>
<li><p>提问的质量，真的不是给了钱的人，就会好好思考，再提出高质量问题的。  </p>
</li>
<li><p>后来改版后，主讲人同样能在直播间操作，并且实现了协作讲师选取精选留言，和消息限流的功能，发言权限也就放开了。  </p>
</li>
</ol>
<h3 id="有效性评估"><a href="#有效性评估" class="headerlink" title="有效性评估"></a>有效性评估</h3><p>当初在实业企业的时候，我也经常抱怨用户和 BA 怎么经常改需求，还提得那么晚。但是，老实说，实业企业的需求，怎么变都没有互联网那么快。因为，实业的业务流程，涉及既定利益体的协作，是没那么容易变动的。它们制约了需求的可变范围，当然这也是被互联网行业降维打击的原因。  </p>
<p>纯互联网行业约束少，需求更新快，可能让开发更抓狂。机会和风口以来，可能就要马上跟进试探。这个时候，用临时方案，还是设计完整的功能路径，就必须小心考虑了。因为，如果临时的方案多了，就会把系统搞得千疮百孔。但是，假如每个试探的方案都像常规功能那样来设计，不仅可能拖慢进度，还可能最后发现方向不对，废弃成本高。  </p>
<p>我们也吃了这方面的苦头。当初系统实现的工会模式，以及为了让大V节省时间而做的转让直播的功能，后来其实用途不大。但是这两个功能对系统逻辑，开发和测试时间影响还蛮大。  </p>
<p><strong>如何评估一个需求的有效性，精简地设计易扩展的模型，让临时方案的代码侵入性小，以及平衡开发效率，是非常大的问题</strong>。  </p>
<h3 id="责任人确定"><a href="#责任人确定" class="headerlink" title="责任人确定"></a>责任人确定</h3><p>责任人是什么意思？要为什么负责？  </p>
<p>责任人是业务功能的用户吗？可以说是，但也不全是。  </p>
<p>比如说，我们系统最开始有一个心愿单的功能，目的是为了收集用户心仪讲师的讲座或者课程。这功能乍一听很有用，也很快就加上了。但是，后期这些数据是谁看呢？产品？还是运营？怎么看和怎么拿出来分析？这都就是责任人要负责的事情，不是说功能加了就算了。由于责任人前期并没有明确，收集的数据并没有很好地发挥作用，功能最后也砍了。同理，像数据报表，用户反馈等类似的功能，也是需要非常明确地指定责任人的。  </p>
<p><strong>当责任人不清晰的时候，可以说任何开发出来的功能，最后都会被慢慢遗弃。所以，一个功能要不要做，怎么做才好用，首先应该确认责任人是谁。</strong>  </p>
<p>这个问题在实业企业也会发生，但在纯互联网行业更常见，尤其在初创期。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作那么久以来，前面一大半辈子都是做 J2EE 项目，参与的都是实业企业的业务系统。最近这一两年，接触了互联网产品的开发，我对这两领域的业务差异，以及它们对技术开发人员的影响有更切实的体会。（这里提及的纯互联网，是指不需要和实体行业接轨的领域，比如消息通信，游戏，社交，工具
    
    </summary>
    
      <category term="Think" scheme="http://www.thinkingincrowd.me/categories/Think/"/>
    
    
      <category term="Business Logic" scheme="http://www.thinkingincrowd.me/tags/Business-Logic/"/>
    
  </entry>
  
  <entry>
    <title>听听系统的多地部署改造</title>
    <link href="http://www.thinkingincrowd.me/2017/11/29/tingting-multi-region-architecture/"/>
    <id>http://www.thinkingincrowd.me/2017/11/29/tingting-multi-region-architecture/</id>
    <published>2017-11-29T00:29:02.000Z</published>
    <updated>2018-04-10T08:46:23.590Z</updated>
    
    <content type="html"><![CDATA[<p>很早就想过写这篇文章了，一直没动手。  </p>
<h2 id="直播系统卡壳"><a href="#直播系统卡壳" class="headerlink" title="直播系统卡壳"></a>直播系统卡壳</h2><p>在一块听听刚上线不久，我们就迎来了一个 6W 人的直播。当天，直播开始时间前后 10 分钟那个区间，系统是真的卡的不行。  用户打不开页面，进不了直播间，老师发言也发不出去。  </p>
<p>当时真的是心急火燎，但是又没有什么能做。真的只能慢慢等时间流逝，压力下来，进直播间的人都稳定了，系统也就平稳了。是什么导致那么狼狈呢？  </p>
<h3 id="时间和规划不足"><a href="#时间和规划不足" class="headerlink" title="时间和规划不足"></a>时间和规划不足</h3><p>整个系统国庆后开始开发，11月12日功能才基本完整上线并迎来第一个直播，这个大直播（12月13日）就来了。这期间还忙着需求开发，没足够时间做性能测试。  </p>
<h3 id="不必要的接口开销多。"><a href="#不必要的接口开销多。" class="headerlink" title="不必要的接口开销多。"></a>不必要的接口开销多。</h3><p>用户有两个途径进入直播间，一个是直达直播间的微信通知的消息链接，另一个是「我的」菜单按钮。当时「我的」个人页面，前端一共调用 4 个接口：  </p>
<ol>
<li>获取用户资料</li>
<li>获取用户发起的直播  </li>
<li>获取用户购买的直播  </li>
<li>获取其它更多相关的直播  </li>
</ol>
<h3 id="频繁查写库，没充分利用缓存"><a href="#频繁查写库，没充分利用缓存" class="headerlink" title="频繁查写库，没充分利用缓存"></a>频繁查写库，没充分利用缓存</h3><p>我们没很好利用缓存。而且，一开始是区分提问和非提问票的。在用户冲入直播间（或者刷新直播间页面）的时候，我们都必须获取用户提问发言次数，看是否已经超出限额。这些操作当时都是直接读写数据库，导致缓慢。  </p>
<h3 id="业务导致网络开销大"><a href="#业务导致网络开销大" class="headerlink" title="业务导致网络开销大"></a>业务导致网络开销大</h3><p>我们当时的直播间做的很实诚，每进退一个人，都在上面显示实时人数。这个人数变动的消息广播，对网络影响相当大。  </p>
<h3 id="不必要实时显示的数据"><a href="#不必要实时显示的数据" class="headerlink" title="不必要实时显示的数据"></a>不必要实时显示的数据</h3><p>我们的直播间还有一个打赏榜，当时的打赏情况实在是火热，很多人频繁刷打赏榜，实时从数据库拉取数据。另一个加重服务压力的方面，用户每进出一次打赏榜就要出直播间和再返回一次，导致更频繁的进入直播间请求。  </p>
<h2 id="优化之路"><a href="#优化之路" class="headerlink" title="优化之路"></a>优化之路</h2><p>经此一役，并听说罗永浩又要来直播（1月16号），量可能更大，我们就迅速准备调整了。  </p>
<h3 id="业务调整"><a href="#业务调整" class="headerlink" title="业务调整"></a>业务调整</h3><p>业务功能，是有可能对性能影响很大的。当然，不是说有了性能问题，就只能调整业务。而是，如何恰当地在业务功能上做出可接受的妥协，使得性能优化更可行。  </p>
<p>曹政公众号的文章也举了类似的例子，搜索引擎的翻页功能。百度最多 49 页，Google 更少，6 页就没了。其实搜索根本没必要支持很多页，因为真正的用户，翻三四页没找到要的信息就会调整关键字了，怎么可能翻上百页。  </p>
<p>我们去除了提问票，就没有必要在进入直播间的时候写数据库了。当然，调整的主要原因不是因为性能，而是产品和业务的考虑。具体原因有机会再分享。假设还是有提问需求，那么，检查提问次数的逻辑，可以调整为前端缓存检查，没太大必要那么严格的在进入直播间的时候，通过后端检查。  </p>
<h3 id="接口控制"><a href="#接口控制" class="headerlink" title="接口控制"></a>接口控制</h3><p>如前面所说，根据页面功能的规划，我们可以确定不同区域的重要程度和降级方案。然后，通过接口动态屏蔽的功能，前端可以在特殊时候减少网络请求。  </p>
<p>前面提到的4个接口，接口1 其实前端可以使用客户端缓存；接口2 只有少数是主讲人的用户才需要；接口4 是非常耗费资源，计算复杂的接口。但是获取其它更多相关的直播，在大直播来临的时候，其实可以完全屏蔽，因为这个时候多数用户关注点不在这里。  </p>
<h3 id="减少网络开销"><a href="#减少网络开销" class="headerlink" title="减少网络开销"></a>减少网络开销</h3><p>面临大规模访问时候，网络数据的大小和频率会非常影响系统稳定性。  </p>
<p>如前面所说，socket 服务器的实时人数的消息广播，真的很占网络资源。后来业务上也觉得这个信息不太需要，也就直接去掉了。去掉了后，Socket 可支撑的同时在线人数马上上去了。  </p>
<p>另一个是进入直播间后 http 服务器返回的数据，也作出精简。只有第一眼用户需要看到的数据，才拿出来。一些其它支持用户其它操作的数据，可以等用户需要的时候，再让前端发请求获取。  </p>
<h3 id="增加缓存，非实时数据异步处理"><a href="#增加缓存，非实时数据异步处理" class="headerlink" title="增加缓存，非实时数据异步处理"></a>增加缓存，非实时数据异步处理</h3><p>打赏榜的数据，在大直播刚开始时，其实并没有太强烈的实时聚合打赏数据排名的要求。所以，后期我们通过异步任务后台聚合，放缓存，前端直接从缓存拿数据。  </p>
<p>除了后端优化，前端方面，我们还可以动态禁止查看打赏榜。进入打赏榜的时候，不再需要离开直播间，而是弹出一个新的层，减少直播间进出的情况，带来不必要的网络请求。  </p>
<h3 id="多地部署，读写分离"><a href="#多地部署，读写分离" class="headerlink" title="多地部署，读写分离"></a>多地部署，读写分离</h3><p>虽然，不是说性能不行，就马上要横向扩展和实现多地架构，但当时青云的北京区服务器，华南，华东一些偏远地区平时访问也有点慢，网络有时还会抽风。多地部署可以让全国不同省市的人，访问最近的服务。而且，罗永浩直播的人数真是不好预估，所以，我们还是担心只有一个区的服务器和网络可能撑不住。  </p>
<p>下面是一开始的服务架构：  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/tingting-old-architecture.png" alt="Old Architecture"></p>
<p>因为我们实现多地部署要达成的最基本的目标是：增加缓存，每个分区独立运作，承担各自的压力，互不影响，也就是按区域横向扩展。所以，每个只读的分区，应该要有独立的 Redis，HTTP Server 和 Socket Server。  </p>
<p>增加缓存，多地部署后要面对的最直接的问题是：  </p>
<ul>
<li>什么数据适合放在缓存？  </li>
</ul>
<p>直播详情，用户购买记录等一些高频查询数据，我们都放在缓存里。这个问题在以前的文章「<a href="http://www.thinkingincrowd.me/2017/05/02/cache-and-business-characteristics/">业务与缓存</a>」有更详细的介绍，这里就不重复了。  </p>
<ul>
<li>有数据改动的时候，如何失效各分区的缓存呢？  </li>
</ul>
<p>目前，我们依赖的是 Redis 的 Pub/Sub 机制。主区有新的数据改动的时候，publish 消息到特定的 channel。各个独立分区的 Subscriber 监听到消息通知，就失效掉特定的缓存。  </p>
<p>最后，新的服务架构如下：  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/tingting-new-architecture.png" alt="New Architecture"></p>
<p>MongoDB，HTTP Server（写）这些负责写的部分，和 Redis (PubSub) 是公共的，其它部分其实是不同分区独立拥有的相同的组件。我在上面标注主讲人，下面标注普通用户，只是为了容易看一些，它们实际是完全一样的。这样的架构，有需要的时候，复制不同的读分区出来服务不同地区的用户就比较容易了。  </p>
<h2 id="还能做什么？"><a href="#还能做什么？" class="headerlink" title="还能做什么？"></a>还能做什么？</h2><p>现在这个架构，服务器之间的通信还是挺复杂的，网络占用应该还有更多优化空间。当时罗永浩直播刚开始的时候，某些用户还出现了“已经在其它终端登录”的警告而被踢出直播间。可是这个问题一直没时间细查。  </p>
<p>这个架构，其实还不是真正意义的异地多活，和分布式系统，因为数据库和写服务器还是单一的。目前我们做这个的话，成本还是太高。不过，或许以后真的要再一次重构，也应该是服务的细分，SOA 更靠谱一些。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早就想过写这篇文章了，一直没动手。  &lt;/p&gt;
&lt;h2 id=&quot;直播系统卡壳&quot;&gt;&lt;a href=&quot;#直播系统卡壳&quot; class=&quot;headerlink&quot; title=&quot;直播系统卡壳&quot;&gt;&lt;/a&gt;直播系统卡壳&lt;/h2&gt;&lt;p&gt;在一块听听刚上线不久，我们就迎来了一个 6W 人的直
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Distributed" scheme="http://www.thinkingincrowd.me/tags/Distributed/"/>
    
      <category term="Architecture" scheme="http://www.thinkingincrowd.me/tags/Architecture/"/>
    
      <category term="Cache" scheme="http://www.thinkingincrowd.me/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>硬分叉，可能真的比 ICO 更好</title>
    <link href="http://www.thinkingincrowd.me/2017/11/19/hard-fork-might-really-be-better-than-ico/"/>
    <id>http://www.thinkingincrowd.me/2017/11/19/hard-fork-might-really-be-better-than-ico/</id>
    <published>2017-11-19T06:05:41.000Z</published>
    <updated>2018-04-10T08:46:23.589Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章写作的出发点，其实是因为看了曹政老师的「<a href="https://mp.weixin.qq.com/s/qgRPIGvMK44CvyTxvELDig" target="_blank" rel="external">谈谈比特币分叉</a>」有感而发。或许应该说，因为疑惑为什么一贯克制，客观的他，写出比较主观和动机论的文章。前面一大段是尽可能写的详尽的利益声明。不熟悉我的人，应该看仔细。熟悉的，闲烦可以直接跳后面「为什么」那部分。  </p>
<h2 id="利益声明"><a href="#利益声明" class="headerlink" title="利益声明"></a>利益声明</h2><h3 id="我和比特币的关系"><a href="#我和比特币的关系" class="headerlink" title="我和比特币的关系"></a>我和比特币的关系</h3><p>我几乎从来没有对比特币发过任何评论，甚至我最开始买比特币的时候，我老婆都不知道，而且她还一直让我卖出去，当时我买的时候才 3000 元左右。我和我死党说的时候，他们也不怎么在意。特别是银行的朋友，更是对这种新生的东西心存疑虑。  </p>
<p>当然，坦白说，我没有很深入的去研究它，所以也不是狂热和坚定的粉丝，没有倾家荡产的买它。不像李笑来老师说的，拿法币来换它为主。所以，即便当时我买的时候它那么“便宜”（仅针对当前价格来说，以后不担保），我也还没有实现我的小目标，拥有 10 个比特币。  </p>
<p>我只是一个潜意识觉得它是好东西，但也被现实束缚着的，胆小的人。我从来没有把慢慢积攒回来的 BTC 去交易所炒，只是安安静静的放在自己的钱包，等着给自己以后养老，或者给儿子一点点小遗产吧。  </p>
<h3 id="我和李笑来的关系"><a href="#我和李笑来的关系" class="headerlink" title="我和李笑来的关系"></a>我和李笑来的关系</h3><p>我承认之前一直很欣赏（甚至崇拜，当然现在看东西比较理性了）李笑来，也正因为这样，我公众号开张的<a href="https://mp.weixin.qq.com/s/sJfPB5ShzV8eHQLTpFwduQ" target="_blank" rel="external">第一篇文章</a>（2015 年 11 月），就说是由他的文章促成了我的一些思考，并链接和引用他的文章和话，以及为他的七年就是一辈子社群打广告。  </p>
<p>并且在 2016 年 7 月，我自告奋勇，到了李笑来下面的新生大学工作，当一个「全栈工程师」。这也是他当时被很多业内人嘲笑的时候（虽然我也不太认同当时他那个说法，一年成为全栈）。我也写过一些相关的文章：  </p>
<p>「<a href="http://mp.weixin.qq.com/s/P0uO2gRGroeA3_XN8XEVbg" target="_blank" rel="external">这些年，放下，前行的点滴和感触</a>」<br>「<a href="https://mp.weixin.qq.com/s/AZ0KYUhQ9BzWQDQOPS3QEw" target="_blank" rel="external">怎么样才算得上是全栈</a>」  </p>
<p>目前我是「一块听听」公众号的后端开发者之一。这个项目当时是李笑来和 CTO 提出，并执行。  </p>
<p>我和李笑来有点关系，但也基本只是点头之交多一些，甚至只是老板和员工的关系。我在新生大学的第二年会费，都是自己交的真金白银，而不是以工作人员，需要测试或其它理由，获得会员资格。  </p>
<h3 id="我和曹政的关系"><a href="#我和曹政的关系" class="headerlink" title="我和曹政的关系"></a>我和曹政的关系</h3><p>同样，在我公众号开张的<a href="https://mp.weixin.qq.com/s/sJfPB5ShzV8eHQLTpFwduQ" target="_blank" rel="external">第一篇文章</a>，我就向我的读者，推荐了曹政的公众号。当时我对曹政了解不多，但是订阅没多久，就和大家推荐，并一直把他的置顶。  </p>
<p>虽然订阅了公众号，但自知是赞赏很少的那类人，隐约好像有那么一两次，也是一两元的样子。回头看自己，赞赏比较多的应该是 Fenng 的公众号。  </p>
<p>我的留言也不多，好像有两三次吧。第一次被曹政把留言选为精选，还特高兴。最近也在他的「<a href="https://mp.weixin.qq.com/s/jJ9jOyk--n6EfARLydHGlg" target="_blank" rel="external">关于知识付费，是的，我就是来砸场子的。</a>」留言并表明身份和表示敬佩。  </p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h3 id="曹政老师的文章主观，动机论"><a href="#曹政老师的文章主观，动机论" class="headerlink" title="曹政老师的文章主观，动机论"></a>曹政老师的文章主观，动机论</h3><p>曹政老师那篇文章前面一部分都没有问题，也很简明扼要的说明比特币的背景，现状和分叉。问题在「但这肯定不是一篇值得十万+的文章，好玩的事情在后面。」后面。  </p>
<p>不容否认，确实有好一些组织，都想参与到 BTC 上面来。既 BCC 后，比特黄金也尝试来分，李笑来也说要主导一个。  </p>
<p>但是，文章里这些阐述个人觉得比较主观，和带有揣测性质。而且还有一些带有偏向性的比喻。  </p>
<blockquote>
<p>这次主导方是由李某来担任主席的super bitcoin团队，听上去很唬人有没有，很像是比特币的核心管理团队有没有。那么，你听说过<strong>全国牙防组</strong>这个名字么？</p>
<p>这个super bitcoin基金会组织，据我所知，（当然，也许我无知，如果有，请打脸）没有参与，也没有资格参与几乎所有关于分叉方案的技术讨论和闭门会议，没有参与任何相关的核心决策和签字。但是现在，他们突然跳出来说，我们要硬分叉。</p>
<p>利益！赤果果的利益！因为他们的硬分叉方案里，除了承诺所有比特币用户会获得1：1的新货币，也就是2100万个新货币外，还会预挖21万个新货币，听上去只有1%哦，好像蛮合理的。你手里凭空多了21万个比特币（BTC）是啥概念？或者，咱们现实点，你手里多了21万个比特现金（BCC）是啥概念，比特现金的最新价格虽然比不了比特币，但也有1000美元哦？</p>
</blockquote>
<p>为什么我觉得上面的质疑是主观的？  </p>
<ol>
<li><p>首先，任何人都可以分叉的。只要你愿意，并且有资金和行动力。但是上面的言论，听起来比较倾向于认可了 BCC，后面的比特黄金，和李笑来的分叉就偏贬低的态度了。  </p>
</li>
<li><p>你如果分叉了，当然要有个名字，BCC，比特黄金，Super Bitcoin，什么都好，分叉的人喜欢就可以了啊？为什么拿全国牙防组来比喻呢？官网也没说是自己是核心团队。起名字真的不能太高调，不能用最字了？而且，他们官网明确写了团队里面有谁，如果他们当骗子，自己的压力还是实名承载了的。BCC 的团队还说是 Decentralized，都不知道是谁，有谁呢。我觉得实名这事，已经很不容易了。  </p>
</li>
<li><p>利益。没有利益谁去分叉。但是为了利益不等于讹诈骗钱。正当商家也是为了追求利益最大化的啊。学过经济学的，应该不会不同意这点。  </p>
</li>
<li><p>预挖新货币。这个目前确实是李笑来这个分叉不同的地方。但是别人的分叉，别人说了算啊。BCC 的紧急难度调整机制也同样被人诟病，这个机制是为了谁的利益可能也不好说。Super Bitcoin 在官网说明了预挖的用途：21万SBTC归基金会管理,主要用于激励早期开发者、投资生态建设、基金会运营。这个我也不觉得有问题，别人如果真的相信这个币以后的价值，自己持有和创业团队拿股份有什么区别？中本聪一开始也自己持有不少比特币啊。  </p>
</li>
<li><p>价格推定。上面一段话的最后，推定 Super Bitcoin 背后可能有的价值。Super Bitcoin 最后能发展成什么样子，真的不好说。BCC 价值 1000 美元，但是比特黄金呢，你们听说过哪个交易所支持了吗？价值多少？这里的推测似乎已经假定 Super Bitcoin 已经可以捞到很多钱了。  </p>
</li>
</ol>
<p>我觉得这篇文章真的不符合曹政以前文章的风格。具体原因是为什么当然我不知道。我也不做任何主观猜测。这里提供两篇曹政老师之前的文章让大家看看：  </p>
<p><a href="http://mp.weixin.qq.com/s/AqfF4Qsoemh8eFUa237Rwg" target="_blank" rel="external">宣泄，还是逻辑</a><br><a href="http://mp.weixin.qq.com/s/ksyyxPg2RyFgs56XrtyKMw" target="_blank" rel="external">再谈大V的套路</a>  </p>
<h3 id="硬分叉，可能真的比-ICO-更好"><a href="#硬分叉，可能真的比-ICO-更好" class="headerlink" title="硬分叉，可能真的比 ICO 更好"></a>硬分叉，可能真的比 ICO 更好</h3><p>为什么我觉得这个更好？  </p>
<p>基于我前面对自己的评价：「我没有很深入的去研究它，所以也不是狂热和坚定的粉丝，没有倾家荡产的买它」。分叉，对于我来说，是平白无故，利益可能最大化的事情。因为我可以突然多了一些其它电子货币。ICO 的话，我还要掏钱去买。  </p>
<p>如果分叉以后任何一个，甚至几个币成功了，我就赚了。  </p>
<p>但是，这里有个前提，就是我们作为普通人，不要太贪心，去炒，去轻易的拿比特币钱包的地址，和私钥去兑换其它分裂出来的币。这样很容易就会遭遇重放攻击。要兑换，也要把币转移到新的钱包后，再用旧的钱包地址去兑换。  </p>
<p>按照 Super Bitcoin 分叉的出发点：Make Bitcoin Great Again。他们是希望在上面加上各种好东西（各位可以上他们简陋的<a href="http://www.supersmartbitcoin.com/index_cn.html" target="_blank" rel="external">官网</a>看看）。纯按逻辑推理说，如果这个币真的那么好，而且很多人相信，那不是很好吗？所以，我不去质疑他是不是真的那么做，我也不去炒，就静静的等着分就可以了。  </p>
<p>而且，说实话，任何电子货币和股票其实也一样。你真正有价值的东西，你任何时候进场，都不会错过的。看你怎么看待它而已。你大可以等待币战尘埃落定，在买或者投资你觉得有价值的币。  </p>
<p><strong>严正声明，本文从来没有什么洗白李笑来，质疑曹政的意图，也不是鼓励大家买 Super Bitcoin 或者任何币。曹政老师的文章还是很有价值，我还是会一直置顶他的公众号。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章写作的出发点，其实是因为看了曹政老师的「&lt;a href=&quot;https://mp.weixin.qq.com/s/qgRPIGvMK44CvyTxvELDig&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;谈谈比特币分叉&lt;/a&gt;」有感而发。或许应该说
    
    </summary>
    
      <category term="Think" scheme="http://www.thinkingincrowd.me/categories/Think/"/>
    
    
      <category term="BTC" scheme="http://www.thinkingincrowd.me/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>一直改不了，是因为你不了解自己</title>
    <link href="http://www.thinkingincrowd.me/2017/11/19/cannot-change-because-you-donot-really-know-yourself/"/>
    <id>http://www.thinkingincrowd.me/2017/11/19/cannot-change-because-you-donot-really-know-yourself/</id>
    <published>2017-11-19T04:44:27.000Z</published>
    <updated>2018-04-10T08:46:23.587Z</updated>
    
    <content type="html"><![CDATA[<p>现在，我一直在听两个心理学课程。</p>
<p>一个是李松蔚的「洞悉相处之道」。这个课程给我打开了关系层面如何相处和看待一些问题的新视角。我以前从来不会，也没意识到这个问题。它可以说是给了我一次重生吧，所以，我也到处推荐给朋友。李松蔚一开始是学数学的，只是考北大后被调到心理学。他拥有很浓重的理科生范和思维方式，他的一些知乎 Live 举的例子，也很理科化。所以，整个课程给我的感觉，是相对比较理性的看待关系层面的问题。估计这也是一开始吸引我一个理科生的原因吧。大胆猜测，这也是他偏向系统论，系统家庭治疗的原因。  </p>
<p>另一个课程是武志红在得到的心理学课，「拥有一个自己说了算的人生」。他的方向是精神分析，所以一开始就从人的本性出发讲解，包括自恋，性，和攻击性。精神分析由弗洛伊德创立，偏向于潜意识层面的探索和研究。所以，我一开始听的时候，感觉有点观点真不好接受，有些案例的解释，好像也是勉强套入到那三个本性里一样。整体感觉它是偏感性，并且有一些奇幻的色彩。  </p>
<p>从根本上来说，两位老师的课程和观点，都很强调关系的重要性。这也可以说是两门课的核心吧。<strong>人的很多问题都是在关系层面，不能从单一角度来分析</strong>。李松蔚的课偏向理性，从系统，像是从作用力和反作用力的角度来看。武志红的课，偏向于从人的本性，出生后和父母的关系来开始观察和推导。这样的起点，想起来似乎也挺合理的。毕竟一个人从出生开始，最开始的关系就是和养育者的关系，并在其中发展，从一元，二元，到三元。<strong>精神分析里面谈的人的本性，就有点像是经济学里假定人是自私的一样</strong>。  </p>
<p>我觉得我一开始我不太相信精神分析，除了那些感觉比较奇幻的身体感受的例子，和一些解释有点勉强外，很重要的一点是我不确定，性格是否真的在 3 岁或者 6 岁前就定型了。也许，其实是我怕信了这个观点，就杜绝了自己改变的可能，把问题推到原生家庭上。所以，一开始我是比较喜欢李松蔚那个课的。  </p>
<p>后来，听到武志红老师在关系那章所说：“<strong>性格在关系中形成，在关系中展现，在关系中疗愈</strong>” 。当时真是震动了一下，我的一部分性格，即便是小时候的环境造成，但也在关系中逐渐改变。以前的我无法改变，但是未来的我是不受约束的。  </p>
<p>​两边听着听着，慢慢感觉两个角度其实并不冲突，而且很多概念是相通的。  </p>
<p>比如，最近李松蔚的关于「积极赋义」的课程，其实和武志红提到的「人格的对立面」，发现行为背后的积极动力很像。李松蔚在「积极赋义」课程里提到他督导的一个例子，我觉得似乎更像是一个精神分析师可能给出的个案。  </p>
<p>一个一直认为自己比较怂的人，不敢问老板要答应给的奖金。一个心理分析师和他反复理性分析各方面利弊，最后似乎他也觉得自己没什么理由不去，答应了第二天就去。可是，真的有那么简单吗？以前难道从来没人劝说过他？他说有，而且他妈妈从小到大就一直给他各种建议，推着他走。  </p>
<p>所以，松蔚老师觉得，他内心可能还一直在和以前的妈妈喊话，在对抗她。为什么一定要成为妈妈想他成为的样子呢？从松蔚老师的角度来看，他内心的这份对抗，其实是很有力量的，他并不怂。最后，当事人和老师说：“也许他该放下小时候的事了。但是不是现在。等真的放下了，跟心里的母亲取得和解，那个时候他该要的东西都会要回来”。  </p>
<p>有时候，我们只是没有发现自己做某一些事情，或者无法改变的真正原因。<strong>人这种动物，似乎总是需要对任何问题，找到一个让自己相信的解释。并且只有在接受了这个解释之后，才能安心，才可能采取行动，并发生改变</strong>。  </p>
<p>所以，无论是理性，还是从潜意识层面更感性地观察自己，它们只是给我们提供了不同的视角。唯有面对过去，承认，甚至挖掘自我小时候的可能受到的影响，才能真正地看见和认识自己，而不是逃避。相反，不正视自己的内心，问题的根本原因没有找出来，自己想要改变是很难的。最重要的是，无论是什么原因，都要相信自己能改变。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在，我一直在听两个心理学课程。&lt;/p&gt;
&lt;p&gt;一个是李松蔚的「洞悉相处之道」。这个课程给我打开了关系层面如何相处和看待一些问题的新视角。我以前从来不会，也没意识到这个问题。它可以说是给了我一次重生吧，所以，我也到处推荐给朋友。李松蔚一开始是学数学的，只是考北大后被调到心理
    
    </summary>
    
      <category term="Psychology" scheme="http://www.thinkingincrowd.me/categories/Psychology/"/>
    
    
      <category term="Change" scheme="http://www.thinkingincrowd.me/tags/Change/"/>
    
      <category term="Relationship" scheme="http://www.thinkingincrowd.me/tags/Relationship/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的支付业务与模型演变</title>
    <link href="http://www.thinkingincrowd.me/2017/11/11/model-evolvement-for-a-simple-payment-system/"/>
    <id>http://www.thinkingincrowd.me/2017/11/11/model-evolvement-for-a-simple-payment-system/</id>
    <published>2017-11-11T13:42:28.000Z</published>
    <updated>2018-04-10T08:46:23.586Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看 Eric Evans 的 <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_1" target="_blank" rel="external">Domain Driven Design - Tackling Complexity in the Heart of Software</a> 这本书。为了能更深入理解里面的概念，我大致捋了一下最近做的系统里支付模块的演变，希望等不断深入这本书后再重新审视一下目前的设计，看如何改进。  </p>
<p>之前写教程 <a href="http://www.thinkingincrowd.me/2016/11/13/Node-js-Wechat-Web-App-Tutorial-Data-Modeling/">Node.js 微信后台搭建系列 - 数据建模</a> 的时候，一些同学对建模没什么概念。希望这篇文章也能让编程初学者初步理解如何建模，如何随着业务的改变而调整模型。  </p>
<p>下面的一些模型图，和字段名称，我觉得它们的命名应该能表达清楚它们的用途了吧？我就不逐个字段解释了。这里也只是列出最主要的信息而已。一些辅助的，系统流程控制的字段和业务关系不大，主要是取决于实现的方式，也就不列出来了。  </p>
<h2 id="原始阶段"><a href="#原始阶段" class="headerlink" title="原始阶段"></a>原始阶段</h2><p>在我们的系统刚开始实现的时候，由于业务比较简单，支付模块实现的比较简单：  </p>
<ol>
<li><p>微信和我们系统按 T+1 来结算。所以，我们也是直播结束后第二天就把收入拨给主讲人。  </p>
</li>
<li><p>直接在用户表里用 balance 字段表示账户余额。  </p>
</li>
<li><p>只有一个 payments 表。这个表揉合了基本的订单信息，和支付状态信息。  </p>
</li>
</ol>
<p>这样设计的其它考虑是：  </p>
<p>第一，我们并没有普通电商平台那样的购物车，和订单流程。用户如果遇到心仪的课程，他只需要点击购买，支付，然后就可以在他的已购列表看到刚购买的课程了。  </p>
<p>第二，我们用的是 MongoDB。MongoDB 没有 transaction 和 join 的概念。如果把订单和支付信息切分到不同的 collection，操作会变复杂，并还有可能由于操作或数据库错误导致数据不完整。  </p>
<p>所以，最开始的支付模块模型大致如下图。后台有定时 Job 用来计算主讲人收入，和他的各个直播收益的。  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/payment-module-design-phase-1.png" alt="Payment Modeling Phase 1"></p>
<h2 id="冻结部分收益"><a href="#冻结部分收益" class="headerlink" title="冻结部分收益"></a>冻结部分收益</h2><p>到了第二个阶段，出现了一些问题需要我们面对：  </p>
<ol>
<li><p>因为我们售卖的是虚拟商品，微信把我们系统的到帐改为 T+15 了。  </p>
</li>
<li><p>随着直播数的增加，和主讲人资质的放宽，单纯靠运营人员人工根据直播情况来把控主讲人的提现需求越加困难。  </p>
</li>
</ol>
<p>业务上我们也相应要做出调整：  </p>
<ol>
<li><p>主讲人的每一个直播，首笔收益到帐时间为直播结束后 15 天。之后用户的每一笔支付，也延后 15 天才能到帐。  </p>
</li>
<li><p>由于主讲人收入到帐时间大为延长，为了让主讲人更清晰了解他的收入情况，我们为主讲人提供每天收入明细，展示每个直播冻结中，和已经结算的收益情况。  </p>
</li>
</ol>
<p>因此，原来的模型扩展为如下的情况：  </p>
<ol>
<li><p>添加了 <code>transactions</code> collection。它的作用是存放每天聚合了的 <code>payments</code> 数据，为主讲人提供每天收入明细，并记录哪些收益还在冻结中，哪些可以释放出来。  </p>
</li>
<li><p><code>users</code> 和 <code>products</code> 加上 <code>frozenProfit</code> 和 <code>totalProfit</code>。这两个字段都是从 <code>transactions</code> 里面的数据演算得出的。  </p>
</li>
</ol>
<p><img src="http://thinkingincrowd.u.qiniudn.com/payment-module-design-phase-2.png" alt="Payment Modeling Phase 2"></p>
<h2 id="分销"><a href="#分销" class="headerlink" title="分销"></a>分销</h2><p>某一天，CTO 和我说，我们需要实现分销的功能。就这么一句话，你们觉得怎么做？要几天？模型需要改吗？  </p>
<p>模型肯定要变了。为什么？因为不仅仅是直播商品的拥有人，其它的用户都有可能拥有收入。那么，收益相关的数据 <code>frozenProfit</code>, <code>totalProfit</code> 也就不能简单地附着在商品数据，也就是 <code>products</code> collection 里面了。  </p>
<p>所以，我抽出新的 <code>revenue_summary</code> collection 来存放每个用户在某个商品上能获取的收益，和收入来源。当然，<code>products</code> 里的相应字段也就不需要了。  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/payment-module-design-phase-3.png" alt="Payment Modeling Phase 3"></p>
<h2 id="多商户商品打包"><a href="#多商户商品打包" class="headerlink" title="多商户商品打包"></a>多商户商品打包</h2><p>随后，我们又支持了多商户商品打包售卖的需求。  </p>
<p>身为一个平台，在搞活动的时候，我们需要打包优惠出售多个商户的商品。虽然说上面的模型也能基本满足要求，不需要太大的变动也能支持，但是，这种商品的收入计算逻辑，因为涉及多方收入分配，更为复杂，我们觉得还是要做出一些调整。  </p>
<p>我们新增加了一个 <code>payment_instructions</code> collection。  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/payment-module-design-phase-4.png" alt="Payment Modeling Phase 4"></p>
<p>这个模型有什么用呢？  </p>
<p>其实，以前每一笔用户支付给我们的买课程的费用，都被分成好几部分：  </p>
<ol>
<li>微信手续费  </li>
<li>分销渠道费用（如果有的话）  </li>
<li>主讲人分成  </li>
<li>平台分成  </li>
</ol>
<p>除主讲人分成那部分费用之前有明确记录外（因为需要展示给用户看），其它部分其实都隐含在 Job 的收益计算逻辑里面。虽然说我们可以根据每一笔支付费用的总额，协定分成比等数据计算出其它部分，但是当我们想做数据统计，和对账的时候，就比较麻烦了。所以，现在每一笔费用，在成功处理后，我们把帐目明细都记录下来。  </p>
<p>通过这样的调整，今后的数据统计和对账问题得以解决。而且，作为一个商城，以后如果我们还需要拓展积分，钱包余额支付等功能也更方便清晰。  </p>
<p>目前这个支付模块还是有点简陋的，再学习怎么优化吧。AirBnB 的支付系统也是面对各种现实问题后不断演进，有兴趣朋友可以看看它们的 Medium <a href="https://medium.com/airbnb-engineering/scaling-airbnbs-payment-platform-43ebfc99b324" target="_blank" rel="external">文章</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看 Eric Evans 的 &lt;a href=&quot;https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_1&quot; target=&quot;_bl
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Design" scheme="http://www.thinkingincrowd.me/tags/Design/"/>
    
      <category term="Data Modeling" scheme="http://www.thinkingincrowd.me/tags/Data-Modeling/"/>
    
      <category term="DDD" scheme="http://www.thinkingincrowd.me/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>怎样可以不用再写接口文档</title>
    <link href="http://www.thinkingincrowd.me/2017/10/28/no-need-to-write-api-doc-anymore/"/>
    <id>http://www.thinkingincrowd.me/2017/10/28/no-need-to-write-api-doc-anymore/</id>
    <published>2017-10-28T15:03:24.000Z</published>
    <updated>2018-04-10T08:46:23.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码如文档"><a href="#代码如文档" class="headerlink" title="代码如文档"></a>代码如文档</h2><p>绝大多数的程序员，其实都不喜欢写文档。即便是一开始写了文档，随着时间的推移，需求的变更，文档很多情况下都慢慢跟不上变化，最后腐烂变质。看文档还不如看代码。</p>
<p>所以，如何维护文档在软件工程一直都是大问题。  后来，有人提出了一种观点：“让你的代码成为文档”。什么意思？如果你竟然还没听说过这个概念，可以看看 <a href="https://en.wikipedia.org/wiki/Self-documenting_code" target="_blank" rel="external">Wiki</a> 或者 Martin Fowler 的<a href="https://www.martinfowler.com/bliki/CodeAsDocumentation.html" target="_blank" rel="external">文章</a>看看：</p>
<h2 id="接口-vs-契约"><a href="#接口-vs-契约" class="headerlink" title="接口 vs 契约"></a>接口 vs 契约</h2><p>从毕业以来，我做的项目都是前后端一条龙通杀的，从最开始的 vanilla-js，公司内部框架，jQuery, 到 ExtJs。不过，现在很多公司都前后端分离了，前端专职页面，后端提供接口，各司其职。</p>
<p>这种情况下，尤其在大公司里，API 接口文档在合作和沟通层面起非常大的作用。一个好的 API 接口，除了要有良好的命名，统一的风格这样的基本要求外，它接收的参数（数量，格式，限制等），返回值，权限等是更需要关注和保持更新的讯息。一旦这些讯息发生改变，前后端不同步，某个系统功能可能就挂了。所以说，接口文档就是前后端合作契约的说法一点也不夸张。</p>
<h2 id="代码生成文档"><a href="#代码生成文档" class="headerlink" title="代码生成文档"></a>代码生成文档</h2><p>去年 3 月份，我看到陈天在公众号「程序人生」（programmer_life）的文章「<a href="https://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=402114651&amp;idx=1&amp;sn=a7b891f532e29b73afd83f17ae071023&amp;scene=21#wechat_redirect" target="_blank" rel="external">再谈 API 的撰写 - 契约</a>」，很对胃口。我后面就按这样的思路在自己写的 Node.js boilerplate 里面设计了特定的接口定义和编写方式，也在现在的公司一直使用。所有的 HTTP API 都是通过编写描述式的 JSON 来定义的。文档也通过读取这些 JSON 定义来生成。每当接口契约改变，文档就更新了。</p>
<p>那是怎么自动生成的呢？有兴趣的朋友，可以看看我的 Github Repo <a href="https://github.com/kenspirit/joi-route-to-swagger" target="_blank" rel="external">joi-route-to-swagger</a>：</p>
<p>Repo 里面的 README 阐述了基本的理念和用法。更详细的思路，大家还是看陈天的「<a href="https://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=402114651&amp;idx=1&amp;sn=a7b891f532e29b73afd83f17ae071023&amp;scene=21#wechat_redirect" target="_blank" rel="external">再谈 API 的撰写 - 契约</a>」吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码如文档&quot;&gt;&lt;a href=&quot;#代码如文档&quot; class=&quot;headerlink&quot; title=&quot;代码如文档&quot;&gt;&lt;/a&gt;代码如文档&lt;/h2&gt;&lt;p&gt;绝大多数的程序员，其实都不喜欢写文档。即便是一开始写了文档，随着时间的推移，需求的变更，文档很多情况下都慢慢跟不上变
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Node.js" scheme="http://www.thinkingincrowd.me/tags/Node-js/"/>
    
      <category term="API" scheme="http://www.thinkingincrowd.me/tags/API/"/>
    
      <category term="Swagger" scheme="http://www.thinkingincrowd.me/tags/Swagger/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 微信后台搭建系列 - 微信集成</title>
    <link href="http://www.thinkingincrowd.me/2017/07/30/Node-js-Wechat-Web-App-Tutorial-Wechat-Integration/"/>
    <id>http://www.thinkingincrowd.me/2017/07/30/Node-js-Wechat-Web-App-Tutorial-Wechat-Integration/</id>
    <published>2017-07-30T15:30:57.000Z</published>
    <updated>2018-04-10T08:46:23.583Z</updated>
    
    <content type="html"><![CDATA[<p>终于基本到了最后的一步了。微信集成主要包含三个部分：  </p>
<ol>
<li>接入验证，让微信确认你的服务器，就是你公众号的拥有人。  </li>
<li>接收微信给你服务器的消息。  </li>
<li>发送消息给微信服务器，让它转发给你公众号的关注者。  </li>
</ol>
<p>公众号的基本开发，微信的官方文档「<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1472017492_58YV5" target="_blank" rel="external">入门指南</a>」其实已经基本包含所有必须要知道的知识。但是，它的文档是以 Python 为例子，还有一些比较看起来吓死人的流程图，技术细节，和一些个人号没法开通的功能介绍。所以，这篇教程是侧重于个人公众号如何用 JavaScript 来开发实现。  </p>
<h2 id="接入验证"><a href="#接入验证" class="headerlink" title="接入验证"></a>接入验证</h2><p>怎么<a href="https://mp.weixin.qq.com/cgi-bin/loginpage?t=wxm2-login&amp;lang=zh_CN" target="_blank" rel="external">申请微信个人公众号</a>，我就不说了。个人只能申请订阅号。  </p>
<p>申请成功后，登录，点击左边菜单栏下面的「开发」-&gt;「基本配置」，可以看到如下页面：  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/11-wechat-setup.png" alt="Wechat Setup"></p>
<p>先把 <code>开发者ID(AppID)</code> 和 <code>开发者密码(AppSecret)</code> 分别复制出来，保存在一边。<code>令牌(Token)</code> 是自己定的不让别人知道的字符串。下面我们来看看系统里如何配置，接入微信。  </p>
<p>打开命令行，进入你的项目目录，然后输入以下命令：  </p>
<p><code>yo evergrow:wechat</code>  </p>
<p>它会提醒你是否要覆盖 <code>package.json</code> 文件，你可以输入 <code>d</code>，按 <code>Enter</code> 看有什么变动。其实只是新加一些必要的包，所以你输入 <code>Y</code>，然后覆盖就可以了。正常的话，操作后会如下图那样，新生成几个微信相关的文件。  </p>
<p><img src="http://thinkingincrowd.u.qiniudn.com/11-wechat-module-generation.png" alt="Wechat Module Generation"></p>
<p>打开 <code>config/wechat/sample.js</code> 文件，内容如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  appToken: <span class="string">'evergrow'</span>,</div><div class="line">  appId: <span class="string">''</span>,</div><div class="line">  appSecret: <span class="string">''</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你要做的是，复制 <code>sample.js</code> 文件，重命名为 <code>production.js</code>，然后把前面保存的 <code>开发者ID(AppID)</code> 和 <code>开发者密码(AppSecret)</code> 分别赋值给 <code>appId</code> 和 <code>appSecret</code>。<code>appToken</code> 不用理会。<strong>appToken 和 appSecret 可不要让别人知道！</strong>以我的为例：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  appToken: <span class="string">'mytoken'</span>, <span class="comment">// 自己定义，</span></div><div class="line">  appId: <span class="string">'wxe5284a1d0aa6b9fb'</span>,</div><div class="line">  appSecret: <span class="string">'asldgjoieadgkladlj'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置完了以后，你就可以部署到服务器上面了。  </p>
<p>确定你的服务器已经启动后，你就可以在微信「启用」你的服务器了。服务器的 URL 就填你的服务器地址(或 IP)，加上我们微信集成模块的路由 <code>/wechat</code>，比如： <code>http://www.mydomain.com/wechat/</code>。  </p>
<h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>启用后大概要过三五分钟可能才会生效。然后，如果你发一段文字给你的公众号，你的服务器会打印出接受到的消息内容。  </p>
<h3 id="文字消息"><a href="#文字消息" class="headerlink" title="文字消息"></a>文字消息</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  ToUserName: <span class="string">'gh_1bfda0ee00eb'</span>,</div><div class="line">  FromUserName: <span class="string">'oZQ1dwRfxWyDpRjBNBS5DcltOAU4'</span>, <span class="comment">// 发消息给你的用户的 openid</span></div><div class="line">  CreateTime: <span class="string">'1501422823'</span>,</div><div class="line">  MsgType: <span class="string">'text'</span>,</div><div class="line">  Content: <span class="string">'Hello'</span>,</div><div class="line">  MsgId: <span class="string">'6448561922693293780'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关注公众号的消息"><a href="#关注公众号的消息" class="headerlink" title="关注公众号的消息"></a>关注公众号的消息</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  ToUserName: <span class="string">'gh_1bfda0ee00eb'</span>,</div><div class="line">  FromUserName: <span class="string">'oZQ1dwRfxWyDpRjBNBS5DcltOAU4'</span>, <span class="comment">// 关注者的 openid</span></div><div class="line">  CreateTime: <span class="string">'1501423109'</span>,</div><div class="line">  MsgType: <span class="string">'event'</span>,</div><div class="line">  Event: <span class="string">'subscribe'</span>,</div><div class="line">  EventKey: <span class="string">''</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="图片消息"><a href="#图片消息" class="headerlink" title="图片消息"></a>图片消息</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  ToUserName: <span class="string">'gh_1bfda0ee00eb'</span>,</div><div class="line">  FromUserName: <span class="string">'oZQ1dwRfxWyDpRjBNBS5DcltOAU4'</span>,</div><div class="line">  CreateTime: <span class="string">'1501423196'</span>,</div><div class="line">  MsgType: <span class="string">'image'</span>,</div><div class="line">  PicUrl: <span class="string">'http://mmbiz.qpic.cn/mmbiz_jpg/zQibzicfvUiciaoqcE4kibLSnIvGs2SI0g5zHSnUQFeXvom1SHLEAHK8csInU7jXodQaG1ScxibfwkSG7MEK09xyukTQ/0'</span>,</div><div class="line">  MsgId: <span class="string">'6448563524716095218'</span>,</div><div class="line">  MediaId: <span class="string">'t-4AThjfL-GK2vbKh3XRX9go-DE-Z3hvHNFwA9Bb2Ep_xUK5r13eYlJqsD8FLqqw'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>知道了上面几大类型的消息格式，我们就可以做一些东西了。  </p>
<p>微信消息的接收和处理，都在 <code>wechat/wechat-controller.js</code> 里面的 <code>wechatMsg</code> 方法里处理就可以了。它默认生成的代码是这样的：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports.wechatMsg = WechatManager.getWechatRouter(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="comment">// 微信输入信息都在req.weixin上</span></div><div class="line">  <span class="keyword">var</span> message = req.weixin</div><div class="line">  <span class="built_in">console</span>.log(message);</div><div class="line"></div><div class="line">  res.reply(<span class="string">''</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="关注自动回复"><a href="#关注自动回复" class="headerlink" title="关注自动回复"></a>关注自动回复</h3><p>如果要在用户关注后自动回复，我们可以在上面的方法里加如下的代码：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">  <span class="built_in">module</span>.exports.wechatMsg = WechatManager.getWechatRouter(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    <span class="comment">// 微信输入信息都在req.weixin上</span></div><div class="line">    <span class="keyword">var</span> message = req.weixin</div><div class="line">    <span class="built_in">console</span>.log(message);</div><div class="line"></div><div class="line">    <span class="comment">// 自动回复处理</span></div><div class="line">    <span class="keyword">if</span> (message.MsgType === <span class="string">'event'</span> &amp;&amp; message.Event === <span class="string">'subscribe'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> res.reply(<span class="string">`非常感谢你的关注。点击菜单栏的 “历史文章” 可查看我精心分类的文章列表。</span></div><div class="line"></div><div class="line">儿子，丈夫，父亲，程序员。每一个标签，都是对我的一个要求。在这里，所有的文字都用心创作，记录了我在每一个标签下逐渐成长的经历和思考。希望某一篇文章，甚至某一句话，能与你产生共鸣。</div><div class="line"></div><div class="line">&lt;a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzI0NDEwMDk2NQ==&amp;hid=1&amp;sn=b1cd332c53a573ea36c4a71e19f47539#wechat_redirect"&gt;历史文章&lt;/a&gt;`)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    res.reply(<span class="string">''</span>)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p><em>因为启用自己的服务器后，自定义菜单功能就没有了，我只能在关注自动回复加链接去我的历史文章页了（哭）。</em></p>
<h3 id="回复用户发来的图片"><a href="#回复用户发来的图片" class="headerlink" title="回复用户发来的图片"></a>回复用户发来的图片</h3><p>如果我们想直接把用户发给我们的图片回复回去，我们可以这样做：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports.wechatMsg = WechatManager.getWechatRouter(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="comment">// 微信输入信息都在req.weixin上</span></div><div class="line">  <span class="keyword">var</span> message = req.weixin</div><div class="line">  <span class="built_in">console</span>.log(message);</div><div class="line"></div><div class="line">  <span class="comment">// 自动回复用户发来的图片</span></div><div class="line">  <span class="keyword">if</span> (message.MsgType === <span class="string">'image'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> res.reply(&#123;</div><div class="line">      type: <span class="string">'image'</span>,</div><div class="line">      content: &#123;</div><div class="line">        mediaId: message.MediaId <span class="comment">// 用回微信告诉我们的用户发来的图片 MediaId</span></div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  res.reply(<span class="string">''</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>有了这些基础，你可以按自己的需求，来实现其它自动回复的功能。下一章我们再看如何结合之前的系统，随机抽取系统接收的其它用户发来的图片，而不是返回自己当前发来图片。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于基本到了最后的一步了。微信集成主要包含三个部分：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接入验证，让微信确认你的服务器，就是你公众号的拥有人。  &lt;/li&gt;
&lt;li&gt;接收微信给你服务器的消息。  &lt;/li&gt;
&lt;li&gt;发送消息给微信服务器，让它转发给你公众号的关注者。  &lt;/li
    
    </summary>
    
      <category term="Sword" scheme="http://www.thinkingincrowd.me/categories/Sword/"/>
    
    
      <category term="Node.js" scheme="http://www.thinkingincrowd.me/tags/Node-js/"/>
    
      <category term="Wechat" scheme="http://www.thinkingincrowd.me/tags/Wechat/"/>
    
      <category term="Tutorial" scheme="http://www.thinkingincrowd.me/tags/Tutorial/"/>
    
      <category term="MVC" scheme="http://www.thinkingincrowd.me/tags/MVC/"/>
    
      <category term="Integration" scheme="http://www.thinkingincrowd.me/tags/Integration/"/>
    
  </entry>
  
</feed>
